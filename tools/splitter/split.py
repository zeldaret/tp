"""
split.py - 202x erin moon for zeldaret
"""

from typing import Iterable, List
from dataclasses import dataclass
from pathlib import Path, PosixPath
from textwrap import dedent
from loguru import logger
from datetime import datetime
import re
import click
import itertools
from asm import asm, Emittable, Global, Label, Line, BlockComment, Instruction

__version__ = 'v0.2'

def pairwise(iterable):
    "s -> (s0,s1), (s1,s2), (s2, s3), ..."
    a, b = itertools.tee(iterable)
    next(b, None)
    return itertools.zip_longest(a, b)


def function_global_search(lines: List[Line]) -> Iterable[Line]:
    i = 0
    while i < len(lines):
        if isinstance(lines[i].body, Global):
            sym = lines[i].body.symbol
            if isinstance(lines[i+1].body, Label) and lines[i+1].body.symbol == sym:
                yield lines[i]
            i += 2
        else:
            i += 1


def emit_lines(lines: List[Line]) -> str:
    return '\n'.join([line.emit() for line in lines])

def comment_out(line: Emittable) -> Line:
    return BlockComment(line.emit())

@dataclass
class Function:
    name: str
    addr: int
    lines: List[Line]

    @property
    def line_count(self):
        return len(self.lines)
    
    @property
    def filename(self) -> str:
        return f'func_{self.addr:X}.s'
    
    def include_path(self, base: Path) -> str:
        return str(PosixPath(base) / PosixPath(self.filename))

def find_functions(lines: List[Line]) -> Iterable[Function]:
    for func_global_line, next_func_global_line in pairwise(function_global_search(lines)):
        fr = func_global_line.index + 2
        to = next_func_global_line.index if next_func_global_line is not None else -1
        func_lines = lines[fr:to]
        addr = int(func_lines[0].content[0].text.strip().split()[0], 16)

        yield Function(name=func_global_line.body.symbol,
                addr=addr,
                lines=func_lines)

def emit_cxx_asmfn(inc_base: Path, func: Function) -> str:
    return dedent('''\
        asm void {name}(void) {{
            nofralloc
            #include "{inc}"
        }}'''.format(name=func.name,
                     inc=func.include_path(inc_base)))

def emit_cxx_extern_fns(tu_file: str, labels: Iterable[str]) -> str:
    def decl(label):
        return f'void {label}(void);'

    defs = '\n    '.join(decl(label) for label in labels)

    return (f'// additional symbols needed for {tu_file}\n'
            f'// autogenerated by split.py {__version__} at {datetime.utcnow()}\n'
            'extern "C" {\n'
            '    ' + defs
            +'\n}'
    )

def emit_cxx_extern_vars(tu_file: str, labels: Iterable[str]) -> str:
    def decl(label):
        return f'extern u8 {label};'

    return (
        f'// additional symbols needed for {tu_file}\n'
        f'// autogenerated by split.py {__version__} at {datetime.utcnow()}\n'
        + '\n'.join(decl(label) for label in labels)
        + '\n'
    )

@click.command()
@click.argument('src', type=click.File('r'))
@click.argument('cxx_out', type=click.Path(file_okay=True, dir_okay=False))
@click.option('--funcs-out', type=click.Path(file_okay=False, dir_okay=True), default='include/funcs')
@click.option('--s-include-base', type=str, default='funcs')
@click.option('--extern-functions-file', type=click.Path(file_okay=True, dir_okay=False), default='include/functions.h')
@click.option('--extern-variables-file', type=click.Path(file_okay=True, dir_okay=False), default='include/variables.h')
@click.option('--from-line', type=int)
@click.option('--to-line', type=int)
def split(src, cxx_out, funcs_out, s_include_base, extern_functions_file,
        extern_variables_file, from_line, to_line):
    funcs_out_dir = Path(funcs_out)
    funcs_out_dir.mkdir(exist_ok=True)

    cxx_out = Path(cxx_out)

    lines = asm.parse(src.read())
    lines = lines[(from_line-1 if from_line else 0):(to_line-1 if to_line else -1)]

    with open(extern_functions_file, 'r') as f:
        extern_funcs_src = f.read()
    with open(extern_variables_file, 'r') as f:
        extern_vars_src = f.read()

    # -- get all defined labels and jump targets
    jumped_labels = set()
    defined_labels = set()

    for line in lines:
        if isinstance(line.body, Label):
            defined_labels.add(line.body.symbol)
        if isinstance(line.body, Instruction):
            if line.body.opcode[0] == 'b' and line.body.operands != []: # branch
                jumped_labels.add(line.body.operands[0]) #jump target

    # -- find everything of the form lbl_[hex] that's in an operand on the RHS of a l* instruction
    #    this is a relatively okay assumption given that any var that's *not* of the form lbl_ has
    #    probably already been renamed and thus is exported in variables.h
    LBL_RE = re.compile(r'lbl_[0-9A-F]+')
    def find_labels_in_operands(operands):
        for operand in operands:
            if match := LBL_RE.search(operand):
                yield match.group()

    loaded_labels = set()
    for line in lines:
        if isinstance(line.body, Instruction):
            if line.body.opcode[0] in {'l', 's'}: # load and store instructions, ish
                loaded_labels |= set(find_labels_in_operands(line.body.operands))

    # -- dump new variable labels to variables.h

    vars_new = set()
    for label in loaded_labels:
        if label not in extern_vars_src:
            logger.info(f'adding extern var {label} to {extern_variables_file}')
            vars_new.add(label)
    
    if len(vars_new) > 0:
        with open(extern_variables_file, 'a') as f:
            f.write('\n\n')
            f.write(emit_cxx_extern_vars(cxx_out.name, vars_new))

    # -- find all defined functions and split them
    functions = list(find_functions(lines))
    for func in functions:

        logger.debug(f'working on function {func.name} @ {func.addr:X} with {func.line_count} lines')

        # comment out .globals
        func.lines = [comment_out(line) if isinstance(line.body, Global) else line for line in func.lines]

        with open(out_path := funcs_out_dir / func.filename, 'w') as f:
            logger.debug(f'emitting {out_path}')
            f.write(emit_lines(func.lines))
    
    # -- dump new labels to functions.h
    func_labels = jumped_labels - defined_labels
    # add in everything we def to make sure asm can get backrefs
    for func in functions:
        func_labels.add(func.name)

    # get rid of stuff already in functions.h. extremely hacky
    funcs_new_labels = set()
    for label in func_labels:
        if label not in extern_funcs_src:
            logger.info(f'adding extern func {label} to {extern_functions_file}')
            funcs_new_labels.add(label)

    if len(funcs_new_labels) > 0:
        with open(extern_functions_file, 'a') as f:
            f.write('\n\n')
            f.write(emit_cxx_extern_fns(cxx_out.name, funcs_new_labels))

    # -- write asm stubs to cxx_out (could've done this as part of previous loop but imo this is cleaner)
    logger.info(f'emitting asm stubs to {cxx_out}')
    with open(cxx_out, 'w') as f:
        f.write(f'/* {cxx_out.name} autogenerated by split.py {__version__} at {datetime.utcnow()} */\n\n')
        f.write('#include "global.h"\n\n')
        
        f.write('extern "C" {\n')
        for func in functions:
            logger.debug(f'emitting asm stub for {func.name}')
            f.write(emit_cxx_asmfn(s_include_base, func))
            f.write('\n\n')

        f.write('}; // extern "C"\n')

if __name__ == '__main__':
    split()