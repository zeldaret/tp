/* c_xyz.cpp autogenerated by split.py v0.1 at 2020-12-27 17:32:37.883661 */

#include "SComponent/c_xyz.h"
#include "msl_c/math.h"

extern "C" {
void __ml__4cXyzCFf(void);
void cM_atan2s__Fff(void);
void cXyz_NS_dtor(void);
void normZP__4cXyzCFv(void);
void func_80361C24(void);
}

extern float lbl_80450AEC[4];  // array to force 2 step load, MSL_C.PPCEABI.bare.H::__f32_epsilon
extern f32 lbl_80450AE0[4];

const static f32 lbl_80455070 = 1.0f;
const static f32 lbl_80455078 = 1.25f;
const static f32 lbl_8045507C = 1000000.0f;
const static f32 lbl_80455080 = 0.0f;
const static f32 lbl_80455084 = 32.0f;
const static f64 lbl_80455088 = 0.5;
const static f64 lbl_80455090 = 3.0;
const static f64 lbl_80455098 = 0.0;

// __pl__4cXyzCFRC3Vec
cXyz cXyz::operator+(const Vec& vec) const {
    Vec ret;
    PSVECAdd(this, &vec, &ret);
    return cXyz(ret);
}

// __mi__4cXyzCFRC3Vec
cXyz cXyz::operator-(const Vec& vec) const {
    Vec ret;
    PSVECSubtract(this, &vec, &ret);
    return cXyz(ret);
}

// __ml__4cXyzCFf
cXyz cXyz::operator*(f32 scale) const {
    Vec ret;
    PSVECScale(this, &ret, scale);
    return cXyz(ret);
}

inline void vecMul(const Vec* src1, const Vec* src2, Vec* dst) {
    dst->x = src1->x * src2->x;
    dst->y = src1->y * src2->y;
    dst->z = src1->z * src2->z;
}

// __ml__4cXyzCFRC3Vec
cXyz cXyz::operator*(const Vec& vec) const {
    cXyz ret;
    vecMul(this, &vec, &ret);
    return cXyz(ret);
}

// __dv__4cXyzCFf
cXyz cXyz::operator/(f32 scale) const {
    Vec ret;
    PSVECScale(this, &ret, /* 1.0 */ FLOAT_LABEL(lbl_80455070) / scale);
    return cXyz(ret);
}

// getCrossProduct__4cXyzCFRC3Vec
cXyz cXyz::getCrossProduct(const Vec& vec) const {
    Vec ret;
    PSVECCrossProduct(this, &vec, &ret);
    return cXyz(ret);
}

// outprod__4cXyzCFRC3Vec
cXyz cXyz::outprod(const Vec& vec) const {
    return this->getCrossProduct(vec);
}

// norm__4cXyzCFv
cXyz cXyz::norm(void) const {
    Vec ret;
    PSVECNormalize(this, &ret);
    return cXyz(ret);
}

// normZP__4cXyzCFv
cXyz cXyz::normZP(void) const {
    Vec vec;
    if (this->isNearZeroSquare() == false) {
        PSVECNormalize(this, &vec);
    } else {
        vec = lbl_80430CF4;
    }
    return cXyz(vec);
}

inline void normToUpZIfNearZero(Vec& vec) {
    if (cXyz(vec).isNearZeroSquare()) {
        vec.x = FLOAT_LABEL(lbl_80455080);
        vec.y = FLOAT_LABEL(lbl_80455080);
        vec.z = FLOAT_LABEL(lbl_80455070);
        const Vec v = {0, 0, 1};
        vec = v;
    }
}

// normZC__4cXyzCFv
cXyz cXyz::normZC(void) const {
    Vec outVec;
    if (this->isNearZeroSquare() == false) {
        PSVECNormalize(this, &outVec);
    } else {
        outVec = (*this * FLOAT_LABEL(lbl_80455078) * FLOAT_LABEL(lbl_8045507C)).normZP();
        normToUpZIfNearZero(outVec);
    }
    return outVec;
}

// normalize__4cXyzFv
cXyz cXyz::normalize(void) {
    PSVECNormalize(this, this);
    return *this;
}

// normalizeZP__4cXyzFv
cXyz cXyz::normalizeZP(void) {
    if (this->isNearZeroSquare() == false) {
        PSVECNormalize(this, this);
    } else {
        *this = lbl_80430CF4;
    }
    return *this;
}

// normalizeRS__4cXyzFv
bool cXyz::normalizeRS(void) {
    if (this->isNearZeroSquare()) {
        return false;
    } else {
        PSVECNormalize(this, this);
        return true;
    }
}

// __eq__4cXyzCFRC3Vec
bool cXyz::operator==(const Vec& vec) const {
    return this->x == vec.x && this->y == vec.y && this->z == vec.z;
}

// __ne__4cXyzCFRC3Vec
bool cXyz::operator!=(const Vec& vec) const {
    return !(this->x == vec.x && this->y == vec.y && this->z == vec.z);
}

// isZero__4cXyzCFv
bool cXyz::isZero(void) const {
    return fabsf(this->x) <
               /* 32 */ FLOAT_LABEL(lbl_80455084) *
                   /* MSL_C.PPCEABI.bare.H::__f32_epsilon */ lbl_80450AEC[0] &&
           fabsf(this->y) < FLOAT_LABEL(lbl_80455084) * lbl_80450AEC[0] &&
           fabsf(this->z) < FLOAT_LABEL(lbl_80455084) * lbl_80450AEC[0];
}

// atan2sX_Z__4cXyzCFv
s16 cXyz::atan2sX_Z(void) const {
    return cM_atan2s(this->x, this->z);
}

inline f32 VecMagXZ(const cXyz& xyz) {
    return cXyz(xyz.x, FLOAT_LABEL(lbl_80455080), xyz.z).getSquareMag();
    // return cXyz(xyz.x, 0, xyz.z).getSquareMag(); // matches, but screws up data
}

// this belongs to msl_c/math.h, but can't go there currently because of data
inline f32 sqrtf(f32 mag) {
    if (mag > FLOAT_LABEL(lbl_80455080)) {
        f64 tmpd = __frsqrte(mag);
        tmpd = DOUBLE_LABEL(lbl_80455088) * tmpd * (DOUBLE_LABEL(lbl_80455090) - tmpd * tmpd * mag);
        tmpd = DOUBLE_LABEL(lbl_80455088) * tmpd * (DOUBLE_LABEL(lbl_80455090) - tmpd * tmpd * mag);
        return DOUBLE_LABEL(lbl_80455088) * tmpd *
               (DOUBLE_LABEL(lbl_80455090) - tmpd * tmpd * mag) * mag;
    } else if (mag < DOUBLE_LABEL(lbl_80455098)) {
        return /* __float_nan */ lbl_80450AE0[0];
    } else if (fpclassify(mag) == 1) {
        return /* __float_nan */ lbl_80450AE0[0];
    } else {
        return mag;
    }
}

// atan2sY_XZ__4cXyzCFv
#ifdef NON_MATCHING
s16 cXyz::atan2sY_XZ(void) const {
    f32 mag = VecMagXZ(*this);  // would match if the float literal in VecMagXZ would be used
    return cM_atan2s(-this->y, sqrtf(mag));
}
#else
asm s16 cXyz::atan2sY_XZ(void) const {
    nofralloc
#include "SComponent/c_xyz/asm/func_80267150.s"
}
#endif

extern "C" {

// __sinit_c_xyz_cpp
asm void __sinit_c_xyz_cpp(void) {
    nofralloc
#include "SComponent/c_xyz/asm/func_80267290.s"
}
};
