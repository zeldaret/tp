/* c_angle.cpp autogenerated by split.py v0.3 at 2020-12-31 13:27:46.813506 */

#include "SComponent/c_angle.h"
#include "global.h"

extern "C" {

float cAngle_NS_Adjust(float, float, float);
}

// additional symbols needed for c_angle.cpp
// autogenerated by split.py v0.3 at 2020-12-31 13:27:46.742344
extern float lbl_80455208;   // SComponent::@2248, 182.04445f
extern float lbl_8045520C;   // SComponent::@2260, 0.005493164f
extern double lbl_80455210;  // SComponent::@2263, 4.503601774854144E15
extern float lbl_80455218;   // SComponent::@2269, 9.58738E-5
extern float lbl_8045521C;   // SComponent::@2277, 3.0517578E-5
extern float lbl_80455220;   // SComponent::@2440, -180.0f
extern float lbl_80455224;   // SComponent::@2441, 180.0
extern float lbl_80455228;   // SComponent::@2474, 0.017453292
extern float lbl_8045522C;   // SComponent::@2491, 0.0f
extern double lbl_80455230;  // SComponent::@2671, 0.0
extern float lbl_80455238;   // SComponent::@2672, 10430.378f
extern float lbl_8045523C;   // SComponent::@2744, 1.0
extern u8 lbl_80430F98;      // SComponent::@2401

// __ct__7cSAngleFRC7cSAngle
cSAngle::cSAngle(const cSAngle& angle) {
    this->Val(angle);
}

// __ct__7cSAngleFs
cSAngle::cSAngle(s16 angle) {
    this->Val(angle);
}

// __ct__7cSAngleFf
cSAngle::cSAngle(float angle) {
    this->Val(angle);
}

// Val__7cSAngleFRC7cSAngle
void cSAngle::Val(const cSAngle& other) {
    this->mAngle = other.mAngle;
}

// Val__7cSAngleFs
void cSAngle::Val(s16 val) {
    this->mAngle = val;
}

// Val__7cSAngleFf
void cSAngle::Val(float f) {
    this->mAngle = lbl_80455208 * f;
}

// Degree__7cSAngleCFv
#ifdef NON_MATCHING
float cSAngle::Degree(void) const {
    // matches, but adds a double constant for the s16 -> float conversion
    return lbl_8045520C * this->angle;
}
#else
asm float cSAngle::Degree(void) const {
    nofralloc
#include "SComponent/c_angle/asm/func_80271030.s"
}
#endif

// Radian__7cSAngleCFv
#ifdef NON_MATCHING
float cSAngle::Radian(void) const {
    // matches, but adds a double constant for the s16 -> float conversion
    return lbl_80455218 * this->angle;
}
#else
asm float cSAngle::Radian(void) const {
    nofralloc
#include "SComponent/c_angle/asm/func_80271064.s"
}
#endif

// Norm__7cSAngleCFv
// cSAngle::Norm(void) const
asm float cSAngle::Norm(void) const {nofralloc
#include "SComponent/c_angle/asm/func_80271098.s"
}

// Abs__7cSAngleCFv
s16 cSAngle::Abs(void) const {
    return mAngle >= 0 ? mAngle : -mAngle;
}

// Inv__7cSAngleCFv
s16 cSAngle::Inv(void) const {
    return mAngle - 0x8000;
}

// Sin__7cSAngleCFv
float cSAngle::Sin(void) const {
    return func_8036C590(this->Radian());
}

// Cos__7cSAngleCFv
float cSAngle::Cos(void) const {
    return func_8036C028(this->Radian());
}

// __mi__7cSAngleCFv
cSAngle cSAngle::operator-(void) const {
    return cSAngle((s16)-mAngle);
}

// __pl__7cSAngleCFRC7cSAngle
cSAngle cSAngle::operator+(const cSAngle& other) const {
    return cSAngle((s16)(mAngle + other.mAngle));
}

// __mi__7cSAngleCFRC7cSAngle
cSAngle cSAngle::operator-(const cSAngle& other) const {
    return cSAngle((s16)(mAngle - other.mAngle));
}

// __apl__7cSAngleFRC7cSAngle
void cSAngle::operator+=(const cSAngle& other) {
    mAngle += other.mAngle;
}

// __ami__7cSAngleFRC7cSAngle
void cSAngle::operator-=(const cSAngle& other) {
    mAngle -= other.mAngle;
}

// __pl__7cSAngleCFs
cSAngle cSAngle::operator+(short other) const {
    return cSAngle((s16)(mAngle + other));
}

// __mi__7cSAngleCFs
cSAngle cSAngle::operator-(short other) const {
    return cSAngle((s16)(mAngle - other));
}

// __apl__7cSAngleFs
void cSAngle::operator+=(short other) {
    mAngle += other;
}

// __ml__7cSAngleCFf
#ifdef NON_MATCHING
cSAngle cSAngle::operator*(float f1) const {
    return cSAngle((s16)(angle * f1));
}
#else
asm cSAngle cSAngle::operator*(float) const {
    nofralloc
#include "SComponent/c_angle/asm/func_80271264.s"
}
#endif

// __amu__7cSAngleFf
#ifdef NON_MATCHING
void cSAngle::operator*=(float f1) {
    this->angle *= f1;
}
#else
asm void cSAngle::operator*=(float) {
    nofralloc
#include "SComponent/c_angle/asm/func_802712B4.s"
}
#endif

// __pl__FsRC7cSAngle
cSAngle operator+(short other, const cSAngle& angle) {
    return cSAngle((s16)(other + angle.Val()));
}

// __mi__FsRC7cSAngle
cSAngle operator-(short other, const cSAngle& angle) {
    return cSAngle((s16)(other - angle.Val()));
}

// __ct__7cDegreeFf
cDegree::cDegree(float f) {
    this->Val(f);
}

// Formal__7cDegreeFv
cDegree& cDegree::Formal(void) {
    mDegree = cAngle_NS_Adjust(mDegree, lbl_80455220, lbl_80455224);
    return *this;
}

// Val__7cDegreeFf
void cDegree::Val(float f) {
    mDegree = f;
    this->Formal();
}

// Radian__7cDegreeCFv
float cDegree::Radian(void) const {
    return lbl_80455228 * mDegree;
}

// Sin__7cDegreeCFv
float cDegree::Sin(void) const {
    return func_8036C590(this->Radian());
}

// Cos__7cDegreeCFv
float cDegree::Cos(void) const {
    return func_8036C028(this->Radian());
}

// Tan__7cDegreeCFv
float cDegree::Tan(void) const {
    return func_8036C668(this->Radian());
}

// __ct__7cSPolarFRC4cXyz
cSPolar::cSPolar(const cXyz& xyz) {
    this->Val(xyz);
}

// Formal__7cSPolarFv
cSPolar& cSPolar::Formal(void) {
    if (mRadial < /* 0.0 */ lbl_8045522C) {
        mRadial = -mRadial;
        cSAngle tmp((s16)-0x8000);
        mAngle1.Val(tmp - mAngle1);
        mAngle2.Val(mAngle2.Inv());
    }
    if (mAngle1.Val() < 0 && mAngle1.Val() != -0x8000) {
        mAngle1.Val(-mAngle1);
        mAngle2.Val(mAngle2.Inv());
    }
    return *this;
}

// Val__7cSPolarFfss
void cSPolar::Val(float f, short s1, short s2) {
    mRadial = f;
    mAngle1 = cSAngle(s1);
    mAngle2 = cSAngle(s2);
    this->Formal();
}

inline double square(float f) {
    return f * f;
}

// Val__7cSPolarFRC4cXyz
void cSPolar::Val(const cXyz& xyz) {
    float x, y, z, tmp4;
    x = xyz.x;
    y = xyz.y;
    z = xyz.z;
    double tmp = square(z) + square(x);
    double tmp2 = square(y) + tmp;
    tmp4 = (tmp > lbl_80455230) ? (float)func_8036CA54(tmp) : lbl_8045522C;
    mRadial = (tmp2 > lbl_80455230) ? (float)func_8036CA54(tmp2) : lbl_8045522C;
    mAngle1.Val((s16)(cM_atan2f(tmp4, y) * lbl_80455238));
    mAngle2.Val((s16)(cM_atan2f(x, z) * lbl_80455238));
    this->Formal();
}

// Xyz__7cSPolarCFv
cXyz cSPolar::Xyz(void) const {
    float ang1Cos;
    float ang2Cos;
    float ang1Sin = mRadial * (float)func_8036C590(mAngle1.Radian());
    ang2Cos = (float)func_8036C028(mAngle2.Radian());
    ang1Cos = mRadial * (float)func_8036C028(mAngle1.Radian());
    float ang2Sin = func_8036C590(mAngle2.Radian());
    return cXyz(ang1Sin * ang2Sin, ang1Cos, ang1Sin * ang2Cos);
}

// Globe__7cSPolarCFP7cSGlobe
void cSPolar::Globe(cSGlobe* globe) const {
    globe->Val(mRadial, 0x4000 - mAngle1.Val(), mAngle2.Val());
}

// __ct__7cSGlobeFRC7cSGlobe
cSGlobe::cSGlobe(const cSGlobe& other) {
    this->Val(other);
}

// __ct__7cSGlobeFfss
cSGlobe::cSGlobe(float f, short s1, short s2) {
    this->Val(f, s1, s2);
}

// __ct__7cSGlobeFfRC7cSAngleRC7cSAngle
cSGlobe::cSGlobe(float f, const cSAngle& a1, const cSAngle& a2) {
    this->Val(f, a1, a2);
}

// __ct__7cSGlobeFRC4cXyz
cSGlobe::cSGlobe(const cXyz& xyz) {
    this->Val(xyz);
}

// Formal__7cSGlobeFv
cSGlobe& cSGlobe::Formal(void) {
    if (mRadius < lbl_8045522C) {
        mRadius = -mRadius;
        mAzimuth = -mAzimuth;
        mInclination.Val(mInclination.Inv());
    }
    if (mAzimuth.Val() < -0x4000 || 0x4000 < mAzimuth.Val()) {
        mAzimuth.mirrorAtMaxNeg();
        mInclination.Val(mInclination.Inv());
    }
    return *this;
}

// Val__7cSGlobeFRC7cSGlobe
void cSGlobe::Val(const cSGlobe& other) {
    mRadius = other.mRadius;
    mAzimuth = other.mAzimuth;
    mInclination = other.mInclination;
    this->Formal();
}

// Val__7cSGlobeFfss
void cSGlobe::Val(float f, short s1, short s2) {
    mRadius = f;
    mAzimuth = cSAngle(s1);
    mInclination = cSAngle(s2);
    this->Formal();
}

// Val__7cSGlobeFfRC7cSAngleRC7cSAngle
void cSGlobe::Val(float f, const cSAngle& a1, const cSAngle& a2) {
    mRadius = f;
    mAzimuth = cSAngle(a1.Val());
    mInclination = cSAngle(a2.Val());
    this->Formal();
}

// Val__7cSGlobeFRC4cXyz
void cSGlobe::Val(const cXyz& xyz) {
    cSPolar csp(xyz);
    csp.Globe(this);
    this->Formal();
}

// Xyz__7cSGlobeCFv
cXyz cSGlobe::Xyz(void) const {
    cSPolar csp;
    this->Polar(&csp);
    return csp.Xyz();
}

// Polar__7cSGlobeCFP7cSPolar
// cSGlobe::Polar(cSPolar*) const
void cSGlobe::Polar(cSPolar* csp) const {
    csp->Val(mRadius, 0x4000 - mAzimuth.Val(), mInclination.Val());
}

// Norm__7cSGlobeCFv
cXyz cSGlobe::Norm(void) const {
    cSGlobe glob(/* 1.0 */ lbl_8045523C, mAzimuth, mInclination);
    return glob.Xyz();
}

// Invert__7cSGlobeFv
cSGlobe& cSGlobe::Invert(void) {
    mRadius = -mRadius;
    return this->Formal();
}

extern "C" {

// Adjust<f>__6cAngleFfff
float cAngle_NS_Adjust(float f1, float f2, float f3) {
    while (f1 >= f3) {
        f1 -= f3 - f2;
    }
    while (f1 < f2) {
        f1 += f3 - f2;
    }
    return f1;
}

// __sinit_c_angle_cpp
//
asm void func_80271BD4(void) {
    nofralloc
#include "SComponent/c_angle/asm/func_80271BD4.s"
}
};
