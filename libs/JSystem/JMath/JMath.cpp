//
// Generated By: dol2asm
// Translation Unit: JMath
//

#include "JSystem/JMath/JMath.h"
#include "dol2asm.h"

//
// Forward References:
//

extern "C" void JMAEulerToQuat__FsssP10Quaternion();
extern "C" void JMAQuatLerp__FPC10QuaternionPC10QuaternionfP10Quaternion();
extern "C" void JMAFastVECNormalize__FPC3VecP3Vec();
extern "C" void JMAVECScaleAdd__FPC3VecPC3VecP3Vecf();
extern "C" void JMAMTXApplyScale__FPA4_CfPA4_ffff();

//
// External References:
//

extern "C" u8 sincosTable___5JMath[65536];

//
// Declarations:
//

/* 80339878-80339938 3341B8 00C0+00 0/0 11/11 2/2 .text            JMAEulerToQuat__FsssP10Quaternion
 */
#ifdef NONMATCHING
void JMAEulerToQuat(s16 x, s16 y, s16 z, Quaternion* quat) {
    f32 cosX = JMASCos(x / 2);
    f32 cosY = JMASCos(y / 2);
    f32 cosZ = JMASCos(z / 2);
    f32 sinX = JMASSin(x / 2);
    f32 sinY = JMASSin(y / 2);
    f32 sinZ = JMASSin(z / 2);

    f32 cyz = cosY * cosZ;
    f32 syz = sinY * sinZ;
    quat->w = cosX * (cyz) + sinX * (syz);
    quat->x = sinX * (cyz) - cosX * (syz);
    quat->y = cosZ * (cosX * sinY) + sinZ * (sinX * cosY);
    quat->z = sinZ * (cosX * cosY) - cosZ * (sinX * sinY);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JMAEulerToQuat(s16 param_0, s16 param_1, s16 param_2, Quaternion* param_3) {
    nofralloc
#include "asm/JSystem/JMath/JMath/JMAEulerToQuat__FsssP10Quaternion.s"
}
#pragma pop
#endif

/* 80339938-80339A30 334278 00F8+00 0/0 5/5 0/0 .text
 * JMAQuatLerp__FPC10QuaternionPC10QuaternionfP10Quaternion     */
void JMAQuatLerp(register const Quaternion* p, register const Quaternion* q, f32 t,
                 Quaternion* dst) {
    register f32 pxy, pzw, qxy, qzw;
    register f32 dp;
    __asm  // compute dot product
    {
        psq_l       pxy, 0(p), 0, 0
        psq_l       qxy, 0(q), 0, 0
        ps_mul      dp, pxy, qxy
        
        psq_l       pzw, 8(p), 0, 0
        psq_l       qzw, 8(q), 0, 0
        ps_madd     dp, pzw, qzw, dp
        
        ps_sum0     dp, dp, dp, dp
    }

    if (dp < 0.0) {
        dst->x = -t * (p->x + q->x) + p->x;
        dst->y = -t * (p->y + q->y) + p->y;
        dst->z = -t * (p->z + q->z) + p->z;
        dst->w = -t * (p->w + q->w) + p->w;
    }
    else {
        dst->x = -t * (p->x - q->x) + p->x;
        dst->y = -t * (p->y - q->y) + p->y;
        dst->z = -t * (p->z - q->z) + p->z;
        dst->w = -t * (p->w - q->w) + p->w;
    }
}

/* 80339A30-80339A5C 334370 002C+00 0/0 1/1 0/0 .text            JMAFastVECNormalize__FPC3VecP3Vec
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JMAFastVECNormalize(Vec const* param_0, Vec* param_1) {
    nofralloc
#include "asm/JSystem/JMath/JMath/JMAFastVECNormalize__FPC3VecP3Vec.s"
}
#pragma pop

/* 80339A5C-80339A84 33439C 0028+00 0/0 1/1 0/0 .text            JMAVECScaleAdd__FPC3VecPC3VecP3Vecf
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JMAVECScaleAdd(Vec const* param_0, Vec const* param_1, Vec* param_2, f32 param_3) {
    nofralloc
#include "asm/JSystem/JMath/JMath/JMAVECScaleAdd__FPC3VecPC3VecP3Vecf.s"
}
#pragma pop

/* ############################################################################################## */
/* 804564D0-804564D8 004AD0 0004+04 1/1 0/0 0/0 .sdata2          @411 */
SECTION_SDATA2 static f32 lit_411[1 + 1 /* padding */] = {
    1.0f,
    /* padding */
    0.0f,
};

/* 80339A84-80339AE4 3343C4 0060+00 0/0 5/5 0/0 .text            JMAMTXApplyScale__FPA4_CfPA4_ffff
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JMAMTXApplyScale(f32 const (*param_0)[4], f32 (*param_1)[4], f32 param_2, f32 param_3,
                          f32 param_4) {
    nofralloc
#include "asm/JSystem/JMath/JMath/JMAMTXApplyScale__FPA4_CfPA4_ffff.s"
}
#pragma pop
