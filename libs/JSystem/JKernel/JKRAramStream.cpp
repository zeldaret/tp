//
// Generated By: dol2asm
// Translation Unit: JKRAramStream
//

#include "JSystem/JKernel/JKRAramStream.h"
#include "JSystem/JKernel/JKRAramPiece.h"
#include "JSystem/JKernel/JKRHeap.h"
#include "JSystem/JSupport/JSUFileStream.h"
#include "JSystem/JSupport/JSURandomInputStream.h"
#include "JSystem/JUtility/JUTException.h"
#include "dol2asm.h"
#include "global.h"

//
// Forward References:
//

extern "C" void create__13JKRAramStreamFl();
extern "C" void __ct__13JKRAramStreamFl();
extern "C" void __dt__13JKRAramStreamFv();
extern "C" void run__13JKRAramStreamFv();
extern "C" bool readFromAram__13JKRAramStreamFv();
extern "C" void writeToAram__13JKRAramStreamFP20JKRAramStreamCommand();
extern "C" void write_StreamToAram_Async__13JKRAramStreamFP18JSUFileInputStreamUlUlUlPUl();
extern "C" void sync__13JKRAramStreamFP20JKRAramStreamCommandi();
extern "C" void setTransBuffer__13JKRAramStreamFPUcUlP7JKRHeap();
extern "C" void __ct__20JKRAramStreamCommandFv();
extern "C" s32 getAvailable__20JSURandomInputStreamCFv(JSURandomInputStream*);
extern "C" extern char const* const JKRAramStream__stringBase0;
extern "C" u8 sMessageBuffer__13JKRAramStream[16];
extern "C" u8 sMessageQueue__13JKRAramStream[32];
extern "C" u8 sAramStreamObject__13JKRAramStream[4];
extern "C" u8 transBuffer__13JKRAramStream[4];
extern "C" u8 transSize__13JKRAramStream[4];
extern "C" u8 transHeap__13JKRAramStream[4];

//
// External References:
//

extern "C" void alloc__7JKRHeapFUliP7JKRHeap();
extern "C" void alloc__7JKRHeapFUli();
extern "C" void free__7JKRHeapFPvP7JKRHeap();
extern "C" void* __nw__FUlP7JKRHeapi();
extern "C" void __dl__FPv();
extern "C" void __ct__9JKRThreadFUlii();
extern "C" void __dt__9JKRThreadFv();
extern "C" void orderSync__12JKRAramPieceFiUlUlUlP12JKRAramBlock();
extern "C" void read__14JSUInputStreamFPvl();
extern "C" void seek__20JSURandomInputStreamFl17JSUStreamSeekFrom();
extern "C" void panic_f__12JUTExceptionFPCciPCce();
extern "C" void _savegpr_24();
extern "C" void _savegpr_26();
extern "C" void _restgpr_24();
extern "C" void _restgpr_26();
extern "C" u8 sSystemHeap__7JKRHeap[4];
extern "C" u8 sCurrentHeap__7JKRHeap[4];

//
// Declarations:
//

/* ############################################################################################## */
/* 80451408-8045140C 000908 0004+00 1/1 0/0 0/0 .sbss            sAramStreamObject__13JKRAramStream
 */
JKRAramStream* JKRAramStream::sAramStreamObject;

/* 802D3B48-802D3BB8 2CE488 0070+00 0/0 1/1 0/0 .text            create__13JKRAramStreamFl */
JKRAramStream* JKRAramStream::create(long priority) {
    if (!sAramStreamObject) {
        sAramStreamObject = new (JKRGetSystemHeap(), 0) JKRAramStream(priority);
        setTransBuffer(NULL, 0, NULL);
    }

    return sAramStreamObject;
}

/* ############################################################################################## */
/* 803CC188-803CC198 0292A8 0010+00 1/1 0/0 0/0 .data            sMessageBuffer__13JKRAramStream */
void* JKRAramStream::sMessageBuffer[4] = {
    NULL,
    NULL,
    NULL,
    NULL,
};

/* 803CC198-803CC1B8 0292B8 0020+00 2/2 0/0 0/0 .data            sMessageQueue__13JKRAramStream */
OSMessageQueue JKRAramStream::sMessageQueue = {0};

/* 802D3BB8-802D3C08 2CE4F8 0050+00 1/1 0/0 0/0 .text            __ct__13JKRAramStreamFl */
JKRAramStream::JKRAramStream(long priority) : JKRThread(0xc00, 0x10, priority) {
    resume();
}

/* 802D3C08-802D3C68 2CE548 0060+00 1/0 0/0 0/0 .text            __dt__13JKRAramStreamFv */
JKRAramStream::~JKRAramStream() {}

/* 802D3C68-802D3CD8 2CE5A8 0070+00 1/0 0/0 0/0 .text            run__13JKRAramStreamFv */
void* JKRAramStream::run(void) {
    OSInitMessageQueue(&sMessageQueue, sMessageBuffer, ARRAY_SIZE(sMessageBuffer));

    for (;;) {
        OSMessage message;
        OSReceiveMessage(&sMessageQueue, &message, OS_MESSAGE_BLOCKING);
        JKRAramStreamCommand* command = (JKRAramStreamCommand*)message;

        switch (command->mType) {
        case JKRAramStreamCommand::READ:
            readFromAram();
            break;
        case JKRAramStreamCommand::WRITE:
            writeToAram(command);
            break;
        }
    }
}

/* 802D3CD8-802D3CE0 2CE618 0008+00 1/1 0/0 0/0 .text            readFromAram__13JKRAramStreamFv */
s32 JKRAramStream::readFromAram(void) {
    return 1;
}

/* ############################################################################################## */
/* 8039D120-8039D120 029780 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
// regalloc problems
#ifdef NONMATCHING
s32 JKRAramStream::writeToAram(JKRAramStreamCommand* command) {
    u32 size;
    u32 dstSize = command->mSize;
    u32 offset = command->mOffset;
    u32 writtenLength = 0;
    u32 destination = command->mAddress;
    u8* buffer = command->mTransferBuffer;
    u32 bufferSize = command->mTransferBufferSize;
    JKRHeap* heap = command->mHeap;
    if (buffer) {
        if (bufferSize) {
            size = bufferSize;
        } else {
            size = 0x8000;
        }

        command->mTransferBufferSize = size;
        command->mAllocatedTransferBuffer = false;
    } else {
        if (bufferSize) {
            size = bufferSize;
        } else {
            size = 0x8000;
        }

        if (heap) {
            buffer = (u8*)JKRAllocFromHeap(heap, size, -0x20);
            command->mTransferBuffer = buffer;
        } else {
            buffer = (u8*)JKRAllocFromSysHeap(size, -0x20);
            command->mTransferBuffer = buffer;
        }

        command->mTransferBufferSize = size;
        command->mAllocatedTransferBuffer = true;
    }

    if (!buffer) {
        if (!heap) {
            JKRGetCurrentHeap()->dump();
        } else {
            heap->dump();
        }

        JUTException::panic_f("JKRAramStream.cpp", 0xac, "%s", ":::Cannot alloc memory\n");
    }

    if (buffer) {
        ((JSURandomInputStream*)command->mStream)->seek(offset, JSUStreamSeekFrom_SET);
        while (dstSize != 0) {
            u32 length;
            if (dstSize > size) {
                length = size;
            } else {
                length = dstSize;
            }

            s32 readLength = ((JSURandomInputStream*)command->mStream)->read(buffer, length);
            if (readLength == 0) {
                writtenLength = 0;
                break;
            }

            JKRAramPcs(0, (u32)buffer, destination, length, NULL);
            dstSize -= length;
            writtenLength += writtenLength;
            destination += length;

            if (command->mReturnSize) {
                *command->mReturnSize += length;
            }
        }

        if (command->mAllocatedTransferBuffer) {
            i_JKRFree(buffer);
            command->mAllocatedTransferBuffer = false;
        }
    }

    OSSendMessage(&command->mMessageQueue, (OSMessage)writtenLength, OS_MESSAGE_NON_BLOCKING);
    return writtenLength;
}
#else
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039D120 = "JKRAramStream.cpp";
SECTION_DEAD static char const* const stringBase_8039D132 = "%s";
SECTION_DEAD static char const* const stringBase_8039D135 = ":::Cannot alloc memory\n";
/* @stringBase0 padding */
SECTION_DEAD static char const* const pad_8039D14D = "\0\0";
#pragma pop

/* 802D3CE0-802D3ED0 2CE620 01F0+00 1/1 0/0 0/0 .text
 * writeToAram__13JKRAramStreamFP20JKRAramStreamCommand         */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm s32 JKRAramStream::writeToAram(JKRAramStreamCommand* param_0) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAramStream/writeToAram__13JKRAramStreamFP20JKRAramStreamCommand.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 8045140C-80451410 00090C 0004+00 2/2 0/0 0/0 .sbss            transBuffer__13JKRAramStream */
u8* JKRAramStream::transBuffer;

/* 80451410-80451414 000910 0004+00 2/2 0/0 0/0 .sbss            transSize__13JKRAramStream */
u32 JKRAramStream::transSize;

/* 80451414-80451418 000914 0004+00 2/2 0/0 0/0 .sbss            transHeap__13JKRAramStream */
JKRHeap* JKRAramStream::transHeap;

/* 802D3ED0-802D3FA0 2CE810 00D0+00 0/0 1/1 0/0 .text
 * write_StreamToAram_Async__13JKRAramStreamFP18JSUFileInputStreamUlUlUlPUl */
JKRAramStreamCommand* JKRAramStream::write_StreamToAram_Async(JSUFileInputStream* stream, u32 addr,
                                                              u32 size, u32 offset,
                                                              u32* returnSize) {
    JKRAramStreamCommand* command = new (JKRGetSystemHeap(), -4) JKRAramStreamCommand();
    command->mType = JKRAramStreamCommand::WRITE;
    command->mAddress = addr;
    command->mSize = size;
    command->mStream = stream;
    command->field_0x2c = 0;
    command->mOffset = offset;
    command->mTransferBuffer = transBuffer;
    command->mHeap = transHeap;
    command->mTransferBufferSize = transSize;
    command->mReturnSize = returnSize;
    if (returnSize) {
        *returnSize = 0;
    }

    OSInitMessageQueue(&command->mMessageQueue, &command->mMessage, 1);
    OSSendMessage(&sMessageQueue, command, OS_MESSAGE_BLOCKING);
    return command;
}

/* 802D3FA0-802D4034 2CE8E0 0094+00 0/0 1/1 0/0 .text
 * sync__13JKRAramStreamFP20JKRAramStreamCommandi               */
JKRAramStreamCommand* JKRAramStream::sync(JKRAramStreamCommand* command, BOOL isNonBlocking) {
    OSMessage message;
    if (isNonBlocking == 0) {
        OSReceiveMessage(&command->mMessageQueue, &message, OS_MESSAGE_BLOCKING);
        if (message == NULL) {
            command = NULL;
            return command;
        } else {
            return command;
        }
    } else {
        BOOL receiveResult =
            OSReceiveMessage(&command->mMessageQueue, &message, OS_MESSAGE_NON_BLOCKING);
        if (receiveResult == FALSE) {
            command = NULL;
            return command;
        } else if (message == NULL) {
            command = NULL;
            return command;
        } else {
            return command;
        }
    }
}

/* 802D4034-802D4088 2CE974 0054+00 1/1 1/1 0/0 .text
 * setTransBuffer__13JKRAramStreamFPUcUlP7JKRHeap               */
void JKRAramStream::setTransBuffer(u8* buffer, u32 bufferSize, JKRHeap* heap) {
    transBuffer = NULL;
    transSize = 0x8000;
    transHeap = NULL;

    if (buffer) {
        transBuffer = (u8*)ALIGN_NEXT((u32)buffer, 0x20);
    }

    if (bufferSize) {
        transSize = ALIGN_PREV(bufferSize, 0x20);
    }

    if (heap && !buffer) {
        transHeap = heap;
    }
}

/* 802D4088-802D4094 2CE9C8 000C+00 1/1 0/0 0/0 .text            __ct__20JKRAramStreamCommandFv */
JKRAramStreamCommand::JKRAramStreamCommand() {
    mAllocatedTransferBuffer = false;
}

/* 802D4094-802D40F0 2CE9D4 005C+00 0/0 3/0 0/0 .text getAvailable__20JSURandomInputStreamCFv */
// s32 JSURandomInputStream::getAvailable() const {
// should be an inline function
extern "C" s32 getAvailable__20JSURandomInputStreamCFv(JSURandomInputStream* self) {
    return self->getLength() - self->getPosition();
}

/* 8039D120-8039D120 029780 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
