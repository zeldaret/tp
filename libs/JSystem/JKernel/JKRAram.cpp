//
// Generated By: dol2asm
// Translation Unit: JKRAram
//

#include "JSystem/JKernel/JKRAram.h"
#include "JSystem/JKernel/JKRAramBlock.h"
#include "JSystem/JKernel/JKRAramHeap.h"
#include "JSystem/JKernel/JKRAramPiece.h"
#include "JSystem/JKernel/JKRAramStream.h"
#include "JSystem/JKernel/JKRExpHeap.h"
#include "JSystem/JUtility/JUTException.h"
#include "MSL_C/string.h"
#include "dol2asm.h"
#include "dolphin/ar/ar.h"
#include "global.h"

//
// Forward References:
//

extern "C" void create__7JKRAramFUlUllll();
extern "C" void __ct__7JKRAramFUlUll();
extern "C" void __dt__7JKRAramFv();
extern "C" void run__7JKRAramFv();
extern "C" void checkOkAddress__7JKRAramFPUcUlP12JKRAramBlockUl();
extern "C" void changeGroupIdIfNeed__7JKRAramFPUci();
extern "C" void mainRamToAram__7JKRAramFPUcUlUl15JKRExpandSwitchUlP7JKRHeapiPUl();
extern "C" void aramToMainRam__7JKRAramFUlPUcUl15JKRExpandSwitchUlP7JKRHeapiPUl();
extern "C" static void JKRDecompressFromAramToMainRam__FUlPvUlUlUlPUl();
extern "C" static void decompSZS_subroutine__FPUcPUc();
static int decompSZS_subroutine(u8* param_0, u8* param_1);
extern "C" static void firstSrcData__Fv();
static u8* firstSrcData(void);
extern "C" static void nextSrcData__FPUc();
extern "C" void __sinit_JKRAram_cpp();
extern "C" void func_802D2DF0(void* _this);
extern "C" extern char const* const JKRAram__stringBase0;
extern "C" u8 sMessageBuffer__7JKRAram[16];
extern "C" u8 sMessageQueue__7JKRAram[32];
extern "C" u8 sAramCommandList__7JKRAram[12];
extern "C" u32 sSZSBufferSize__7JKRAram[1 + 1 /* padding */];
extern "C" u8 sAramObject__7JKRAram[4];

//
// External References:
//

extern "C" void alloc__7JKRHeapFUliP7JKRHeap();
extern "C" void alloc__7JKRHeapFUli();
extern "C" void free__7JKRHeapFPvP7JKRHeap();
extern "C" void* __nw__FUlP7JKRHeapi();
extern "C" void __dl__FPv();
extern "C" void __ct__9JKRThreadFUlii();
extern "C" void __dt__9JKRThreadFv();
extern "C" void __ct__11JKRAramHeapFUlUl();
extern "C" void alloc__11JKRAramHeapFUlQ211JKRAramHeap10EAllocMode();
extern "C" void orderSync__12JKRAramPieceFiUlUlUlP12JKRAramBlock();
extern "C" void startDMA__12JKRAramPieceFP12JKRAMCommand();
extern "C" void create__13JKRAramStreamFl();
extern "C" void create__9JKRDecompFl();
extern "C" void orderSync__9JKRDecompFPUcPUcUlUl();
extern "C" void checkCompressed__9JKRDecompFPUc();
extern "C" void __dt__10JSUPtrListFv();
extern "C" void initiate__10JSUPtrListFv();
extern "C" void panic_f__12JUTExceptionFPCciPCce();
extern "C" void ARQInit();
extern "C" void __register_global_object();
extern "C" void _savegpr_22();
extern "C" void _savegpr_23();
extern "C" void _savegpr_25();
extern "C" void _savegpr_27();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_22();
extern "C" void _restgpr_23();
extern "C" void _restgpr_25();
extern "C" void _restgpr_27();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();
extern "C" u8 sSystemHeap__7JKRHeap[4];
extern "C" u8 sCurrentHeap__7JKRHeap[4];

//
// Declarations:
//

/* ############################################################################################## */
/* 804513C8-804513CC 0008C8 0004+00 3/3 9/9 0/0 .sbss            sAramObject__7JKRAram */
JKRAram* JKRAram::sAramObject;

/* 802D1FA4-802D2040 2CC8E4 009C+00 0/0 1/1 0/0 .text            create__7JKRAramFUlUllll */
JKRAram* JKRAram::create(u32 aram_audio_buffer_size, u32 aram_audio_graph_size,
                         long stream_priority, long decomp_priority, long piece_priority) {
    if (!sAramObject) {
        sAramObject = new (JKRHeap::getSystemHeap(), 0)
            JKRAram(aram_audio_buffer_size, aram_audio_graph_size, piece_priority);
    }

    JKRCreateAramStreamManager(stream_priority);
    JKRCreateDecompManager(decomp_priority);
    sAramObject->resume();
    return sAramObject;
}

/* ############################################################################################## */
/* 803CC128-803CC138 029248 0010+00 1/1 0/0 0/0 .data            sMessageBuffer__7JKRAram */
OSMessage JKRAram::sMessageBuffer[4] = {
    NULL,
    NULL,
    NULL,
    NULL,
};

/* 803CC138-803CC158 029258 0020+00 1/1 1/1 0/0 .data            sMessageQueue__7JKRAram */
OSMessageQueue JKRAram::sMessageQueue = {0};

/* 802D2040-802D214C 2CC980 010C+00 1/1 0/0 0/0 .text            __ct__7JKRAramFUlUll */
JKRAram::JKRAram(u32 audio_buffer_size, u32 audio_graph_size, long priority)
    : JKRThread(0xC00, 0x10, priority) {
    u32 aramBase = ARInit(mStackArray, ARRAY_SIZE(mStackArray));
    ARQInit();

    u32 aramSize = ARGetSize();

    mAudioMemorySize = audio_buffer_size;
    if (audio_graph_size == 0xffffffff) {
        mGraphMemorySize = (aramSize - audio_buffer_size) - aramBase;
        mAramMemorySize = 0;
    } else {
        mGraphMemorySize = audio_graph_size;
        mAramMemorySize = (aramSize - (audio_buffer_size + audio_graph_size)) - aramBase;
    }

    mAudioMemoryPtr = ARAlloc(mAudioMemorySize);
    mGraphMemoryPtr = ARAlloc(mGraphMemorySize);

    if (mAramMemorySize) {
        mAramMemoryPtr = ARAlloc(mAramMemorySize);
    } else {
        mAramMemoryPtr = NULL;
    }

    mAramHeap = new (JKRHeap::getSystemHeap(), 0) JKRAramHeap(mGraphMemoryPtr, mGraphMemorySize);
}

/* 802D214C-802D21DC 2CCA8C 0090+00 1/0 0/0 0/0 .text            __dt__7JKRAramFv */
JKRAram::~JKRAram() {
    sAramObject = NULL;
    if (mAramHeap)
        delete mAramHeap;
}

/* 802D21DC-802D2248 2CCB1C 006C+00 1/0 0/0 0/0 .text            run__7JKRAramFv */
// almost full match
#ifdef NONMATCHING
void* JKRAram::run(void) {
    int result;
    JKRAMCommand* command;
    JKRAramPiece::Message* message;
    OSInitMessageQueue(&sMessageQueue, sMessageBuffer, 4);
    do {
        OSReceiveMessage(&sMessageQueue, (OSMessage*)&message, OS_MESSAGE_BLOCKING);
        result = message->field_0x00;
        command = message->command;
        delete message;

        if (result != 1) {
        } else {
            JKRAramPiece::startDMA(command);
        }
    } while (true);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void* JKRAram::run() {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/run__7JKRAramFv.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 8039D078-8039D078 0296D8 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
// #pragma push
// #pragma force_active on
// SECTION_DEAD static char const* const stringBase_8039D078 = "JKRAram.cpp";
// SECTION_DEAD static char const* const stringBase_8039D084 = "%s";
// SECTION_DEAD static char const* const stringBase_8039D087 = ":::address not 32Byte aligned.";
// #pragma pop

/* 802D2248-802D22DC 2CCB88 0094+00 2/2 0/0 0/0 .text
 * checkOkAddress__7JKRAramFPUcUlP12JKRAramBlockUl              */
void JKRAram::checkOkAddress(u8* addr, u32 size, JKRAramBlock* block, u32 param_4) {
    if (!IS_ALIGNED((u32)addr, 0x20) && !IS_ALIGNED(size, 0x20)) {
        JUTException::panic_f("JKRAram.cpp", 0xdb, "%s", ":::address not 32Byte aligned.");
    }

    if (block && !IS_ALIGNED((u32)block->getAddress() + param_4, 0x20)) {
        JUTException::panic_f("JKRAram.cpp", 0xe3, "%s", ":::address not 32Byte aligned.");
    }
}

/* 802D22DC-802D233C 2CCC1C 0060+00 1/1 0/0 0/0 .text            changeGroupIdIfNeed__7JKRAramFPUci
 */
void JKRAram::changeGroupIdIfNeed(u8* data, int groupId) {
    JKRHeap* currentHeap = JKRHeap::getCurrentHeap();
    if (currentHeap->getHeapType() == 'EXPH' && groupId >= 0) {
        JKRExpHeap::CMemBlock* block = JKRExpHeap::CMemBlock::getBlock(data);
        block->newGroupId(groupId);
    }
}

/* 802D233C-802D25B4 2CCC7C 0278+00 0/0 3/3 0/0 .text
 * mainRamToAram__7JKRAramFPUcUlUl15JKRExpandSwitchUlP7JKRHeapiPUl */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JKRAram::mainRamToAram(u8* param_0, u32 param_1, u32 param_2, JKRExpandSwitch param_3,
                                u32 param_4, JKRHeap* param_5, int param_6, u32* param_7) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/mainRamToAram__7JKRAramFPUcUlUl15JKRExpandSwitchUlP7JKRHeapiPUl.s"
}
#pragma pop

/* 802D25B4-802D2830 2CCEF4 027C+00 0/0 6/6 0/0 .text
 * aramToMainRam__7JKRAramFUlPUcUl15JKRExpandSwitchUlP7JKRHeapiPUl */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void JKRAram::aramToMainRam(u32 param_0, u8* param_1, u32 param_2, JKRExpandSwitch param_3,
                                u32 param_4, JKRHeap* param_5, int param_6, u32* param_7) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/aramToMainRam__7JKRAramFUlPUcUl15JKRExpandSwitchUlP7JKRHeapiPUl.s"
}
#pragma pop

/* 804342DC-804342E8 060FFC 000C+00 1/1 0/0 0/0 .bss             sAramCommandList__7JKRAram */
JSUList<JKRAMCommand> JKRAram::sAramCommandList;

/* 804342E8-80434300 061008 0018+00 1/1 0/0 0/0 .bss             decompMutex */
static OSMutex decompMutex;

/* 804508B8-804508C0 000338 0004+04 1/1 1/1 0/0 .sdata           sSZSBufferSize__7JKRAram */
u32 JKRAram::sSZSBufferSize = 0x00000400;

/* 804513CC-804513D0 0008CC 0004+00 3/3 0/0 0/0 .sbss            szpBuf */
static u8* szpBuf;

/* 804513D0-804513D4 0008D0 0004+00 3/3 0/0 0/0 .sbss            szpEnd */
static u8* szpEnd;

/* 804513D4-804513D8 0008D4 0004+00 2/2 0/0 0/0 .sbss            refBuf */
static u8* refBuf;

/* 804513D8-804513DC 0008D8 0004+00 2/2 0/0 0/0 .sbss            refEnd */
static u8* refEnd;

/* 804513DC-804513E0 0008DC 0004+00 2/2 0/0 0/0 .sbss            refCurrent */
static u8* refCurrent;

/* 804513E0-804513E4 0008E0 0004+00 3/3 0/0 0/0 .sbss            srcOffset */
static u32 srcOffset;

/* 804513E4-804513E8 0008E4 0004+00 4/4 0/0 0/0 .sbss            transLeft */
static u32 transLeft;

/* 804513E8-804513EC 0008E8 0004+00 3/3 0/0 0/0 .sbss            srcLimit */
static u8* srcLimit;

/* 804513EC-804513F0 0008EC 0004+00 3/3 0/0 0/0 .sbss            srcAddress */
static u32 srcAddress;

/* 804513F0-804513F4 0008F0 0004+00 2/2 0/0 0/0 .sbss            fileOffset */
static u32 fileOffset;

/* 804513F4-804513F8 0008F4 0004+00 2/2 0/0 0/0 .sbss            readCount */
static u32 readCount;

/* 804513F8-804513FC 0008F8 0004+00 2/2 0/0 0/0 .sbss            maxDest */
static u32 maxDest;

/* 804513FC-80451400 0008FC 0004+00 1/1 0/0 0/0 .sbss            None */
static bool data_804513FC;

/* 80451400-80451404 000900 0004+00 2/2 0/0 0/0 .sbss            tsPtr */
static u32* tsPtr;

/* 80451404-80451408 000904 0004+00 1/1 0/0 0/0 .sbss            tsArea */
static u32 tsArea;

/* 802D2830-802D29A0 2CD170 0170+00 1/1 0/0 0/0 .text
 * JKRDecompressFromAramToMainRam__FUlPvUlUlUlPUl               */
#ifdef NONMATCHING
// full match, except:
//     tsPtr = &tsArea;
// doesn't use r13
void JKRDecompressFromAramToMainRam(u32 src, void* dst, u32 srcLength, u32 dstLength, u32 offset,
                                    u32* resourceSize) {
#define s_is_decompress_mutex_initialized data_804513FC

    // STATIC BEGIN
    // This code is probably generated by the compiler for a static variable
    BOOL enable = OSDisableInterrupts();
    if (s_is_decompress_mutex_initialized == false) {
        OSInitMutex(&decompMutex);
        s_is_decompress_mutex_initialized = true;
    }
    OSRestoreInterrupts(enable);
    // STATIC END

    OSLockMutex(&decompMutex);
    u32 szpSize = JKRAram::getSZSBufferSize();
    szpBuf = (u8*)JKRAllocFromSysHeap(szpSize, 0x20);
    ASSERT(szpBuf != 0);
    szpEnd = szpBuf + szpSize;

    if (offset != 0) {
        refBuf = (u8*)JKRAllocFromSysHeap(0x1120, 0);
        ASSERT(refBuf != 0);
        refEnd = refBuf + 0x1120;
        refCurrent = refBuf;
    } else {
        refBuf = NULL;
    }

    srcAddress = src;
    srcOffset = 0;
    if (srcLength == 0) {
        transLeft = -1;
    } else {
        transLeft = srcLength;
    }

    fileOffset = offset;
    readCount = 0;
    maxDest = dstLength;
    if (!resourceSize) {
        tsPtr = &tsArea;
    } else {
        tsPtr = resourceSize;
    }

    *tsPtr = 0;

    decompSZS_subroutine(firstSrcData(), (u8*)dst);
    JKRFreeToSysHeap(szpBuf);
    if (refBuf) {
        JKRFreeToSysHeap(refBuf);
    }
    DCStoreRangeNoSync(dst, *tsPtr);
    OSUnlockMutex(&decompMutex);
#undef s_is_decompress_mutex_initialized
#undef decompMutex
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void JKRDecompressFromAramToMainRam(u32 param_0, void* param_1, u32 param_2, u32 param_3,
                                               u32 param_4, u32* param_5) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/JKRDecompressFromAramToMainRam__FUlPvUlUlUlPUl.s"
}
#pragma pop
#endif

/* 802D29A0-802D2C40 2CD2E0 02A0+00 1/1 0/0 0/0 .text            decompSZS_subroutine__FPUcPUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm int decompSZS_subroutine(u8* param_0, u8* param_1) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/decompSZS_subroutine__FPUcPUc.s"
}
#pragma pop

/* 802D2C40-802D2CE4 2CD580 00A4+00 1/1 0/0 0/0 .text            firstSrcData__Fv */
static u8* firstSrcData(void) {
    srcLimit = szpEnd - 0x19;
    u8* buffer = szpBuf;

    u32 length;
    u32 size = szpEnd - szpBuf;
    if (transLeft < size) {
        length = transLeft;
    } else {
        length = size;
    }

    u32 src = (u32)(srcAddress + srcOffset);
    u32 dst = (u32)buffer;
    u32 alignedLength = ALIGN_NEXT(length, 0x20);
    JKRAramPcs(1, src, dst, alignedLength, NULL);

    srcOffset += length;
    transLeft -= length;
    if (!transLeft) {
        srcLimit = buffer + length;
    }

    return buffer;
}

/* 802D2CE4-802D2DAC 2CD624 00C8+00 1/1 0/0 0/0 .text            nextSrcData__FPUc */
// missing one add instruction
#ifdef NONMATCHING
inline u32 nextSrcData_MIN(u32 A, u32 B) {
    if (A > B)
        return B;
    return A;
}

static u8* nextSrcData(u8* current) {
    u8* dest;
    u32 left = (u32)(szpEnd - current);
    if (!IS_NOT_ALIGNED(left, 0x20)) {
        dest = szpBuf;
    } else {
        dest = szpBuf + 0x20 - (left & 0x1f);
    }

    memcpy(dest, current, left);
    u32 transSize = nextSrcData_MIN(transLeft, szpEnd - (dest + left));
    ASSERT(transSize > 0);

    JKRAramPcs(1, (u32)(srcAddress + srcOffset), (u32)(dest + left), ALIGN_NEXT(transSize, 0x20),
               NULL);
    srcOffset += transSize;
    transLeft -= transSize;

    if (transLeft == 0) {
        srcLimit = (dest + left) + transSize;
    }

    return dest;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm u8* nextSrcData(u8* param_0) {
    nofralloc
#include "asm/JSystem/JKernel/JKRAram/nextSrcData__FPUc.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 8039D0A6-8039D0B8 029706 000E+04 0/0 0/0 0/0 .rodata          None */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039D0A6 = "bad aramSync\n";
/* @stringBase0 padding */
SECTION_DEAD static char const* const pad_8039D0B4 = "\0\0\0";
#pragma pop

/* 8039D078-8039D078 0296D8 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
