//
// Generated By: dol2asm
// Translation Unit: MSL_Common/Src/string
//

#include "MSL_C/MSL_Common/Src/string.h"
#include "dol2asm.h"
#include "dolphin/types.h"

#define K1 0x80808080
#define K2 0xFEFEFEFF

//
// Declarations:
//

/* 803688DC-80368924 36321C 0048+00 0/0 1/1 0/0 .text            strrchr */
char* strrchr(const char* str, int chr) {
    const u8* p = (u8*)str - 1;
	const u8* q = NULL;
	u32 c = (chr & 0xFF);

	u32 ch;
	while (ch = *++p) {
		if (ch == c) {
			q = p;
        }
    }

	if (q != NULL) {
		return (char*)q;
    }

	return c ? NULL : (char*)p;
}

/* 80368924-80368954 363264 0030+00 0/0 3/3 0/0 .text            strchr */
char* strchr(const char* str, int chr) {
    const u8* p = (u8*)str - 1;
	u32 c = (chr & 0xFF);

	u32 ch;
	while (ch = *++p) {
		if (ch == c) {
			return (char*)p;
        }
    }

	return c ? NULL : (char*)p;
}

/* 80368954-80368994 363294 0040+00 0/0 6/6 0/0 .text            strncmp */
int strncmp(const char* strA, const char* strB, u32 n) {
    const u8* p1 = (u8*)strA - 1;
	const u8* p2 = (u8*)strB - 1;
	u32 c1, c2;

	n++;
	while (--n) {
		if ((c1 = *++p1) != (c2 = *++p2)) {
			return c1 - c2;
        } else if (c1 == 0) {
			break;
        }
    }

	return 0;
}

/* 80368994-80368ABC 3632D4 0128+00 0/0 155/155 279/279 .text            strcmp */
int strcmp(const char* strA, const char* strB) {
    register u8* left  = (u8*)strA;
	register u8* right = (u8*)strB;
	u32 align, l1, r1, x;

	l1 = *left;
	r1 = *right;
	if (l1 - r1) {
		return l1 - r1;
	}

	if ((align = ((int)left & 3)) != ((int)right & 3)) {
		goto bytecopy;
	}

	if (align) {
		if (l1 == 0) {
			return 0;
		}
		for (align = 3 - align; align; align--) {
			l1 = *(++left);
			r1 = *(++right);
			if (l1 - r1) {
				return l1 - r1;
			}
			if (l1 == 0) {
				return 0;
			}
		}
		left++;
		right++;
	}

	l1 = *(int*)left;
	r1 = *(int*)right;
	x  = l1 + K2;
	if (x & K1) {
		goto adjust;
	}

	while (l1 == r1) {
		l1 = *(++((int*)(left)));
		r1 = *(++((int*)(right)));
		x  = l1 + K2;
		if (x & K1) {
			goto adjust;
		}
	}

	if (l1 > r1) {
		return 1;
    }
	return -1;

adjust:
	l1 = *left;
	r1 = *right;
	if (l1 - r1) {
		return l1 - r1;
	}

bytecopy:
	if (l1 == 0) {
		return 0;
	}

	do {
		l1 = *(++left);
		r1 = *(++right);
		if (l1 - r1) {
			return l1 - r1;
		}
		if (l1 == 0) {
			return 0;
		}
	} while (1);
}

/* 80368ABC-80368AE8 3633FC 002C+00 0/0 20/20 8/8 .text            strcat */
char* strcat(char* dst, const char* src) {
    const u8* p = (u8*)src - 1;
	u8* q = (u8*)dst - 1;

	while (*++q) {}
	
	q--;

	while (*++q = *++p) {}

	return dst;
}

/* 80368AE8-80368B2C 363428 0044+00 0/0 9/9 1/1 .text            strncpy */
char* strncpy(char* dst, const char* src, size_t n) {
	const u8* p = (const u8*)src - 1;
	u8* q = (u8*)dst - 1;

	n++;
	while (--n) {
		if (!(*++q = *++p)) {
			while (--n) {
				*++q = 0;
            }
			break;
		}
    }

	return dst;
}

/* 80368B2C-80368BE4 36346C 00B8+00 0/0 131/131 13/13 .text            strcpy */
char* strcpy(char* dst, const char* src) {
	register u8 *destb, *fromb;
	register u32 w, t, align;

	fromb = (u8*)src;
	destb = (u8*)dst;

	if ((align = ((int)fromb & 3)) != ((int)destb & 3)) {
		goto bytecopy;
	}

	if (align) {
		if ((*destb = *fromb) == 0) {
			return dst;
        }

		for (align = 3 - align; align; align--) {
			if ((*(++destb) = *(++fromb)) == 0) {
				return dst;
            }
		}
		++destb;
		++fromb;
	}

	w = *((int*)(fromb));

	t = w + K2;

	t &= K1;
	if (t) {
		goto bytecopy;
    }
	--((int*)(destb));

	do {
		*(++((int*)(destb))) = w;
		w = *(++((int*)(fromb)));

		t = w + K2;
		t &= K1;
		if (t) {
			goto adjust;
        }
	} while (1);

adjust:
	++((int*)(destb));

bytecopy:
	if ((*destb = *fromb) == 0) {
		return dst;
    }

	do {
		if ((*(++destb) = *(++fromb)) == 0) {
			return dst;
        }
	} while (1);

	return dst;
}

/* 80368BE4-80368C00 363524 001C+00 0/0 28/28 8/8 .text            strlen */
u32 strlen(const char* str) {
	size_t len = -1;
	u8* p = (u8*)str - 1;

	do {
		len++;
    }
	while (*++p);

	return len;
}
