//
// Generated By: dol2asm
// Translation Unit: EXIBios
//

#include "dolphin/exi/EXIBios.h"
#include "dol2asm.h"
#include "dolphin/os/OS.h"

#define REG_MAX 5
#define REG(chan, idx) (__EXIRegs[((chan)*REG_MAX) + (idx)])

#define EXI_0CR(tstart, dma, rw, tlen)                                                             \
    ((((u32)(tstart)) << 0) | (((u32)(dma)) << 1) | (((u32)(rw)) << 2) | (((u32)(tlen)) << 4))

//
// Forward References:
//

static void SetExiInterruptMask(s32 chan, EXIControl* exi);
BOOL __EXIProbe(s32 chan);
static u32 EXIClearInterrupts(s32 chan, BOOL exi, BOOL tc, BOOL ext);
static void EXIIntrruptHandler(s16 interrupt, OSContext* context);
static void TCIntrruptHandler(s16 interrupt, OSContext* context);
static void EXTIntrruptHandler(s16 interrupt, OSContext* context);

//
// External References:
//

void __OSEnableBarnacle();
void __div2i();
void memmove();
extern u8 __OSInIPL[4 + 4 /* padding */];

//
// Declarations:
//

/* ############################################################################################## */
/* 8044C570-8044C630 079290 00C0+00 20/20 0/0 0/0 .bss             Ecb */
static EXIControl Ecb[3];

/* 80342C0C-80342D00 33D54C 00F4+00 4/4 0/0 0/0 .text            SetExiInterruptMask */
#ifdef NONMATCHING
static void SetExiInterruptMask(s32 chan, EXIControl* exi) {
    EXIControl* exi2;

    exi2 = &Ecb[2];
    switch (chan) {
    case 0:
        if ((exi->exiCallback == 0 && exi2->exiCallback == 0) || (exi->state & STATE_LOCKED)) {
            __OSMaskInterrupts(OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_2_EXI);
        } else {
            __OSUnmaskInterrupts(OS_INTERRUPTMASK_EXI_0_EXI | OS_INTERRUPTMASK_EXI_2_EXI);
        }
        break;
    case 1:
        if (exi->exiCallback == 0 || (exi->state & STATE_LOCKED)) {
            __OSMaskInterrupts(OS_INTERRUPTMASK_EXI_1_EXI);
        } else {
            __OSUnmaskInterrupts(OS_INTERRUPTMASK_EXI_1_EXI);
        }
        break;
    case 2:
        if (__OSGetInterruptHandler(OS_INTR_PI_DEBUG) == 0 || (exi->state & STATE_LOCKED)) {
            __OSMaskInterrupts(OS_INTERRUPTMASK_PI_DEBUG);
        } else {
            __OSUnmaskInterrupts(OS_INTERRUPTMASK_PI_DEBUG);
        }
        break;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void SetExiInterruptMask(s32 chan, EXIControl* exi) {
    nofralloc
#include "asm/exi/EXIBios/SetExiInterruptMask.s"
}
#pragma pop
#endif

/* 80342D00-80342F5C 33D640 025C+00 2/2 9/9 0/0 .text            EXIImm */
#ifdef NONMATCHING
s32 EXIImm(s32 chan, void* buf, s32 len, u32 type, EXICallback callback) {
    EXIControl* exi = &Ecb[chan];
    BOOL enabled;

    enabled = OSDisableInterrupts();
    if ((exi->state & EXI_STATE_BUSY) || !(exi->state & EXI_STATE_SELECTED)) {
        OSRestoreInterrupts(enabled);
        return FALSE;
    }

    exi->tcCallback = callback;
    if (exi->tcCallback) {
        EXIClearInterrupts(chan, FALSE, TRUE, FALSE);
        __OSUnmaskInterrupts(OS_INTERRUPTMASK_EXI_0_TC >> (3 * chan));
    }

    exi->state |= EXI_STATE_IMM;

    if (type != EXI_READ) {
        u32 data;
        int i;

        data = 0;
        for (i = 0; i < len; i++) {
            data |= ((u8*)buf)[i] << ((3 - i) * 8);
        }
        REG(chan, 4) = data;
    }

    exi->immBuf = buf;
    exi->immLen = (type != EXI_WRITE) ? len : 0;

    REG(chan, 3) = EXI_0CR(1, 0, type, len - 1);

    OSRestoreInterrupts(enabled);

    return TRUE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm s32 EXIImm(s32 chan, void* buf, s32 len, u32 type, EXICallback callback) {
    nofralloc
#include "asm/exi/EXIBios/EXIImm.s"
}
#pragma pop
#endif

/* 80342F5C-80342FFC 33D89C 00A0+00 0/0 7/7 0/0 .text            EXIImmEx */
// needs compiler lmw/lwz order patch
#ifdef NONMATCHING
BOOL EXIImmEx(s32 chan, void* buf, s32 len, u32 mode) {
    s32 xLen;

    while (len) {
        xLen = (len < 4) ? len : 4;
        if (!EXIImm(chan, buf, xLen, mode, NULL)) {
            return FALSE;
        }

        if (!EXISync(chan)) {
            return FALSE;
        }

        (u8*)buf += xLen;
        len -= xLen;
    }
    return TRUE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm s32 EXIImmEx(s32 chan, void* buf, s32 len, u32 mode) {
    nofralloc
#include "asm/exi/EXIBios/EXIImmEx.s"
}
#pragma pop
#endif

/* 80342FFC-803430E8 33D93C 00EC+00 0/0 4/4 0/0 .text            EXIDma */
#ifdef NONMATCHING
BOOL EXIDma(s32 chan, void* buf, s32 len, u32 type, EXICallback callback) {
    EXIControl* exi = &Ecb[chan];
    BOOL enabled;

    enabled = OSDisableInterrupts();
    if ((exi->state & EXI_STATE_BUSY) || !(exi->state & EXI_STATE_SELECTED)) {
        OSRestoreInterrupts(enabled);
        return FALSE;
    }

    exi->tcCallback = callback;
    if (exi->tcCallback) {
        EXIClearInterrupts(chan, FALSE, TRUE, FALSE);
        __OSUnmaskInterrupts(OS_INTERRUPTMASK_EXI_0_TC >> (3 * chan));
    }

    exi->state |= EXI_STATE_DMA;

    REG(chan, 1) = (u32)buf & 0x3ffffe0;
    REG(chan, 2) = (u32)len;
    REG(chan, 3) = EXI_0CR(1, 1, type, 0);

    OSRestoreInterrupts(enabled);

    return TRUE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIDma(s32 chan, void* buf, s32 len, u32 type, EXICallback callback) {
    nofralloc
#include "asm/exi/EXIBios/EXIDma.s"
}
#pragma pop
#endif

/* 803430E8-80343334 33DA28 024C+00 2/2 9/9 0/0 .text            EXISync */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXISync(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXISync.s"
}
#pragma pop

/* 80343334-8034337C 33DC74 0048+00 4/4 0/0 0/0 .text            EXIClearInterrupts */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm u32 EXIClearInterrupts(s32 chan, BOOL exi, BOOL tc, BOOL ext) {
    nofralloc
#include "asm/exi/EXIBios/EXIClearInterrupts.s"
}
#pragma pop

/* 8034337C-803433F8 33DCBC 007C+00 0/0 6/6 0/0 .text            EXISetExiCallback */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm EXICallback EXISetExiCallback(s32 chan, EXICallback exiCallback) {
    nofralloc
#include "asm/exi/EXIBios/EXISetExiCallback.s"
}
#pragma pop

/* 803433F8-8034356C 33DD38 0174+00 7/7 0/0 0/0 .text            __EXIProbe */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL __EXIProbe(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/__EXIProbe.s"
}
#pragma pop

/* 8034356C-803435EC 33DEAC 0080+00 0/0 5/5 0/0 .text            EXIProbe */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIProbe(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIProbe.s"
}
#pragma pop

/* 803435EC-803436A0 33DF2C 00B4+00 0/0 1/1 0/0 .text            EXIProbeEx */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm s32 EXIProbeEx(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIProbeEx.s"
}
#pragma pop

/* 803436A0-803437AC 33DFE0 010C+00 0/0 2/2 0/0 .text            EXIAttach */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIAttach(s32 chan, EXICallback extCallback) {
    nofralloc
#include "asm/exi/EXIBios/EXIAttach.s"
}
#pragma pop

/* 803437AC-80343868 33E0EC 00BC+00 0/0 3/3 0/0 .text            EXIDetach */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIDetach(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIDetach.s"
}
#pragma pop

/* 80343868-80343994 33E1A8 012C+00 1/1 12/12 0/0 .text            EXISelect */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXISelect(s32 chan, u32 dev, u32 freq) {
    nofralloc
#include "asm/exi/EXIBios/EXISelect.s"
}
#pragma pop

/* 80343994-80343AA4 33E2D4 0110+00 1/1 15/15 0/0 .text            EXIDeselect */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIDeselect(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIDeselect.s"
}
#pragma pop

/* 80343AA4-80343B6C 33E3E4 00C8+00 1/1 0/0 0/0 .text            EXIIntrruptHandler */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void EXIIntrruptHandler(s16 interrupt, OSContext* context) {
    nofralloc
#include "asm/exi/EXIBios/EXIIntrruptHandler.s"
}
#pragma pop

/* 80343B6C-80343D84 33E4AC 0218+00 1/1 0/0 0/0 .text            TCIntrruptHandler */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void TCIntrruptHandler(s16 interrupt, OSContext* context) {
    nofralloc
#include "asm/exi/EXIBios/TCIntrruptHandler.s"
}
#pragma pop

/* 80343D84-80343E54 33E6C4 00D0+00 1/1 0/0 0/0 .text            EXTIntrruptHandler */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void EXTIntrruptHandler(s16 interrupt, OSContext* context) {
    nofralloc
#include "asm/exi/EXIBios/EXTIntrruptHandler.s"
}
#pragma pop

/* ############################################################################################## */
/* 803D10A8-803D10F0 02E1C8 0045+03 1/0 0/0 0/0 .data            @1 */
SECTION_DATA static char lit_1[] =
    "<< Dolphin SDK - EXI\trelease build: Apr  5 2004 04:14:14 (0x2301) >>";

/* 804509C0-804509C8 -00001 0004+04 1/1 0/0 0/0 .sdata           __EXIVersion */
SECTION_SDATA static const char* __EXIVersion = lit_1;

/* 804516D8-804516E0 000BD8 0004+04 2/2 0/0 0/0 .sbss            IDSerialPort1 */
static u8 IDSerialPort1[4 + 4 /* padding */];

/* 80343E54-80344028 33E794 01D4+00 0/0 1/1 0/0 .text            EXIInit */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void EXIInit(void) {
    nofralloc
#include "asm/exi/EXIBios/EXIInit.s"
}
#pragma pop

/* 80344028-8034411C 33E968 00F4+00 1/1 10/10 0/0 .text            EXILock */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXILock(s32 chan, u32 dev, EXICallback unlockedCallback) {
    nofralloc
#include "asm/exi/EXIBios/EXILock.s"
}
#pragma pop

/* 8034411C-803441F8 33EA5C 00DC+00 0/0 14/14 0/0 .text            EXIUnlock */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL EXIUnlock(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIUnlock.s"
}
#pragma pop

/* 803441F8-80344210 33EB38 0018+00 0/0 2/2 0/0 .text            EXIGetState */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u32 EXIGetState(s32 chan) {
    nofralloc
#include "asm/exi/EXIBios/EXIGetState.s"
}
#pragma pop

/* 80344210-80344238 33EB50 0028+00 1/1 0/0 0/0 .text            UnlockedHandler */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void UnlockedHandler(s32 chan, OSContext* context) {
    nofralloc
#include "asm/exi/EXIBios/UnlockedHandler.s"
}
#pragma pop

/* 80344238-803445E8 33EB78 03B0+00 5/5 3/3 0/0 .text            EXIGetID */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm s32 EXIGetID(s32 chan, u32 dev, u32* id) {
    nofralloc
#include "asm/exi/EXIBios/EXIGetID.s"
}
#pragma pop

/* ############################################################################################## */
/* 803D10F0-803D1100 02E210 000F+01 0/0 0/0 0/0 .data            @473 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_473[] = "Memory Card 59";
#pragma pop

/* 803D1100-803D1110 02E220 0010+00 0/0 0/0 0/0 .data            @474 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_474[] = "Memory Card 123";
#pragma pop

/* 803D1110-803D1120 02E230 0010+00 0/0 0/0 0/0 .data            @475 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_475[] = "Memory Card 251";
#pragma pop

/* 803D1120-803D1130 02E240 0010+00 0/0 0/0 0/0 .data            @476 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_476[] = "Memory Card 507";
#pragma pop

/* 803D1130-803D1144 02E250 0011+03 0/0 0/0 0/0 .data            @477 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_477[] = "Memory Card 1019";
#pragma pop

/* 803D1144-803D1158 02E264 0011+03 0/0 0/0 0/0 .data            @478 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_478[] = "Memory Card 2043";
#pragma pop

/* 803D1158-803D1164 02E278 000C+00 0/0 0/0 0/0 .data            @479 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_479[] = "USB Adapter";
#pragma pop

/* 803D1164-803D1170 02E284 0009+03 0/0 0/0 0/0 .data            @485 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_485[] = "Net Card";
#pragma pop

/* 803D1170-803D1180 02E290 000D+03 0/0 0/0 0/0 .data            @486 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_486[] = "Artist Ether";
#pragma pop

/* 803D1180-803D1194 02E2A0 0012+02 0/0 0/0 0/0 .data            @487 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_487[] = "Broadband Adapter";
#pragma pop

/* 803D1194-803D11A4 02E2B4 000E+02 0/0 0/0 0/0 .data            @489 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_489[] = "Stream Hanger";
#pragma pop

/* 803D11A4-803D11B8 02E2C4 000E+06 0/0 0/0 0/0 .data            @490 */
#pragma push
#pragma force_active on
SECTION_DATA static char lit_490[] = "IS-DOL-VIEWER";
#pragma pop
