//
// Generated By: dol2asm
// Translation Unit: OSMemory
//

#include "dolphin/os/OSMemory.h"
#include "dolphin/os/OS.h"
#include "dolphin/os/OSReset.h"

#define TRUNC(n, a) (((u32)(n)) & ~((a)-1))
#define ROUND(n, a) (((u32)(n) + (a)-1) & ~((a)-1))

vu16 __MEMRegs[64] : 0xCC004000;

//
// External References:
//

extern OSErrorHandlerEx __OSErrorTable[16];

//
// Declarations:
//

/* 8033EC6C-8033ECA8 3395AC 003C+00 1/0 0/0 0/0 .text            OnReset */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm s32 OnReset(s32 param_0) {
    nofralloc
#include "asm/dolphin/os/OSMemory/OnReset.s"
}
#pragma pop

/* 8033ECA8-8033ED14 3395E8 006C+00 1/1 0/0 0/0 .text            MEMIntrruptHandler */
static void MEMIntrruptHandler(OSInterrupt interrupt, OSContext* context) {
    u32 addr;
    u32 cause;

    cause = __MEMRegs[0xf];
    addr = (((u32)__MEMRegs[0x12] & 0x3ff) << 16) | __MEMRegs[0x11];
    __MEMRegs[0x10] = 0;

    if (__OSErrorTable[EXCEPTION_MEMORY_PROTECTION]) {
        __OSErrorTable[EXCEPTION_MEMORY_PROTECTION](EXCEPTION_MEMORY_PROTECTION, context, cause,
                                                    addr);
        return;
    }

    __OSUnhandledException(EXCEPTION_MEMORY_PROTECTION, context, cause, addr);
}

/* 8033ED14-8033EDD8 339654 00C4+00 0/0 1/1 0/0 .text            OSProtectRange */
void OSProtectRange(u32 chan, void* addr, u32 nBytes, u32 control) {
    BOOL enabled;
    u32 start;
    u32 end;
    u16 reg;
    if (4 <= chan) {
        return;
    }

    control &= OS_PROTECT_CONTROL_RDWR;

    end = (u32)addr + nBytes;
    start = TRUNC(addr, 1u << 10);
    end = ROUND(end, 1u << 10);

    DCFlushRange((void*)start, end - start);

    enabled = OSDisableInterrupts();

    __OSMaskInterrupts(OS_INTERRUPTMASK(OS_INTR_MEM_0 + chan));

    __MEMRegs[0 + 2 * chan] = (u16)(start >> 10);
    __MEMRegs[1 + 2 * chan] = (u16)(end >> 10);

    reg = __MEMRegs[8];
    reg &= ~(OS_PROTECT_CONTROL_RDWR << 2 * chan);
    reg |= control << 2 * chan;
    __MEMRegs[8] = reg;

    if (control != OS_PROTECT_CONTROL_RDWR) {
        __OSUnmaskInterrupts(OS_INTERRUPTMASK(OS_INTR_MEM_0 + chan));
    }

    OSRestoreInterrupts(enabled);
}

/* 8033EDD8-8033EE58 339718 0080+00 1/1 0/0 0/0 .text            Config24MB */
static asm void Config24MB(void) {
    // clang-format off
    nofralloc

    li r7, 0
    lis r4, 0x0000
    addi r4, r4, 0x0002
    lis r3, 0x8000
    addi r3, r3, 0x01FF
    lis r6, 0x0100
    addi r6, r6, 0x0002
    lis r5, 0x8100
    addi r5, r5, 0x00FF
    isync 
    mtdbatu 0, r7
    mtdbatl 0, r4
    mtdbatu 0, r3
    isync 
    mtibatu 0, r7
    mtibatl 0, r4
    mtibatu 0, r3
    isync 
    mtdbatu 2, r7
    mtdbatl 2, r6
    mtdbatu 2, r5
    isync 
    mtibatu 2, r7
    mtibatl 2, r6
    mtibatu 2, r5
    isync 
    mfmsr r3
    ori r3, r3, 0x30
    mtspr 0x1b, r3
    mflr r3
    mtspr 0x1a, r3
    rfi
    // clang-format on
}

/* 8033EE58-8033EED8 339798 0080+00 1/1 0/0 0/0 .text            Config48MB */
static asm void Config48MB(void) {
    // clang-format off
    nofralloc

    li r7, 0
    lis r4, 0x0000
    addi r4, r4, 0x0002
    lis r3, 0x8000
    addi r3, r3, 0x03FF
    lis r6, 0x0200
    addi r6, r6, 0x0002
    lis r5, 0x8200
    addi r5, r5, 0x01FF
    isync 
    mtdbatu 0, r7
    mtdbatl 0, r4
    mtdbatu 0, r3
    isync 
    mtibatu 0, r7
    mtibatl 0, r4
    mtibatu 0, r3
    isync 
    mtdbatu 2, r7
    mtdbatl 2, r6
    mtdbatu 2, r5
    isync 
    mtibatu 2, r7
    mtibatl 2, r6
    mtibatu 2, r5
    isync 
    mfmsr r3
    ori r3, r3, 0x30
    mtspr 0x1b, r3
    mflr r3
    mtspr 0x1a, r3
    rfi
    // clang-format on
}

/* 8033EED8-8033EEF0 339818 0018+00 1/1 0/0 0/0 .text            RealMode */
static asm void RealMode(register u32 config) {
    // clang-format off
    nofralloc

    clrlwi config, config, 2
    mtspr 0x1a, config
    mfmsr config
    rlwinm config, config, 0, 0x1c, 0x19
    mtspr 0x1b, config
    rfi
    // clang-format on
}

/* ############################################################################################## */
/* 803D07D8-803D07E8 -00001 0010+00 1/1 0/0 0/0 .data            ResetFunctionInfo */
static OSResetFunctionInfo ResetFunctionInfo = {
    OnReset,
    0x7F,
    NULL,
    NULL,
};

inline u32 OSGetPhysicalMemSize() {
    return *(u32*)(OSPhysicalToCached(0x0028));
}

inline u32 OSGetConsoleSimulatedMemSize() {
    return *(u32*)(OSPhysicalToCached(0x00F0));
}

/* 8033EEF0-8033F008 339830 0118+00 0/0 1/1 0/0 .text            __OSInitMemoryProtection */
void __OSInitMemoryProtection() {
    u32 padding[8];
    u32 simulatedSize;
    BOOL enabled;
    simulatedSize = OSGetConsoleSimulatedMemSize();
    enabled = OSDisableInterrupts();

    __MEMRegs[16] = 0;
    __MEMRegs[8] = 0xFF;

    __OSMaskInterrupts(OS_INTERRUPTMASK_MEM_0 | OS_INTERRUPTMASK_MEM_1 | OS_INTERRUPTMASK_MEM_2 |
                       OS_INTERRUPTMASK_MEM_3);
    __OSSetInterruptHandler(OS_INTR_MEM_0, MEMIntrruptHandler);
    __OSSetInterruptHandler(OS_INTR_MEM_1, MEMIntrruptHandler);
    __OSSetInterruptHandler(OS_INTR_MEM_2, MEMIntrruptHandler);
    __OSSetInterruptHandler(OS_INTR_MEM_3, MEMIntrruptHandler);
    __OSSetInterruptHandler(OS_INTR_MEM_ADDRESS, MEMIntrruptHandler);
    OSRegisterResetFunction(&ResetFunctionInfo);

    if (OSGetConsoleSimulatedMemSize() < OSGetPhysicalMemSize() &&
        OSGetConsoleSimulatedMemSize() == 0x1800000) {
        DCInvalidateRange((void*)0x81800000, 0x1800000);
        __MEMRegs[20] = 2;
    }

    if (simulatedSize <= 0x1800000) {
        RealMode((u32)&Config24MB);
    } else if (simulatedSize <= 0x3000000) {
        RealMode((u32)&Config48MB);
    }

    __OSUnmaskInterrupts(OS_INTERRUPTMASK_MEM_ADDRESS);
    OSRestoreInterrupts(enabled);
}
