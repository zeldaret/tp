//
// Generated By: dol2asm
// Translation Unit: GXFrameBuf
//

#include "dolphin/gx/GXFrameBuf.h"
#include "dolphin/gx/GX.h"
#include "dol2asm.h"
#include "dolphin/types.h"

//
// Forward References:
//

void GXSetDispCopyFrame2Field();
void GXSetCopyClamp();
void GXSetCopyClear();
void GXSetDispCopyGamma();
void GXClearBoundingBox();
extern u8 GXNtsc480IntDf[60];
extern u8 GXNtsc480Int[60];
extern u8 GXMpal480IntDf[60];
extern u8 GXPal528IntDf[60];
extern u8 GXEurgb60Hz480IntDf[60 + 4 /* padding */];

//
// External References:
//

void __cvt_fp2unsigned();

//
// Declarations:
//

/* 8035CA04-8035CA80 357344 007C+00 0/0 2/2 0/0 .text            GXSetDispCopySrc */
void GXSetDispCopySrc(u16 left, u16 top, u16 width, u16 height)
{
    __GXData->field_0x1e0 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1e0, 22, 10, left);
    GX_BITFIELD_SET(__GXData->field_0x1e0, 12, 10, top);
    GX_BITFIELD_SET(__GXData->field_0x1e0, 0, 8, 73);
    __GXData->field_0x1e4 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1e4, 22, 10, width - 1);
    GX_BITFIELD_SET(__GXData->field_0x1e4, 12, 10, height - 1);
    GX_BITFIELD_SET(__GXData->field_0x1e4, 0, 8, 74);
}

/* 8035CA80-8035CAFC 3573C0 007C+00 0/0 9/9 0/0 .text            GXSetTexCopySrc */
void GXSetTexCopySrc(u16 left, u16 top, u16 width, u16 height)
{
    __GXData->field_0x1f0 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1f0, 22, 10, left);
    GX_BITFIELD_SET(__GXData->field_0x1f0, 12, 10, top);
    GX_BITFIELD_SET(__GXData->field_0x1f0, 0, 8, 0x49);
    __GXData->field_0x1f4 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1f4, 22, 10, width - 1);
    GX_BITFIELD_SET(__GXData->field_0x1f4, 12, 10, height - 1);
    GX_BITFIELD_SET(__GXData->field_0x1f4, 0, 8, 0x4A);
}

/* 8035CAFC-8035CB30 35743C 0034+00 0/0 2/2 0/0 .text            GXSetDispCopyDst */
void GXSetDispCopyDst(u16 arg0, u16 arg1)
{
    s32 val = (s32) ((arg0 << 1) & 0xFFFE) >> 5;
    __GXData->field_0x1e8 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1e8, 22, 10, val);
    GX_BITFIELD_SET(__GXData->field_0x1e8, 0, 8, 0x4D);
}

/* 8035CB30-8035CC60 357470 0130+00 0/0 9/9 0/0 .text            GXSetTexCopyDst */
#ifdef NONMATCHING
void GXSetTexCopyDst(u16 width, u16 height, s32 fmt, GXBool mipmap) {
    s32 fmt2;
    s32 arg3, arg4, arg5;
    __GXData->field_0x200 = 0;

    fmt2 = fmt & 0xf;
    if ((s32)fmt == GX_TF_Z16) {
        fmt2 = 0xb;
    }

    switch (fmt) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 0x26:
        GX_BITFIELD_SET(__GXData->cpTex, 15, 2, 3);
        break;
    default:
        GX_BITFIELD_SET(__GXData->cpTex, 15, 2, 2);
        break;
    }

    __GXData->field_0x200 = 0x10 == (fmt & 0x10);
    __GXData->cpTex = __rlwimi(__GXData->cpTex, fmt2, 0, 28, 28);
    fmt2 &= 7;
    __GetImageTileCount(fmt, width, height, &arg3, &arg4, &arg5);
    __GXData->field_0x1f8 = 0;
    GX_BITFIELD_SET(__GXData->field_0x1f8, 22, 10, arg3*arg5);
    GX_BITFIELD_SET(__GXData->field_0x1f8, 0, 8, 0x4d);
    GX_BITFIELD_SET(__GXData->cpTex, 22, 1, mipmap);
    GX_BITFIELD_SET(__GXData->cpTex, 25, 3, fmt2);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void GXSetTexCopyDst(u16 width, u16 height, s32 fmt, GXBool mipmap) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXSetTexCopyDst.s"
}
#pragma pop
#endif

/* 8035CC60-8035CC84 3575A0 0024+00 0/0 1/1 0/0 .text            GXSetDispCopyFrame2Field */
void GXSetDispCopyFrame2Field(GXCopyMode arg0)
{
    GX_BITFIELD_SET(__GXData->field_0x1ec, 18, 2, arg0);
    GX_BITFIELD_SET(__GXData->cpTex, 18, 2, 0);
}
#define INSERT_FIELD(reg, value, nbits, shift)                                 \
    (reg) = ((u32) (reg) & ~(((1 << (nbits)) - 1) << (shift))) |               \
            ((u32) (value) << (shift));

/* 8035CC84-8035CCDC 3575C4 0058+00 0/0 2/2 0/0 .text            GXSetCopyClamp */
void GXSetCopyClamp(GXFBClamp clamp) {
    u8 isTop = (clamp & GX_CLAMP_TOP) == GX_CLAMP_TOP;
    u8 isBottom = (clamp & GX_CLAMP_BOTTOM) == GX_CLAMP_BOTTOM;
    __GXData->field_0x1ec = __rlwimi(__GXData->field_0x1ec, isTop, 0, 31, 31);
    __GXData->field_0x1ec = __rlwimi(__GXData->field_0x1ec, isBottom, 1, 30, 30);
    __GXData->cpTex = __rlwimi(__GXData->cpTex, isTop, 0, 31, 31);
    __GXData->cpTex = __rlwimi(__GXData->cpTex, isBottom, 1, 30, 30);
}

/* ############################################################################################## */
/* 804565A8-804565B0 004BA8 0004+04 3/3 0/0 0/0 .sdata2          @179 */
SECTION_SDATA2 static f32 lit_179[1 + 1 /* padding */] = {
    256.0f,
    /* padding */
    0.0f,
};

static u32 __GXGetNumXfbLines(u16 efb_height, u32 y_scale) {
    u32 rv = ((efb_height - 1) * 0x100) / y_scale + 1;
    if (y_scale > 0x80 && y_scale < 0x100) {
        for (; (y_scale & 1) == 0; y_scale >>= 1) {
        }
        if (efb_height % y_scale == 0) {
            rv++;
        }
    }
    if (rv > 0x400) {
        rv = 0x400;
    }
    return rv;
}

/* 8035CCDC-8035CD6C 35761C 0090+00 0/0 2/2 0/0 .text            GXGetNumXfbLines */
// regalloc
#ifdef NONMATCHING
u16 GXGetNumXfbLines(u32 efb_height, f32 y_scale) {
    return __GXGetNumXfbLines(efb_height, ((u32)(256.0f / y_scale)) & 0x1ff);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u16 GXGetNumXfbLines(u32 efb_height, f32 y_scale) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXGetNumXfbLines.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 804565B0-804565B8 004BB0 0008+00 1/1 0/0 0/0 .sdata2          @234 */
SECTION_SDATA2 static f64 lit_234 = 4503599627370496.0 /* cast u32 to float */;

/* 8035CD6C-8035CFA4 3576AC 0238+00 0/0 2/2 0/0 .text            GXGetYScaleFactor */
// Matches with literals
#ifdef NONMATCHING
f32 GXGetYScaleFactor(u16 efb_height, u16 xfb_height) {
    u8 padding[0x10];
    u32 uVar6 = xfb_height;
    f32 f29;
    f32 ratio = (f32)xfb_height / (f32)efb_height;
    u32 uVar5 = __GXGetNumXfbLines(efb_height, (u32)(256.0f / ratio) & 0x1ff);
    while (uVar5 > xfb_height) {
        uVar6--;
        ratio = (f32)uVar6 / (f32)efb_height;
        uVar5 = __GXGetNumXfbLines(efb_height, ((u32)(256.0f / ratio)) & 0x1ff);
    }
    f29 = ratio;
    while (uVar5 < xfb_height) {
        uVar6++;
        f29 = ratio;
        ratio = (f32)uVar6 / (f32)efb_height;
        uVar5 = __GXGetNumXfbLines(efb_height, ((u32)(256.0f / ratio)) & 0x1ff);
    }

    return f29;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm f32 GXGetYScaleFactor(u16 efb_height, u16 xfb_height) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXGetYScaleFactor.s"
}
#pragma pop
#endif

/* 8035CFA4-8035D070 3578E4 00CC+00 0/0 2/2 0/0 .text            GXSetDispCopyYScale */
// Needs works
#ifdef NONMATCHING
u32 GXSetDispCopyYScale(f32 y_scale) {
    u32 r5;
    u32 r6;
    u32 r7 = ((u32)(256.0f / y_scale)) & 0x1ff;
    GXFIFO.u8 = 0x61;
    r6 = 0;
    GX_BITFIELD_SET(r6, 0x17, 9, r7);
    GX_BITFIELD_SET(r6, 0, 7, 0x4e);
    GXFIFO.u32 = r6;
    __GXData->bpSentNot = 0;
    r5 = 0x100 - r7 != 1;
    GX_BITFIELD_SET(__GXData->field_0x1ec, 0x15, 1, r5);
    return __GXGetNumXfbLines(__GXData->field_0x1e4, r7);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u32 GXSetDispCopyYScale(f32 y_scale) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXSetDispCopyYScale.s"
}
#pragma pop
#endif

/* 8035D070-8035D0E8 3579B0 0078+00 0/0 2/2 0/0 .text            GXSetCopyClear */
void GXSetCopyClear(GXColor color, u32 clear_z) {
    u32 r6 = 0;
    GX_BITFIELD_SET(r6, 24, 8, color.r);
    GX_BITFIELD_SET(r6, 16, 8, color.a);
    GX_BITFIELD_SET(r6, 0, 8, 0x4f);
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r6;

    r6 = 0;
    GX_BITFIELD_SET(r6, 24, 8, color.b);
    GX_BITFIELD_SET(r6, 16, 8, color.g);
    GX_BITFIELD_SET(r6, 0, 8, 0x50);
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r6;

    r6 = 0;
    GX_BITFIELD_SET(r6, 8, 24, clear_z);
    GX_BITFIELD_SET(r6, 0, 8, 0x51);
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r6;

    __GXData->bpSentNot = 0;
}

/* 8035D0E8-8035D2F0 357A28 0208+00 0/0 4/4 0/0 .text            GXSetCopyFilter */
// Start of antialias if. Possibly variable definition order.
#ifdef NONMATCHING
void GXSetCopyFilter(GXBool antialias, u8 pattern[12][2], GXBool vf, u8 vfilter[7]) {
    u32 r8;
    u32 r7;
    u32 r3;
    u32 r9;
    u32 r11;
    u32 r5;
    if (antialias) {
        r3 = 0;
        GX_BITFIELD_SET(r3, 0x1c, 4, pattern[0][0]);
        GX_BITFIELD_SET(r3, 0x18, 4, pattern[0][1]);
        GX_BITFIELD_SET(r3, 0x14, 4, pattern[1][0]);
        GX_BITFIELD_SET(r3, 0x10, 4, pattern[1][1]);
        GX_BITFIELD_SET(r3, 0xc, 4, pattern[2][0]);
        GX_BITFIELD_SET(r3, 0x8, 4, pattern[2][1]);
        GX_BITFIELD_SET(r3, 0, 8, 1);

        r7 = 0;
        GX_BITFIELD_SET(r7, 0x1c, 4, pattern[3][0]);
        GX_BITFIELD_SET(r7, 0x18, 4, pattern[3][1]);
        GX_BITFIELD_SET(r7, 0x14, 4, pattern[4][0]);
        GX_BITFIELD_SET(r7, 0x10, 4, pattern[4][1]);
        GX_BITFIELD_SET(r7, 0xc, 4, pattern[5][0]);
        GX_BITFIELD_SET(r7, 0x8, 4, pattern[5][1]);
        GX_BITFIELD_SET(r7, 0, 8, 2);

        r8 = 0;
        GX_BITFIELD_SET(r8, 0x1c, 4, pattern[6][0]);
        GX_BITFIELD_SET(r8, 0x18, 4, pattern[6][1]);
        GX_BITFIELD_SET(r8, 0x14, 4, pattern[7][0]);
        GX_BITFIELD_SET(r8, 0x10, 4, pattern[7][1]);
        GX_BITFIELD_SET(r8, 0xc, 4, pattern[8][0]);
        GX_BITFIELD_SET(r8, 0x8, 4, pattern[8][1]);
        GX_BITFIELD_SET(r8, 0, 8, 3);

        r9 = 0;
        GX_BITFIELD_SET(r9, 0x1c, 4, pattern[9][0]);
        GX_BITFIELD_SET(r9, 0x18, 4, pattern[9][1]);
        GX_BITFIELD_SET(r9, 0x14, 4, pattern[10][0]);
        GX_BITFIELD_SET(r9, 0x10, 4, pattern[10][1]);
        GX_BITFIELD_SET(r9, 0xc, 4, pattern[11][0]);
        GX_BITFIELD_SET(r9, 0x8, 4, pattern[11][1]);
        GX_BITFIELD_SET(r9, 0, 8, 4);
    } else {
        r3 = 0x01666666;
        r7 = 0x02666666;
        r8 = 0x03666666;
        r9 = 0x04666666;
    }

    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r3;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r7;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r8;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r9;

    r11 = 0;
    GX_BITFIELD_SET(r11, 0, 8, 0x53);
    r5 = 0;
    GX_BITFIELD_SET(r5, 0, 8, 0x54);
    if (vf) {
        GX_BITFIELD_SET(r11, 0x1a, 6, vfilter[0]);
        GX_BITFIELD_SET(r11, 0x14, 6, vfilter[1]);
        GX_BITFIELD_SET(r11, 0xe, 6, vfilter[2]);
        GX_BITFIELD_SET(r11, 0x8, 6, vfilter[3]);
        GX_BITFIELD_SET(r5, 0x1a, 6, vfilter[4]);
        GX_BITFIELD_SET(r5, 0x14, 6, vfilter[5]);
        GX_BITFIELD_SET(r5, 0xe, 6, vfilter[6]);
    } else {
        GX_BITFIELD_SET(r11, 0x1a, 6, 0);
        GX_BITFIELD_SET(r11, 0x14, 6, 0);
        GX_BITFIELD_SET(r11, 0xe, 6, 0x15);
        GX_BITFIELD_SET(r11, 0x8, 6, 0x16);

        GX_BITFIELD_SET(r5, 0x1a, 6, 0x15);
        GX_BITFIELD_SET(r5, 0x14, 6, 0);
        GX_BITFIELD_SET(r5, 0xe, 6, 0);
    }

    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r11;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r5;
    __GXData->bpSentNot = 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void GXSetCopyFilter(GXBool antialias, u8 pattern[12][2], GXBool vf, u8 vfilter[7]) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXSetCopyFilter.s"
}
#pragma pop
#endif

/* 8035D2F0-8035D304 357C30 0014+00 0/0 2/2 0/0 .text            GXSetDispCopyGamma */
void GXSetDispCopyGamma(GXGamma gamma)
{
    GX_BITFIELD_SET(__GXData->field_0x1ec, 23, 2, gamma);
}

/* 8035D304-8035D46C 357C44 0168+00 0/0 3/3 0/0 .text            GXCopyDisp */
// regalloc / instruction order
#ifdef NONMATCHING
void GXCopyDisp(void* dst, GXBool clear) {
    u32 r7;
    u32 r8;
    GXBool r10;
    u32 r9;
    u32 field_0x1dc;
    if (clear) {
        r8 = __GXData->field_0x1d8;
        GX_BITFIELD_SET(r8, 0x1f, 1, 1);
        GX_BITFIELD_SET(r8, 0x1c, 3, 7);
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = r8;

        r7 = __GXData->field_0x1d0;
        GX_BITFIELD_SET(r7, 0x1f, 1, 0);
        GX_BITFIELD_SET(r7, 0x1e, 1, 0);
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = r7;
    }

    r10 = 0;
    if (clear || (__GXData->field_0x1dc & 0x7) == 3) {
        field_0x1dc = __GXData->field_0x1dc;
        if (((field_0x1dc >> 6) & 1) == 1) {
            GX_BITFIELD_SET(field_0x1dc, 0x19, 1, 0);
            GXFIFO.u8 = 0x61;
            GXFIFO.u32 = field_0x1dc;
            r10 = 1;
        }
    }

    r9 = 0;
    __rlwimi(r9, (int)dst, 0x1b, 0xb, 0x1f);
    GX_BITFIELD_SET(r9, 0, 8, 0x4b);

    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1e0;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1e4;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1e8;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r9;

    GX_BITFIELD_SET(__GXData->field_0x1ec, 0x14, 1, clear);
    GX_BITFIELD_SET(__GXData->field_0x1ec, 0x11, 1, 1);
    GX_BITFIELD_SET(__GXData->field_0x1ec, 0, 8, 0x52);

    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1ec;

    if (clear) {
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1d8;
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1d0;
    }

    if (r10) {
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1dc;
    }

    __GXData->bpSentNot = 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void GXCopyDisp(void* dst, GXBool clear) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXCopyDisp.s"
}
#pragma pop
#endif

/* 8035D46C-8035D5F8 357DAC 018C+00 0/0 9/9 0/0 .text            GXCopyTex */
// regalloc
#ifdef NONMATCHING
void GXCopyTex(void* dst, GXBool clear) {
    u32 r8;
    u32 r7;
    u32 field_0x1dc;
    u8 r0;
    u32 r10;
    if (clear) {
        r8 = __GXData->field_0x1d8;
        GX_BITFIELD_SET(r8, 0x1f, 1, 1);
        GX_BITFIELD_SET(r8, 0x1c, 3, 7);
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = r8;

        r7 = __GXData->field_0x1d0;
        GX_BITFIELD_SET(r7, 0x1f, 1, 0);
        GX_BITFIELD_SET(r7, 0x1e, 1, 0);
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = r7;
    }

    r0 = 0;
    field_0x1dc = __GXData->field_0x1dc;
    if (__GXData->bpSentNot && (field_0x1dc & 0x7) != 3) {
        GX_BITFIELD_SET(r7, 0x1d, 3, 3);
        r0 = 1;
    }

    if ((clear || (field_0x1dc & 0x7) == 3) && ((field_0x1dc >> 6) & 1) == 1) {
        GX_BITFIELD_SET(r7, 0x19, 1, 0);
        r0 = 1;
    }

    if (r0) {
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = r7;
    }

    r10 = 0;
    __rlwimi(r10, (int)dst, 0x1b, 0xb, 0x1f);
    GX_BITFIELD_SET(r10, 0, 8, 0x4b);
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1f0;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1f4;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->field_0x1f8;
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = r10;
    GX_BITFIELD_SET(__GXData->cpTex, 0x14, 1, clear);
    GX_BITFIELD_SET(__GXData->cpTex, 0x11, 1, 0);
    GX_BITFIELD_SET(__GXData->cpTex, 0, 8, 0x52);
    GXFIFO.u8 = 0x61;
    GXFIFO.u32 = __GXData->cpTex;
    if (clear) {
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1d8;
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1d0;
    }

    if (r0) {
        GXFIFO.u8 = 0x61;
        GXFIFO.u32 = __GXData->field_0x1dc;
    }

    __GXData->bpSentNot = 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void GXCopyTex(void* dst, GXBool clear) {
    nofralloc
#include "asm/dolphin/gx/GXFrameBuf/GXCopyTex.s"
}
#pragma pop
#endif

/* 8035D5F8-8035D630 357F38 0038+00 0/0 1/1 0/0 .text            GXClearBoundingBox */
void GXClearBoundingBox(void)
{
    GXFIFO.u8 = GX_LOAD_BP_REG;
    GXFIFO.u32 = 0x550003FF;
    GXFIFO.u8 = GX_LOAD_BP_REG;
    GXFIFO.u32 = 0x560003FF;
    set_x2(GX_FALSE);
}

/* ############################################################################################## */
/* 803D2448-803D2484 02F568 003C+00 0/0 2/1 0/0 .data            GXNtsc480IntDf */
SECTION_DATA extern u8 GXNtsc480IntDf[60] = {
    0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x01, 0xE0, 0x01, 0xE0, 0x00, 0x28, 0x00, 0x00, 0x02,
    0x80, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x0A, 0x0C, 0x0A, 0x08, 0x08, 0x00, 0x00, 0x00,
};

/* 803D2484-803D24C0 02F5A4 003C+00 0/0 1/1 0/0 .data            GXNtsc480Int */
SECTION_DATA extern u8 GXNtsc480Int[60] = {
    0x00, 0x00, 0x00, 0x00, 0x02, 0x80, 0x01, 0xE0, 0x01, 0xE0, 0x00, 0x28, 0x00, 0x00, 0x02,
    0x80, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x15, 0x16, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/* 803D24C0-803D24FC 02F5E0 003C+00 0/0 1/1 0/0 .data            GXMpal480IntDf */
SECTION_DATA extern u8 GXMpal480IntDf[60] = {
    0x00, 0x00, 0x00, 0x08, 0x02, 0x80, 0x01, 0xE0, 0x01, 0xE0, 0x00, 0x28, 0x00, 0x00, 0x02,
    0x80, 0x01, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x0A, 0x0C, 0x0A, 0x08, 0x08, 0x00, 0x00, 0x00,
};

/* 803D24FC-803D2538 02F61C 003C+00 0/0 1/1 0/0 .data            GXPal528IntDf */
SECTION_DATA extern u8 GXPal528IntDf[60] = {
    0x00, 0x00, 0x00, 0x04, 0x02, 0x80, 0x02, 0x10, 0x02, 0x10, 0x00, 0x28, 0x00, 0x17, 0x02,
    0x80, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
    0x06, 0x06, 0x06, 0x06, 0x06, 0x08, 0x08, 0x0A, 0x0C, 0x0A, 0x08, 0x08, 0x00, 0x00, 0x00,
};

/* 803D2538-803D2578 02F658 003C+04 0/0 1/1 0/0 .data            GXEurgb60Hz480IntDf */
SECTION_DATA extern u8 GXEurgb60Hz480IntDf[60 + 4 /* padding */] = {
    0x00,
    0x00,
    0x00,
    0x14,
    0x02,
    0x80,
    0x01,
    0xE0,
    0x01,
    0xE0,
    0x00,
    0x28,
    0x00,
    0x00,
    0x02,
    0x80,
    0x01,
    0xE0,
    0x00,
    0x00,
    0x00,
    0x00,
    0x00,
    0x01,
    0x00,
    0x00,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x06,
    0x08,
    0x08,
    0x0A,
    0x0C,
    0x0A,
    0x08,
    0x08,
    0x00,
    0x00,
    0x00,
    /* padding */
    0x00,
    0x00,
    0x00,
    0x00,
};
