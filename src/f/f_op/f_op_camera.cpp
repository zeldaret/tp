/* f_op_camera.cpp autogenerated by split.py v0.4 at 2021-02-15 20:13:32.027855 */

#include "f/f_op/f_op_camera.h"
#include "d/d_com/d_com_inf_game/d_com_inf_game.h"
#include "f/f_op/f_op_draw_tag.h"
#include "f/f_pc/f_pc_leaf.h"
#include "global.h"

// additional symbols needed for f_op_camera.cpp
// autogenerated by split.py v0.4 at 2021-02-15 20:13:32.027886
extern "C" {
void fopDwTg_DrawQTo(void);
void fopDwTg_Init__FP16create_tag_classPv(void);
void fopDwTg_ToDrawQ__FP16create_tag_classi(void);
void func_8001E180(void);
void func_8001E1C8(void);
void func_8001E21C(void);
void func_8001E270(void);
void fopDwTg_DrawQTo__FP16create_tag_class(void);
void fpcLf_GetPriority__FPC14leafdraw_class(void);
}

// additional symbols needed for f_op_camera.cpp
// autogenerated by split.py v0.4 at 2021-02-15 20:13:32.027892
extern s8 lbl_80451124;

s32 fopCam_Draw(camera_class* pCamera) {
    s32 tmp = 1;

    if (g_dComIfG_gameInfo.getPlay().getField0x4f7d() == false) {
        tmp = fpcLf_DrawMethod(pCamera->pMthd, pCamera);
    }
    return tmp;
}

// Matches, but wrong registers
#ifdef NONMATCHING
void fopCam_Execute(camera_class* pCamera) {
    if (!g_dComIfG_gameInfo.getPlay().getField0x4f7d() && !lbl_80451124) {
        fpcMtd_Execute((process_method_class*)pCamera->pMthd, pCamera);
    }
}
#else
asm void fopCam_Execute(camera_class* pCamera) {
    nofralloc
#include "f/f_op/f_op_camera/asm/func_8001E180.s"
}
#endif

int fopCam_IsDelete(camera_class* pCamera) {
    int tmp = fpcMtd_IsDelete((process_method_class*)pCamera->pMthd, pCamera);
    if (tmp == 1) {
        fopDwTg_DrawQTo(&pCamera->pCreateTag);
    }

    return tmp;
}

int fopCam_Delete(camera_class* pCamera) {
    int tmp = fpcMtd_Delete((process_method_class*)pCamera->pMthd, pCamera);
    if (tmp == 1) {
        fopDwTg_DrawQTo(&pCamera->pCreateTag);
    }

    return tmp;
}

asm void fopCam_Create(void*) {
    nofralloc
#include "f/f_op/f_op_camera/asm/func_8001E270.s"
}
