//
// Generated By: dol2asm
// Translation Unit: std-vector
//

#include "JSystem/JGadget/std-vector.h"
#include "dolphin/types.h"
#include "algorithm.h"

//
// Types:
//

namespace JGadget {
struct vector {
    /* 802DCCC8 */ static u32 extend_default(u32, u32, u32);
};

template <typename T>
struct TAllocator {
    void destroy(T* item) {}
    void deallocate(T* mem, u32 size) {
        DeallocateRaw(mem);
    }
    void DeallocateRaw(T* mem) {
        delete mem;
    }
    T* allocate(u32 count, void *param_2) {
        return AllocateRaw(count * sizeof(T));
    }
    T* AllocateRaw(u32 size) {
        return (T*)new char[size];
    }

    u8 field_0x0;
};
/* TAllocator<void*> */
struct TAllocator__template0 {};

typedef u32 (*extendFunc)(u32, u32, u32);

template <typename T, typename Allocator = JGadget::TAllocator<T> >
struct TVector {
    struct TDestructed_deallocate_ {
        TDestructed_deallocate_(Allocator* allocator, T* addr) {
            mAllocator = allocator;
            mAddr = addr;
        }
        void set(T* addr) {
            mAddr = addr;
        }
        inline ~TDestructed_deallocate_() {
            mAllocator->deallocate(mAddr, 0);
        }
        Allocator* mAllocator;
        T* mAddr;
    };

    TVector(Allocator const& param_0) {
        field_0x0 = param_0;
        pBegin_ = NULL;
        pEnd_ = pBegin_;
        mCapacity = 0;
        pfnExtend_ = JGadget::vector::extend_default;
    }

    ~TVector() {
        clear();
        field_0x0.deallocate(pBegin_, 0);
    }

    T* insert(T* pos, const T& val) {
        u32 diff = (u32)pos - (u32)begin();
        insert(pos, 1, val);
        return pBegin_ + diff;
    }

    void insert(T* pos, u32 count, const T& val) {
        if (count != 0) {
            T* this_00 = Insert_raw(pos, count);
            if (this_00 != end()) {
                std::uninitialized_fill_n(this_00, count, val);
            }
        }
    }

    T* Insert_raw(T* pos, u32 count) {
        if (count == 0) {
            return pos;
        }
        if (mCapacity < count + size()) {
            u32 uVar4 = GetSize_extend_(count);
            T* ppvVar5 = field_0x0.allocate(uVar4, NULL);
            if (ppvVar5 == NULL) {
                pos = end();
            } else {
                TDestructed_deallocate_ aTStack_30(&field_0x0, ppvVar5);
                T* ppvVar6 = std::uninitialized_copy(pBegin_, pos, ppvVar5);
                std::uninitialized_copy(pos, pEnd_, ppvVar6 + count);
                DestroyElement_all_();
                aTStack_30.set(pBegin_);
                u32 uVar2 = (u32)pEnd_ - (u32)pBegin_;
                pEnd_ = ppvVar5 + count + (uVar2 / 4);
                pBegin_ = ppvVar5;
                mCapacity = uVar4;
                pos = ppvVar6;
            }
        } else {
            T* ppvVar5 = pos + count;
            if (ppvVar5 < pEnd_) {
                T* ppvVar6 = pEnd_ - count;
                std::uninitialized_copy(ppvVar6, pEnd_, pEnd_);
                std::copy_backward(pos, ppvVar6, pEnd_);
                DestroyElement_(pos, ppvVar5);
                pEnd_ += count;
            } else {
                std::uninitialized_copy(pos, pEnd_, ppvVar5);
                DestroyElement_(pos, pEnd_);
                pEnd_ += count;
            }
        }
        return pos;
    }

    T* begin() {
        return pBegin_;
    }

    T* end() {
        return pEnd_;
    }

    u32 size() {
        if (pBegin_ == 0) {
            return 0;
        }
        return ((u32)pEnd_ - (u32)pBegin_) / 4;
    }

    u32 capacity() { return mCapacity; }

    u32 GetSize_extend_(u32 count) {
        u32 iVar2 = size();
        u32 uVar3 = capacity();
        u32 uVar4 = pfnExtend_(uVar3, iVar2, count);
        if (uVar4 < iVar2 + count) {
            uVar4 = iVar2 + count;
        }
        return uVar4;
    }

    void DestroyElement_(T* start, T* end) {
        for (; start != end; start++) {
            field_0x0.destroy(start);
        }
    }

    void DestroyElement_all_() {
        DestroyElement_(pBegin_, pEnd_);
    }

    T* erase(T* start, T* end) {
        T* vectorEnd = pEnd_;
        T* ppvVar3 = std::copy(end, vectorEnd, start);
        DestroyElement_(ppvVar3, pEnd_);
        pEnd_ = ppvVar3;
        return start;
    }

    void clear() {
        erase(begin(), end());
    }

    Allocator field_0x0;
    T* pBegin_;
    T* pEnd_;
    u32 mCapacity;
    extendFunc pfnExtend_;
};
/* TVector<void*, JGadget::TAllocator<void*>> */
struct TVector__template0 {
    /* 802DD130 */ void func_802DD130(void* _this, void**, void* const&);
    /* 802DCE1C */ void func_802DCE1C(void* _this, void**, u32, void* const&);
    /* 802DCE8C */ void func_802DCE8C(void* _this, void**, u32);
};

struct TVector_pointer_void : public TVector<void*> {
    /* 802DCCD0 */ TVector_pointer_void(JGadget::TAllocator<void*> const&);
    /* 802DCCFC */ ~TVector_pointer_void();
    /* 802DCDA4 */ void insert(void**, void* const&);
    /* 802DCDC4 */ void** erase(void**, void**);
};

};  // namespace JGadget

//
// Forward References:
//

extern "C" void extend_default__Q27JGadget6vectorFUlUlUl();
extern "C" void func_802DCCD0();
extern "C" void __dt__Q27JGadget20TVector_pointer_voidFv();
extern "C" void insert__Q27JGadget20TVector_pointer_voidFPPvRCPv();
extern "C" void erase__Q27JGadget20TVector_pointer_voidFPPvPPv();
extern "C" void func_802DCE1C(void* _this, void**, u32, void* const&);
extern "C" void func_802DCE8C(void* _this, void**, u32);
extern "C" void func_802DD130(void* _this, void**, void* const&);

//
// External References:
//

extern "C" void* __nw__FUl();
extern "C" void __dl__FPv();
extern "C" void _savegpr_27();
extern "C" void _savegpr_29();
extern "C" void _restgpr_27();
extern "C" void _restgpr_29();

//
// Declarations:
//

/* 802DCCC8-802DCCD0 2D7608 0008+00 1/1 0/0 0/0 .text extend_default__Q27JGadget6vectorFUlUlUl */
u32 JGadget::vector::extend_default(u32 param_0, u32 param_1, u32 param_2) {
    return param_1 << 1;
}

/* 802DCCD0-802DCCFC 2D7610 002C+00 0/0 1/1 0/0 .text
 * __ct__Q27JGadget20TVector_pointer_voidFRCQ27JGadget14TAllocator<Pv> */
JGadget::TVector_pointer_void::TVector_pointer_void(JGadget::TAllocator<void*> const& param_0) : TVector<void*>(param_0) {
}

/* 802DCCFC-802DCDA4 2D763C 00A8+00 0/0 2/2 0/0 .text __dt__Q27JGadget20TVector_pointer_voidFv */
JGadget::TVector_pointer_void::~TVector_pointer_void() {
}

/* 802DCDA4-802DCDC4 2D76E4 0020+00 0/0 1/1 0/0 .text
 * insert__Q27JGadget20TVector_pointer_voidFPPvRCPv             */
// the entire function chain needs work
#ifdef NONMATCHING
void JGadget::TVector_pointer_void::insert(void** param_0, void* const& param_1) {
    TVector<void*>::insert(param_0, param_1);
}
#else
void JGadget::TVector_pointer_void::insert(void** param_0, void* const& param_1) {
    // NONMATCHING
}
#endif

/* 802DCDC4-802DCE1C 2D7704 0058+00 0/0 1/1 0/0 .text
 * erase__Q27JGadget20TVector_pointer_voidFPPvPPv               */
void** JGadget::TVector_pointer_void::erase(void** param_0, void** param_1) {
    return TVector<void*>::erase(param_0, param_1);
}

/* 802DCE1C-802DCE8C 2D775C 0070+00 1/1 0/0 0/0 .text
 * insert__Q27JGadget38TVector<Pv,Q27JGadget14TAllocator<Pv>>FPPvUlRCPv */
extern "C" void func_802DCE1C(void* _this, void** param_0, u32 param_1, void* const& param_2) {
    // NONMATCHING
}

/* 802DCE8C-802DD130 2D77CC 02A4+00 1/1 0/0 0/0 .text
 * Insert_raw__Q27JGadget38TVector<Pv,Q27JGadget14TAllocator<Pv>>FPPvUl */
extern "C" void func_802DCE8C(void* _this, void** param_0, u32 param_1) {
    // NONMATCHING
}

/* 802DD130-802DD188 2D7A70 0058+00 1/1 0/0 0/0 .text
 * insert__Q27JGadget38TVector<Pv,Q27JGadget14TAllocator<Pv>>FPPvRCPv */
extern "C" void func_802DD130(void* _this, void** param_0, void* const& param_1) {
    // NONMATCHING
}