//
// Generated By: dol2asm
// Translation Unit: JPADynamicsBlock
//

#include "JSystem/JParticle/JPADynamicsBlock.h"
#include "JSystem/JParticle/JPAEmitter.h"
#include "dol2asm.h"

//
// Types:
//

//
// Forward References:
//

extern "C" static void JPAVolumePoint(JPAEmitterWorkData*);
extern "C" static void JPAVolumeLine(JPAEmitterWorkData*);
extern "C" static void JPAVolumeCircle(JPAEmitterWorkData*);
extern "C" static void JPAVolumeCube(JPAEmitterWorkData*);
extern "C" static void JPAVolumeSphere(JPAEmitterWorkData*);
extern "C" static void JPAVolumeCylinder(JPAEmitterWorkData*);
extern "C" static void JPAVolumeTorus(JPAEmitterWorkData*);
extern "C" void __ct__16JPADynamicsBlockFPCUc();
extern "C" void init__16JPADynamicsBlockFv();
extern "C" void create__16JPADynamicsBlockFP18JPAEmitterWorkData();

//
// External References:
//

extern "C" void createParticle__14JPABaseEmitterFv();
extern "C" u8 sincosTable___5JMath[65536];

//
// Declarations:
//

/* ############################################################################################## */
/* 80455310-80455314 003910 0004+00 7/7 0/0 0/0 .sdata2          @2287 */
SECTION_SDATA2 static u8 lit_2287[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80455314-80455318 003914 0004+00 7/7 0/0 0/0 .sdata2          @2288 */
SECTION_SDATA2 static f32 lit_2288 = 1.0f;

/* 80455318-80455320 003918 0004+04 3/3 0/0 0/0 .sdata2          @2289 */
SECTION_SDATA2 static f32 lit_2289[1 + 1 /* padding */] = {
    0.5f,
    /* padding */
    0.0f,
};

/* 8027B144-8027B220 275A84 00DC+00 1/1 0/0 0/0 .text JPAVolumePoint__FP18JPAEmitterWorkData */
void JPAVolumePoint(JPAEmitterWorkData* work) {
    work->mVolumePos.zero();
    work->mVelOmni.set(work->mpEmtr->get_r_zh(), work->mpEmtr->get_r_zh(),
                       work->mpEmtr->get_r_zh());
    work->mVelAxis.set(work->mVelOmni.x, 0.0f, work->mVelOmni.z);
}



/* ############################################################################################## */
/* 80455320-80455328 003920 0008+00 6/6 0/0 0/0 .sdata2          @2321 */
SECTION_SDATA2 static f64 lit_2321 = 4503601774854144.0 /* cast s32 to float */;

/* 8027B220-8027B33C 275B60 011C+00 1/1 0/0 0/0 .text JPAVolumeLine */
void JPAVolumeLine(JPAEmitterWorkData* work) {
    if (work->mpEmtr->checkFlag(JPADynFlag_FixedInterval)) {
        work->mVolumePos.set(0.0f, 0.0f,
                             work->mVolumeSize *
                                 ((work->mVolumeEmitIdx / (work->mEmitCount - 1.0f) - 0.5f)));
        work->mVolumeEmitIdx++;
    } else {
        work->mVolumePos.set(0.0f, 0.0f, work->mVolumeSize * work->mpEmtr->get_r_zh());
    }

    work->mVelOmni.set(0.0f, 0.0f, work->mVolumePos.z * work->mGlobalScl.z);
    work->mVelAxis.set(0.0f, 0.0f, work->mVolumePos.z);
}



/* 8027B33C-8027B4E8 275C7C 01AC+00 1/1 0/0 0/0 .text JPAVolumeCircle */
// regalloc. Could be issue with mul asm implementations
#ifdef NONMATCHING
void JPAVolumeCircle(JPAEmitterWorkData* work) {
    s16 thetai;
    f32 theta;
    f32 distance;
    f32 sizeXZ;
    f32 temp;
    if (work->mpEmtr->checkFlag(JPADynFlag_FixedInterval)) {
        theta = (s16)((work->mVolumeEmitIdx << 16) / work->mEmitCount);
        thetai = theta * work->mVolumeSweep;
        work->mVolumeEmitIdx++;
    } else {
        theta = work->mVolumeSweep * work->mpEmtr->get_r_ss();
        thetai = theta;
    }

    distance = work->mpEmtr->get_r_f();
    if (work->mpEmtr->checkFlag(JPADynFlag_FixedDensity)) {
        distance = 1.0f - (distance * distance);
    }

    sizeXZ = work->mVolumeSize * (work->mVolumeMinRad + distance * (1.0f - work->mVolumeMinRad));
    work->mVolumePos.set(sizeXZ * JMASSin(thetai), 0.0f, sizeXZ * JMASCos(thetai));
    work->mVelOmni.mul(work->mVolumePos, work->mGlobalScl);
    work->mVelAxis.set(work->mVolumePos.x, 0.0f, work->mVolumePos.z);
}

#else

static void JPAVolumeCircle(JPAEmitterWorkData* param_0) {
    // NONMATCHING
}

#endif

/* 8027B4E8-8027B5F0 275E28 0108+00 1/1 0/0 0/0 .text JPAVolumeCube */
void JPAVolumeCube(JPAEmitterWorkData* work) {
    work->mVolumePos.set(work->mpEmtr->get_r_zh() * work->mVolumeSize,
                         work->mpEmtr->get_r_zh() * work->mVolumeSize,
                         work->mpEmtr->get_r_zh() * work->mVolumeSize);
    work->mVelOmni.mul(work->mVolumePos, work->mGlobalScl);
    work->mVelAxis.set(work->mVolumePos.x, 0.0f, work->mVolumePos.z);
}



/* ############################################################################################## */
/* 80455328-80455330 003928 0004+04 1/1 0/0 0/0 .sdata2          @2501 */
SECTION_SDATA2 static f32 lit_2501[1 + 1 /* padding */] = {
    32768.0f,
    /* padding */
    0.0f,
};

/* 80455330-80455338 003930 0008+00 1/1 0/0 0/0 .sdata2          @2503 */
SECTION_SDATA2 static f64 lit_2503 = 4503599627370496.0 /* cast u32 to float */;

/* 8027B5F0-8027B87C 275F30 028C+00 1/1 0/0 0/0 .text JPAVolumeSphere__FP18JPAEmitterWorkData */
static void JPAVolumeSphere(JPAEmitterWorkData* param_0) {
    // NONMATCHING
}

/* 8027B87C-8027B9F8 2761BC 017C+00 1/1 0/0 0/0 .text JPAVolumeCylinder__FP18JPAEmitterWorkData */
static void JPAVolumeCylinder(JPAEmitterWorkData* param_0) {
    // NONMATCHING
}

/* 8027B9F8-8027BB18 276338 0120+00 1/1 0/0 0/0 .text JPAVolumeTorus__FP18JPAEmitterWorkData */
static void JPAVolumeTorus(JPAEmitterWorkData* param_0) {
    // NONMATCHING
}

/* 8027BB18-8027BB4C 276458 0034+00 0/0 1/1 0/0 .text            __ct__16JPADynamicsBlockFPCUc */
JPADynamicsBlock::JPADynamicsBlock(u8 const* data) {
    mpData = (const JPADynamicsBlockData*)data;
    init();
}

enum {
    VOL_Cube = 0x00,
    VOL_Sphere = 0x01,
    VOL_Cylinder = 0x02,
    VOL_Torus = 0x03,
    VOL_Point = 0x04,
    VOL_Circle = 0x05,
    VOL_Line = 0x06,
};

/* 8027BB4C-8027BBE8 27648C 009C+00 2/1 0/0 0/0 .text            init__16JPADynamicsBlockFv */
void JPADynamicsBlock::init() {
    switch (getVolumeType()) {
    case VOL_Cube:
        mpCalcVolumeFunc = &JPAVolumeCube;
        break;
    case VOL_Sphere:
        mpCalcVolumeFunc = &JPAVolumeSphere;
        break;
    case VOL_Cylinder:
        mpCalcVolumeFunc = &JPAVolumeCylinder;
        break;
    case VOL_Torus:
        mpCalcVolumeFunc = &JPAVolumeTorus;
        break;
    case VOL_Point:
        mpCalcVolumeFunc = &JPAVolumePoint;
        break;
    case VOL_Circle:
        mpCalcVolumeFunc = &JPAVolumeCircle;
        break;
    case VOL_Line:
        mpCalcVolumeFunc = &JPAVolumeLine;
        break;
    }
}

/* 8027BBE8-8027BDEC 276528 0204+00 0/0 1/1 0/0 .text
 * create__16JPADynamicsBlockFP18JPAEmitterWorkData             */

#ifdef NONMATCHING

// literal only
void JPADynamicsBlock::create(JPAEmitterWorkData* work) {
    if (work->mpEmtr->checkStatus(JPAEmtrStts_RateStepEmit)) {
        s32 emitCount;
        s32 createCount;

        // Probably an inlined function.
        if (work->mpEmtr->checkFlag(JPADynFlag_FixedInterval)) {
            s32 count;
            if (getVolumeType() == VOL_Sphere) {
                count = 4 * getDivNumber() * getDivNumber() + 2;
            } else {
                count = getDivNumber();
            }
            emitCount = count;

            work->mVolumeEmitIdx = 0;
        } else {
            f32 newPtclCount =
                work->mpEmtr->mRate * (getRateRndm() * work->mpEmtr->get_r_zp() + 1.0f);
            f32 newEmitCount = work->mpEmtr->mEmitCount + newPtclCount;
            work->mpEmtr->mEmitCount = newEmitCount;
            emitCount = (s32)newEmitCount;
            work->mpEmtr->mEmitCount -= emitCount;

            if (work->mpEmtr->checkStatus(JPAEmtrStts_FirstEmit) && 0.0f < newPtclCount &&
                newPtclCount < 1.0f)
                emitCount = 1;
        }

        work->mEmitCount = emitCount;
        if (work->mpEmtr->checkStatus(JPAEmtrStts_StopEmit)) {
            emitCount = 0;
        }

        // Probably an inlined function.
        createCount = emitCount;
        while (createCount > 0) {
            JPABaseParticle* ptcl = work->mpEmtr->createParticle();
            if (ptcl == NULL)
                break;
            createCount--;
        }
    }

    if (++work->mpEmtr->mRateStepTimer >= (work->mpEmtr->mRateStep + 1)) {
        work->mpEmtr->mRateStepTimer -= (work->mpEmtr->mRateStep + 1);
        work->mpEmtr->setStatus(JPAEmtrStts_RateStepEmit);
    } else {
        work->mpEmtr->clearStatus(JPAEmtrStts_RateStepEmit);
    }

    work->mpEmtr->clearStatus(JPAEmtrStts_FirstEmit);
}

#else

void JPADynamicsBlock::create(JPAEmitterWorkData* param_0) {
    // NONMATCHING
}

#endif