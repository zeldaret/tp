//
// Generated By: dol2asm
// Translation Unit: JASAramStream
//

#include "JSystem/JAudio2/JASAramStream.h"
#include "JSystem/JAudio2/JASChannel.h"
#include "JSystem/JAudio2/JASCriticalSection.h"
#include "JSystem/JAudio2/JASDriverIF.h"
#include "JSystem/JAudio2/JASDvdThread.h"
#include "JSystem/JKernel/JKRSolidHeap.h"
#include "JSystem/JAudio2/JASAiCtrl.h"
#include "dol2asm.h"

//
// Types:
//

/* JASMemPool_MultiThreaded<JASChannel> */
struct JASMemPool_MultiThreaded__template2 {
    /* 802978DC */ void func_802978DC(void* _this);
};

//
// Forward References:
//

extern "C" void initSystem__13JASAramStreamFUlUl();
extern "C" void __ct__13JASAramStreamFv();
extern "C" void init__13JASAramStreamFUlUlPFUlP13JASAramStreamPv_vPv();
extern "C" void prepare__13JASAramStreamFli();
extern "C" void start__13JASAramStreamFv();
extern "C" void stop__13JASAramStreamFUs();
extern "C" void pause__13JASAramStreamFb();
extern "C" void cancel__13JASAramStreamFv();
extern "C" void getBlockSamples__13JASAramStreamCFv();
extern "C" void headerLoadTask__13JASAramStreamFPv();
extern "C" void firstLoadTask__13JASAramStreamFPv();
extern "C" void loadToAramTask__13JASAramStreamFPv();
extern "C" void finishTask__13JASAramStreamFPv();
extern "C" void prepareFinishTask__13JASAramStreamFPv();
extern "C" void headerLoad__13JASAramStreamFUli();
extern "C" void load__13JASAramStreamFv();
extern "C" void channelProcCallback__13JASAramStreamFPv();
extern "C" void dvdErrorCheck__13JASAramStreamFPv();
extern "C" void channelCallback__13JASAramStreamFUlP10JASChannelPQ26JASDsp8TChannelPv();
extern "C" void updateChannel__13JASAramStreamFUlP10JASChannelPQ26JASDsp8TChannel();
extern "C" void channelProc__13JASAramStreamFv();
extern "C" void channelStart__13JASAramStreamFv();
extern "C" void channelStop__13JASAramStreamFUs();
extern "C" void func_802978DC(void* _this);
extern "C" u8 sLoadThread__13JASAramStream[4];
extern "C" u8 sReadBuffer__13JASAramStream[4];
extern "C" u8 sBlockSize__13JASAramStream[4];
extern "C" u8 sChannelMax__13JASAramStream[4];

//
// External References:
//

extern "C" void sendCmdMsg__13JASTaskThreadFPFPv_vPCvUl();
extern "C" void sendCmdMsg__13JASTaskThreadFPFPv_vPv();
extern "C" void getThreadPointer__6JASDvdFv();
extern "C" void __ct__17JASGenericMemPoolFv();
extern "C" void __dt__17JASGenericMemPoolFv();
extern "C" void alloc__17JASGenericMemPoolFUl();
extern "C" void __ct__10JASChannelFPFUlP10JASChannelPQ26JASDsp8TChannelPv_vPv();
extern "C" void playForce__10JASChannelFv();
extern "C" void release__10JASChannelFUs();
extern "C" void setOscInit__10JASChannelFUlPCQ213JASOscillator4Data();
extern "C" void setMixConfig__10JASChannelFUlUs();
extern "C" void getDacRate__9JASDriverFv();
extern "C" void rejectCallback__9JASDriverFPFPv_lPv();
extern "C" void registerSubFrameCallback__9JASDriverFPFPv_lPv();
extern "C" void* __nwa__FUlP7JKRHeapi();
extern "C" void __dl__FPv();
extern "C" void mainRamToAram__7JKRAramFPUcUlUl15JKRExpandSwitchUlP7JKRHeapiPUl();
extern "C" void __register_global_object();
extern "C" void _savegpr_19();
extern "C" void _savegpr_25();
extern "C" void _savegpr_26();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_19();
extern "C" void _restgpr_25();
extern "C" void _restgpr_26();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();

//
// Declarations:
//

/* ############################################################################################## */
/* 80451250-80451254 000750 0004+00 6/6 0/0 0/0 .sbss            sLoadThread__13JASAramStream */
JASTaskThread* JASAramStream::sLoadThread;

/* 80451254-80451258 000754 0004+00 3/3 0/0 0/0 .sbss            sReadBuffer__13JASAramStream */
u8* JASAramStream::sReadBuffer;

/* 80451258-8045125C 000758 0004+00 6/6 1/1 0/0 .sbss            sBlockSize__13JASAramStream */
u32 JASAramStream::sBlockSize;

/* 8045125C-80451260 00075C 0004+00 1/1 0/0 0/0 .sbss            sChannelMax__13JASAramStream */
u32 JASAramStream::sChannelMax;

/* 80451260-80451268 -00001 0008+00 8/8 4/4 0/0 .sbss            None */
/* 80451260 0001+00 data_80451260 None */
/* 80451261 0001+00 data_80451261 None */
/* 80451262 0006+00 data_80451262 None */
extern bool struct_80451260;
extern bool struct_80451261;
extern u32 struct_80451264;
bool struct_80451260;
bool struct_80451261;
u32 struct_80451264;

/* 8029631C-802963A8 290C5C 008C+00 0/0 1/1 0/0 .text            initSystem__13JASAramStreamFUlUl */
void JASAramStream::initSystem(u32 i_blockSize, u32 i_channelMax) {
    if (JASDriver::registerSubFrameCallback(dvdErrorCheck, NULL)) {
        if (sLoadThread == NULL) {
            sLoadThread = JASDvd::getThreadPointer();
        }
        sReadBuffer = new (JASDram, 0x20) u8[(i_blockSize + 0x20) * i_channelMax];
        sBlockSize = i_blockSize;
        sChannelMax = i_channelMax;
        struct_80451260 = false;
        struct_80451261 = false;
    }
}

/* ############################################################################################## */
/* 80455610-80455614 003C10 0004+00 3/3 0/0 0/0 .sdata2          @390 */
SECTION_SDATA2 static u8 lit_390[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80455614-80455618 003C14 0004+00 2/2 0/0 0/0 .sdata2          @391 */
SECTION_SDATA2 static f32 lit_391 = 1.0f;

/* 80455618-8045561C 003C18 0004+00 2/2 0/0 0/0 .sdata2          @392 */
SECTION_SDATA2 static f32 lit_392 = 0.5f;

/* 802963A8-8029649C 290CE8 00F4+00 0/0 1/1 0/0 .text            __ct__13JASAramStreamFv */
#ifdef NONMATCHING
JASAramStream::JASAramStream() {
    field_0x0a8 = NULL;
    field_0x0ac = false;
    field_0x0ad = false;
    field_0x0ae = 0;
    field_0x0b0 = 0;
    field_0x0b4 = 0;
    field_0x0b8 = 0;
    field_0x0bc = 0;
    field_0x0c0 = false;
    field_0x0c4 = 0;
    field_0x0c8 = 0.0f;
    field_0x108 = 0;
    field_0x10c = 0;
    mBlock = 0;
    field_0x114 = 0;
    field_0x118 = 0;
    field_0x12c = 0;
    field_0x148 = 0;
    field_0x14c = 0;
    mCallback = NULL;
    mCallbackData = NULL;
    field_0x158 = 0;
    mChannelNum = 0;
    mBufCount = 0;
    field_0x160 = 0;
    field_0x164 = 0;
    mLoop = false;
    mLoopStart = 0;
    mLoopEnd = 0;
    mVolume = 1.0f;
    mPitch = 1.0f;
    for (int i = 0; i < 6; i++) {
        mChannels[i] = NULL;
        field_0x130[i] = 0;
        field_0x13c[i] = 0;
        mChannelVolume[i] = 1.0f;
        mChannelPan[i] = 0.5f;
        mChannelFxMix[i] = 0.0f;
        mChannelDolby[i] = 0.0f;
    }
    for (int i = 0; i < 6; i++) {
        field_0x1dc[i] = 0;
    }
}
#else
JASAramStream::JASAramStream() {
    // NONMATCHING
}
#endif

/* 8029649C-8029655C 290DDC 00C0+00 0/0 1/1 0/0 .text
 * init__13JASAramStreamFUlUlPFUlP13JASAramStreamPv_vPv         */
#ifdef NONMATCHING
void JASAramStream::init(u32 param_0, u32 param_1, StreamCallback i_callback, void* i_callbackData) {
    field_0x148 = param_0;
    field_0x14c = param_1;
    field_0x0c8 = 0.0f;
    field_0x0ae = 0;
    field_0x0ac = false;
    field_0x0ad = false;
    field_0x114 = 0;
    mChannelNum = 0;
    for (int i = 0; i < 6; i++) {
        mChannelVolume[i] = 1.0f;
        mChannelPan[i] = 0.5f;
        mChannelFxMix[i] = 0.0f;
        mChannelDolby[i] = 0.0f;
    }
    mVolume = 1.0f;
    mPitch = 1.0f;
    field_0x1dc[0] = 0xffff;
    mCallback = i_callback;
    mCallbackData = i_callbackData;
    OSInitMessageQueue(&field_0x000, field_0x040, 0x10);
    OSInitMessageQueue(&field_0x020, field_0x080, 4);
}
#else
void JASAramStream::init(u32 param_0, u32 param_1, StreamCallback i_callback, void* param_3) {
    // NONMATCHING
}
#endif

/* 8029655C-80296618 290E9C 00BC+00 0/0 1/1 0/0 .text            prepare__13JASAramStreamFli */
bool JASAramStream::prepare(s32 param_0, int param_1) {
    if (!DVDFastOpen(param_0, &mDvdFileInfo)) {
        return false;
    }
    if (!JASDriver::registerSubFrameCallback(channelProcCallback, this)) {
        return false;
    }
    TaskData data;
    data.stream = this;
    data.field_0x4 = field_0x14c;
    data.field_0x8 = param_1;
    if (!sLoadThread->sendCmdMsg(headerLoadTask, &data, 0xc)) {
        JASDriver::rejectCallback(channelProcCallback, this);
        return false;
    }
    return true;
}

/* 80296618-8029664C 290F58 0034+00 0/0 1/1 0/0 .text            start__13JASAramStreamFv */
bool JASAramStream::start() {
    return OSSendMessage(&field_0x000, (OSMessage)0, OS_MESSAGE_NOBLOCK);
}

/* 8029664C-80296684 290F8C 0038+00 0/0 1/1 0/0 .text            stop__13JASAramStreamFUs */
bool JASAramStream::stop(u16 param_0) {
    return OSSendMessage(&field_0x000, (OSMessage)(param_0 << 0x10 | 1), OS_MESSAGE_NOBLOCK);
}

/* 80296684-802966CC 290FC4 0048+00 0/0 1/1 0/0 .text            pause__13JASAramStreamFb */
bool JASAramStream::pause(bool param_0) {
    OSMessage msg;
    if (param_0) {
        msg = (OSMessage)2;
    } else {
        msg = (OSMessage)3;
    }
    if (!OSSendMessage(&field_0x000, msg, OS_MESSAGE_NOBLOCK)) {
        return false;
    }
    return true;
}

/* 802966CC-80296710 29100C 0044+00 0/0 1/1 0/0 .text            cancel__13JASAramStreamFv */
bool JASAramStream::cancel() {
    field_0x114 = 1;
    return sLoadThread->sendCmdMsg(finishTask, this);
}

/* 80296710-8029673C 291050 002C+00 4/4 0/0 0/0 .text            getBlockSamples__13JASAramStreamCFv
 */
u32 JASAramStream::getBlockSamples() const {
    if (field_0x158 == 0) {
        return (sBlockSize << 4) / 9;
    }
    return sBlockSize >> 1;
}

/* 8029673C-8029676C 29107C 0030+00 1/1 0/0 0/0 .text            headerLoadTask__13JASAramStreamFPv
 */
void JASAramStream::headerLoadTask(void* i_data) {
    TaskData* data = (TaskData*)i_data;
    data->stream->headerLoad(data->field_0x4, data->field_0x8);
}

/* 8029676C-80296848 2910AC 00DC+00 1/1 0/0 0/0 .text            firstLoadTask__13JASAramStreamFPv
 */
void JASAramStream::firstLoadTask(void* i_data) {
    TaskData* data = (TaskData*)i_data;
    JASAramStream* _this = data->stream;
    if (!_this->load()) {
        return;
    }
    if (data->field_0x8 > 0) {
        data->field_0x8--;
        if (data->field_0x8 == 0) {
            if (!sLoadThread->sendCmdMsg(prepareFinishTask, _this)) {
                struct_80451261 = true;
            }
        }
    }
    if (data->field_0x4 != 0) {
        data->field_0x4--;
        if (!sLoadThread->sendCmdMsg(firstLoadTask, data, 0xc)) {
            struct_80451261 = true;
        }
        JASCriticalSection cs;
        _this->field_0x118++;
    }
}

/* 80296848-80296868 291188 0020+00 1/1 0/0 0/0 .text            loadToAramTask__13JASAramStreamFPv
 */
void JASAramStream::loadToAramTask(void* i_this) {
    ((JASAramStream*)i_this)->load();
}

/* 80296868-802968C8 2911A8 0060+00 2/2 0/0 0/0 .text            finishTask__13JASAramStreamFPv */
void JASAramStream::finishTask(void* i_this) {
    JASAramStream* _this = (JASAramStream*)i_this;
    JASDriver::rejectCallback(channelProcCallback, _this);
    if (_this->mCallback != NULL) {
        _this->mCallback(CB_START, _this, _this->mCallbackData);
        _this->mCallback = NULL;
    }
}

/* 802968C8-80296920 291208 0058+00 1/1 0/0 0/0 .text prepareFinishTask__13JASAramStreamFPv */
void JASAramStream::prepareFinishTask(void* i_this) {
    JASAramStream* _this = (JASAramStream*)i_this;
    OSSendMessage(&_this->field_0x020, (OSMessage)4, OS_MESSAGE_BLOCK);
    if (_this->mCallback != NULL) {
        _this->mCallback(CB_STOP, _this, _this->mCallbackData);
    }
}

/* ############################################################################################## */
/* 8045561C-80455620 003C1C 0004+00 1/1 0/0 0/0 .sdata2          @531 */
SECTION_SDATA2 static f32 lit_531 = 127.0f;

/* 80455620-80455628 003C20 0008+00 3/3 0/0 0/0 .sdata2          @533 */
SECTION_SDATA2 static f64 lit_533 = 4503599627370496.0 /* cast u32 to float */;

/* 80296920-80296AE8 291260 01C8+00 1/1 0/0 0/0 .text            headerLoad__13JASAramStreamFUli */
bool JASAramStream::headerLoad(u32 param_0, int param_1) {
    if (struct_80451261) {
        return false;
    }
    if (field_0x114 != 0) {
        return false;
    }
    if (DVDReadPrio(&mDvdFileInfo, sReadBuffer, sizeof(Header), 0, 1) < 0) {
        struct_80451261 = true;
        return false;
    }
    Header* header = (Header*)sReadBuffer;
    field_0x158 = header->format;
    mChannelNum = header->channels;
    field_0x164 = header->field_0x10;
    mLoop = header->loop != 0;
    mLoopStart = header->loop_start;
    mLoopEnd = header->loop_end;
    mVolume = header->field_0x28 / 127.0f;
    field_0x118 = 0;
    mBlock = 0;
    field_0x10c = 0;
    field_0x160 = (param_0 / sBlockSize) / header->channels;
    mBufCount = field_0x160;
    mBufCount--;
    field_0x108 = mBufCount;
    getBlockSamples();
    if (param_1 < 0 || param_1 > field_0x108) {
        param_1 = field_0x108;
    }
    if (field_0x114 != 0) {
        return false;
    }
    TaskData data;
    data.stream = this;
    data.field_0x4 = field_0x108 - 1;
    data.field_0x8 = param_1;
    if (!sLoadThread->sendCmdMsg(firstLoadTask, &data, 0xc)) {
        struct_80451261 = true;
        return false;
    }
    JASCriticalSection cs;
    field_0x118++;
    return true;
}


/* 80296AE8-80296D74 291428 028C+00 2/2 0/0 0/0 .text            load__13JASAramStreamFv */
#ifdef NONMATCHING
bool JASAramStream::load() {
    {
        JASCriticalSection cs;
        field_0x118--;
    }
    if (struct_80451261) {
        return false;
    }
    if (field_0x114 != 0) {
        return false;
    }
    u32 loop_end_block = (mLoopEnd - 1) / getBlockSamples();
    u32 loop_start_block = mLoopStart / getBlockSamples();
    u32 block = mBlock;
    if (block > loop_end_block) {
        return false;
    }
    u32 size = sBlockSize * mChannelNum + sizeof(BlockHeader);
    u32 offset = block * size + sizeof(Header);
    if (DVDReadPrio(&mDvdFileInfo, sReadBuffer, size, offset, 1) < 0) {
        struct_80451261 = true;
        return false;
    }
    BlockHeader* bhead = (BlockHeader*)sReadBuffer;
    if (field_0x114 != 0) {
        return false;
    }
    u32 uvar2 = field_0x148 + field_0x10c * sBlockSize;
    for (int i = 0; i < mChannelNum; i++) {
        if (!JKRAram::mainRamToAram(sReadBuffer + bhead->field_0x4 * i + 0x20,
                                    uvar2 + i * field_0x160 * sBlockSize,
                                    bhead->field_0x4, EXPAND_SWITCH_UNKNOWN0, 0, NULL, -1, NULL)) {
            struct_80451261 = 1;
            return false;
        }
    }
    field_0x10c++;
    if (field_0x10c >= field_0x108) {
        u32 uvar8 = mBlock - 1 + field_0x108;
        if (mLoop) {
            for (; uvar8 > loop_end_block; uvar8 = uvar8 - loop_end_block + loop_start_block) {}
        }
        if (uvar8 == loop_end_block || uvar8 + 2 == loop_end_block) {
            field_0x108 = field_0x160;
            OSSendMessage(&field_0x020, (OSMessage)5, OS_MESSAGE_BLOCK);
        } else {
            field_0x108 = field_0x160 - 1;
        }
        for (int i = 0; i < mChannelNum; i++) {
            field_0x130[i] = bhead->field_0x8[i].field_0x0;
            field_0x13c[i] = bhead->field_0x8[i].field_0x2;
        }
        field_0x10c = 0;
    }
    mBlock++;
    if (mBlock > loop_end_block && mLoop) {
        mBlock = loop_start_block;
    }
    return true;
}
#else
bool JASAramStream::load() {
    // NONMATCHING
}
#endif

/* 80296D74-80296D94 2916B4 0020+00 2/2 0/0 0/0 .text channelProcCallback__13JASAramStreamFPv */
s32 JASAramStream::channelProcCallback(void* i_this) {
    return ((JASAramStream*)i_this)->channelProc();
}

/* ############################################################################################## */
/* 803C7670-803C76A8 -00001 0034+04 1/1 0/0 0/0 .data            @613 */
SECTION_DATA static void* lit_613[13 + 1 /* padding */] = {
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x34),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x48),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    (void*)(((char*)dvdErrorCheck__13JASAramStreamFPv) + 0x40),
    /* padding */
    NULL,
};

/* 80296D94-80296DF0 2916D4 005C+00 2/1 0/0 0/0 .text            dvdErrorCheck__13JASAramStreamFPv
 */
#ifdef NONMATCHING
s32 JASAramStream::dvdErrorCheck(void* param_0) {
    switch (DVDGetDriveStatus()) {
    case DVD_STATE_END:
        struct_80451260 = false;
        break;
    case DVD_STATE_WAITING:
    case DVD_STATE_COVER_CLOSED:
    case DVD_STATE_NO_DISK:
    case DVD_STATE_COVER_OPEN:
    case DVD_STATE_WRONG_DISK:
    case DVD_STATE_MOTOR_STOPPED:
    case DVD_STATE_IGNORED:
    case 9:
    case DVD_STATE_CANCELED:
    case DVD_STATE_RETRY:
    case DVD_STATE_FATAL_ERROR:
        struct_80451260 = true;
        break;
    }
    return 0;
}
#else
s32 JASAramStream::dvdErrorCheck(void* param_0) {
    // NONMATCHING
}
#endif

/* 80296DF0-80296E2C 291730 003C+00 1/1 0/0 0/0 .text
 * channelCallback__13JASAramStreamFUlP10JASChannelPQ26JASDsp8TChannelPv */
void JASAramStream::channelCallback(u32 i_callbackType, JASChannel* i_channel,
                                    JASDsp::TChannel* i_dspChannel, void* i_this) {
    ((JASAramStream*)i_this)->updateChannel(i_callbackType, i_channel, i_dspChannel);
}

/* 80296E2C-802974AC 29176C 0680+00 1/1 0/0 0/0 .text
 * updateChannel__13JASAramStreamFUlP10JASChannelPQ26JASDsp8TChannel */
#ifdef NONMATCHING
// missing extra loads of field_0x0c4
void JASAramStream::updateChannel(u32 i_callbackType, JASChannel* i_channel,
                                  JASDsp::TChannel* i_dspChannel) {
    u32 block_samples = getBlockSamples();
    switch (i_callbackType) {
    case JASChannel::CB_START:
        if (field_0x0a8 == NULL) {
            field_0x0a8 = i_channel;
            field_0x0b4 = block_samples * mBufCount;
            field_0x0b8 = 0;
            field_0x0b0 = 0;
            field_0x0bc = (mLoopEnd - 1) / block_samples;
            field_0x0c0 = 0;
            field_0x0c4 = 0;
            field_0x12c = 0;
        }
        break;
    case JASChannel::CB_PLAY:
        if (i_dspChannel->field_0x008 == 0) {
            if (i_channel == field_0x0a8) {
                field_0x12c = 0;
                u32 uvar8 = i_dspChannel->field_0x074 + i_dspChannel->field_0x064;
                u32 uvar5 = field_0x0b4;
                if (uvar8 <= uvar5) {
                    field_0x0b8 += uvar5 - uvar8;
                } else {
                    if (!field_0x0c0) {
                        field_0x0b8 += uvar5;
                        field_0x0b8 += block_samples * mBufCount - uvar8;
                    } else {
                        field_0x0b8 += uvar5;
                        field_0x0b8 += block_samples * mBufCount - uvar8
                                       - i_dspChannel->field_0x110;
                        field_0x0b8 -= mLoopEnd;
                        field_0x0b8 += mLoopStart;
                        i_dspChannel->field_0x110 = 0;
                        field_0x120 = 0;
                        field_0x12c |= 2;
                        if (field_0x0c4 < -1) {
                            field_0x0c4++;
                        }
                        field_0x0c0 = false;
                    }
                }
                if (field_0x0b8 > mLoopEnd) {
                    struct_80451261 = true;
                }
                f32 fvar1 = field_0x0c4;
                fvar1 *= mLoopEnd - mLoopStart;
                if (field_0x0c4 < -1) {
                    fvar1 += field_0x0b8;
                }
                fvar1 /= field_0x164;
                field_0x0c8 = fvar1;
                if (field_0x0b8 + 400 >= mLoopEnd && !field_0x0c0) {
                    if (mLoop) {
                        u32 uvar5 = field_0x0bc + 1;
                        if (uvar5 >= mBufCount) {
                            uvar5 = 0;
                        }
                        i_dspChannel->field_0x110 = mLoopStart % block_samples
                                                    + uvar5 * block_samples;
                        field_0x120 = i_dspChannel->field_0x110;
                        field_0x12c |= 2;
                    } else {
                        i_dspChannel->field_0x102 = 0;
                        field_0x128 = 0;
                        field_0x12c |= 8;
                    }
                    i_dspChannel->field_0x074 -= block_samples * mBufCount
                                        - (field_0x0bc * block_samples + mLoopEnd % block_samples);
                    field_0x11c = i_dspChannel->field_0x074;
                    field_0x12c |= 1;
                    field_0x0bc += (mLoopEnd - 1) / block_samples - mLoopStart / block_samples + 1;
                    field_0x0c0 = true;
                }
                u32 uvar4 = i_dspChannel->field_0x070 - i_channel->field_0x104;
                if (uvar4 != 0) {
                    uvar4--;
                }
                uvar5 = uvar4 / sBlockSize;
                getBlockSamples();
                if (uvar5 != field_0x0b0) {
                    bool cmp = uvar5 < field_0x0b0;
                    while (uvar5 != field_0x0b0) {
                        if (!sLoadThread->sendCmdMsg(loadToAramTask, this)) {
                            struct_80451261 = true;
                            break;
                        }
                        {
                            JASCriticalSection cs;
                            field_0x118++;
                        }
                        field_0x0b0++;
                        if (field_0x0b0 >= mBufCount) {
                            field_0x0b0 = 0;
                        }
                    }
                    if (cmp) {
                        field_0x0bc -= mBufCount;
                        if (field_0x0ad) {
                            if (!field_0x0c0) {
                                i_dspChannel->field_0x074 += block_samples;
                                field_0x11c = i_dspChannel->field_0x074;
                                field_0x12c |= 1;
                            }
                            i_dspChannel->field_0x114 += block_samples;
                            field_0x124 = i_dspChannel->field_0x114;
                            field_0x12c |= 4;
                            mBufCount = field_0x160;
                            field_0x0ad = false;
                        } else {
                            if (mBufCount != field_0x160 - 1) {
                                mBufCount = field_0x160 - 1;
                                i_dspChannel->field_0x114 -= block_samples;
                                field_0x124 = i_dspChannel->field_0x114;
                                field_0x12c |= 4;
                                if (!field_0x0c0) {
                                    i_dspChannel->field_0x074 -= block_samples;
                                    field_0x11c = i_dspChannel->field_0x074;
                                    field_0x12c |= 1;
                                }
                            }
                        }
                    }
                } else {
                    if (field_0x118 == 0 && !struct_80451260) {
                        field_0x0ae &= ~2;
                        field_0x0ae &= ~4;
                    }
                }
                field_0x0b4 = i_dspChannel->field_0x074 + i_dspChannel->field_0x064;
                if (field_0x118 >= field_0x160 - 2) {
                    field_0x0ae |= 4;
                }
            } else {
                if (field_0x12c & 1) {
                    i_dspChannel->field_0x074 = field_0x11c;
                }
                if (field_0x12c & 2) {
                    i_dspChannel->field_0x110 = field_0x120;
                }
                if (field_0x12c & 4) {
                    i_dspChannel->field_0x114 = field_0x124;
                }
                if (field_0x12c & 8) {
                    i_dspChannel->field_0x102 = field_0x128;
                }
            }
            int i = 0;
            for (; i < 6; i++) {
                if (i_channel == mChannels[i]) {
                    break;
                }
            }
            i_dspChannel->field_0x104 = field_0x130[i];
            i_dspChannel->field_0x106 = field_0x13c[i];
        }
        break;
    case JASChannel::CB_STOP:
        bool open_channel = false;
        for (int i = 0; i < 6; i++) {
            if (i_channel == mChannels[i]) {
                mChannels[i] = NULL;
            } else if (mChannels[i] != NULL) {
                open_channel = true;
            }
        }
        if (!open_channel) {
            field_0x114 = 1;
            if (!sLoadThread->sendCmdMsg(finishTask, this)) {
                struct_80451261 = true;
                return;
            }
        }
        break;
    }
    i_channel->mPauseFlag = field_0x0ae != 0;
}
#else
void JASAramStream::updateChannel(u32 param_0, JASChannel* param_1, JASDsp::TChannel* param_2) {
    // NONMATCHING
}
#endif

/* 802974AC-80297658 291DEC 01AC+00 1/1 0/0 0/0 .text            channelProc__13JASAramStreamFv */
#ifdef NONMATCHING
// regalloc and instruction ordering
s32 JASAramStream::channelProc() {
    OSMessage msg;
    while (OSReceiveMessage(&field_0x020, &msg, OS_MESSAGE_NOBLOCK)) {
        switch ((u32)msg) {
        case 4:
            field_0x0ac = true;
            break;
        case 5:
            field_0x0ad = true;
            break;
        }
    }
    
    if (!field_0x0ac) {
        return 0;
    }

    while (OSReceiveMessage(&field_0x000, &msg, OS_MESSAGE_NOBLOCK)) {
        switch ((u32)msg & 0xff) {
        case 0:
            channelStart();
            break;
        case 1:
            channelStop((u32)msg >> 0x10);
            break;
        case 2:
            field_0x0ae |= 1;
            break;
        case 3:
            field_0x0ae &= ~1;
            break;
        }
    }

    if (struct_80451261) {
        field_0x0ae |= 8;
    }
    if (struct_80451260) {
        field_0x0ae |= 2;
    }

    for (int i = 0; i < mChannelNum; i++) {
        JASChannel* channel = mChannels[i];
        if (channel != NULL) {
            JASChannelParams params;
            params.mVolume = mVolume * mChannelVolume[i];
            params.mPitch = mPitch;
            params.field_0x8 = 0.0f;
            params.mPan = mChannelPan[i];
            params.mFxMix = mChannelFxMix[i];
            params.mDolby = mChannelDolby[i];
            channel->setParams(params);
        }
    }
    
    return 0;
}
#else
s32 JASAramStream::channelProc() {
    // NONMATCHING
}
#endif

/* ############################################################################################## */
/* 8039B168-8039B174 0277C8 000C+00 1/0 0/0 0/0 .rodata          OSC_RELEASE_TABLE */
static JASOscillator::Point const OSC_RELEASE_TABLE[2] = {
    {0x0000, 0x0002, 0x0000},
    {0x000F, 0x0000, 0x0000},
};

/* 8039B174-8039B190 -00001 0018+04 1/1 0/0 0/0 .rodata          OSC_ENV */
static JASOscillator::Data const OSC_ENV = {0, 1.0f, NULL, OSC_RELEASE_TABLE, 1.0f, 0.0f};

/* 80431B28-80431B34 05E848 000C+00 1/1 0/0 0/0 .bss             @792 */
static u8 lit_792[12];

/* 80431B34-80431B48 05E854 0010+04 1/1 4/4 0/0 .bss
 * memPool_$localstatic3$getMemPool___46JASPoolAllocObject_MultiThreaded<10JASChannel>Fv */
extern u8 data_80431B34[16 + 4 /* padding */];
u8 data_80431B34[16 + 4 /* padding */];

/* 80455628-80455630 003C28 0004+04 1/1 0/0 0/0 .sdata2          one$776 */
SECTION_SDATA2 static u32 one = 1;

/* 80297658-80297870 291F98 0218+00 1/1 0/0 0/0 .text            channelStart__13JASAramStreamFv */
void JASAramStream::channelStart() {
    u8 r31;
    switch (field_0x158) {
    case 0:
        r31 = 0;
        break;
    case 1:
        r31 = 3;
        break;
    }
    for (int i = 0; i < mChannelNum; i++) {
        JASWaveInfo wave_info;
        wave_info.field_0x00 = r31;
        wave_info.field_0x02 = 0xff;
        wave_info.field_0x10 = 0;
        wave_info.field_0x14 = mBufCount * getBlockSamples();
        wave_info.field_0x18 = wave_info.field_0x14;
        wave_info.field_0x1c = 0;
        wave_info.field_0x1e = 0;
        // probably a fake match, this should be set in the JASWaveInfo constructor
        wave_info.field_0x20 = &one;
        JASChannel* channel = new JASChannel(channelCallback, this);
        channel->setPriority(0x7f7f);
        for (u32 j = 0; j < 6; j++) {
            channel->setMixConfig(j, field_0x1dc[j]);
        }
        channel->setInitPitch(field_0x164 / JASDriver::getDacRate());
        channel->setOscInit(0, &OSC_ENV);
        channel->field_0xdc.field_0x4 = wave_info;
        channel->field_0x104 = field_0x148 + sBlockSize * field_0x160 * i;
        channel->field_0xdc.field_0x0 = 0;
        channel->playForce();
        mChannels[i] = channel;
    }
    field_0x0a8 = NULL;
}


/* 80297870-802978DC 2921B0 006C+00 1/1 0/0 0/0 .text            channelStop__13JASAramStreamFUs */
void JASAramStream::channelStop(u16 i_directRelease) {
    for (int i = 0; i < mChannelNum; i++) {
        if (mChannels[i] != NULL) {
            mChannels[i]->release(i_directRelease);
        }
    }
}

/* 802978DC-80297930 29221C 0054+00 1/1 5/5 0/0 .text
 * __dt__38JASMemPool_MultiThreaded<10JASChannel>Fv             */
extern "C" void func_802978DC(void* _this) {
    // NONMATCHING
}