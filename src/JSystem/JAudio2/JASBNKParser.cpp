//
// Generated By: dol2asm
// Translation Unit: JASBNKParser
//

#include "JSystem/JAudio2/JASBNKParser.h"
#include "JSystem/JAudio2/JASBasicBank.h"
#include "JSystem/JAudio2/JASCalc.h"
#include "JSystem/JAudio2/JASDrumSet.h"
#include "JSystem/JAudio2/JASHeapCtrl.h"
#include "JSystem/JKernel/JKRSolidHeap.h"
#include "JSystem/JSupport/JSupport.h"

/* 80299538-80299558 293E78 0020+00 0/0 1/1 0/0 .text createBank__12JASBNKParserFPCvP7JKRHeap */
JASBank* JASBNKParser::createBank(void const* stream, JKRHeap* heap) {
    return createBasicBank(stream, heap);
}

/* 80451288-8045128C 000788 0004+00 1/1 0/0 0/0 .sbss            sUsedHeapSize__12JASBNKParser */
u32 JASBNKParser::sUsedHeapSize;

/* 80299558-80299600 293E98 00A8+00 1/1 0/0 0/0 .text createBasicBank__12JASBNKParserFPCvP7JKRHeap
 */
JASBasicBank* JASBNKParser::createBasicBank(void const* stream, JKRHeap* heap) {
    if (heap == NULL) {
        heap = JASDram;
    }

    u32 free_size = heap->getFreeSize();
    JASBasicBank* bank = NULL;

    TFileHeader* header = (TFileHeader*)stream;
    switch (header->mVersion) {
    case 0:
        bank = Ver0::createBasicBank(stream, heap);
        break;
    case 1:
        bank = Ver1::createBasicBank(stream, heap);
        break;
    }

    sUsedHeapSize += free_size - heap->getFreeSize();
    return bank;
}

/* 80299600-8029963C 293F40 003C+00 1/1 0/0 0/0 .text findChunk__Q212JASBNKParser4Ver1FPCvUl */
JASBNKParser::Ver1::TChunk* JASBNKParser::Ver1::findChunk(void const* stream, u32 id) {
    TFileHeader* header = (TFileHeader*)stream;
    void* end = (void*)((int)stream + header->mSize);
    TChunk* chunk = (TChunk*)((int)stream + 0x20);
    while (chunk < end) {
        if (chunk->mID == id) {
            return chunk;
        }
        chunk = (TChunk*)(((int)chunk + 0xb + chunk->mSize) & ~3);
    }
    return NULL;
}

/* 8029963C-80299A3C 293F7C 0400+00 1/1 0/0 0/0 .text
 * createBasicBank__Q212JASBNKParser4Ver1FPCvP7JKRHeap          */
// NONMATCHING instruction ordering, regalloc
JASBasicBank* JASBNKParser::Ver1::createBasicBank(void const* stream, JKRHeap* heap) {
    if (heap == NULL) {
        heap = JASDram;
    }

    JASBasicBank* bank = new (heap, 0) JASBasicBank();
    if (bank == NULL) {
        return NULL;
    }

    TEnvtChunk* envt_chunk = (TEnvtChunk*)findChunk(stream, 'ENVT');
    TOscChunk* osc_chunk = (TOscChunk*)findChunk(stream, 'OSCT');
    TListChunk* list_chunk = (TListChunk*)findChunk(stream, 'LIST');

    void* envt = new (heap, 2) u8[envt_chunk->mSize];
    JASCalc::bcopy(envt_chunk->mData, envt, envt_chunk->mSize);

    u32 count = osc_chunk->mCount;
    TOsc* osc = osc_chunk->mOsc;
    JASOscillator::Data* osc_data = new (heap, 0) JASOscillator::Data[count];
    for (int i = 0; i < count; i++, osc++) {
        JASOscillator::Data* data = &osc_data[i];
        data->mTarget = osc->mTarget;
        data->_04 = osc->_08;
        data->mScale = osc->mScale;
        data->_14 = osc->_18;
        data->mTable = (JASOscillator::Point*)((int)envt + osc->mTableOffset);
        data->_0C = (JASOscillator::Point*)((int)envt + osc->_10);
    }

    bank->newInstTable(list_chunk->mCount, heap);
    for (int i = 0; i < list_chunk->mCount; i++) {
        if (list_chunk->mOffsets[i] != 0) {
            u32* ptr = (u32*)((int)stream + list_chunk->mOffsets[i]);
            u32* data = ptr + 1;
            switch (*ptr) {
            case 'Inst': {
                JASBasicInst* inst = new (heap, 0) JASBasicInst();
                u32 count = *data;
                data++;
                for (int j = 0; j < count; j++) {
                    u32 index = *data;
                    data++;
                    inst->setOsc(j, &osc_data[index]);
                }
                count = *data;
                data++;
                for (int j = 0; j < count; j++) {
                    data++;
                }
                count = *data;
                data++;
                inst->setKeyRegionCount(count, heap);
                for (int j = 0; j < count; j++) {
                    JASBasicInst::TKeymap* keymap = inst->getKeyRegion(j);
                    keymap->setHighKey(*data >> 0x18);
                    u32 fVar4 = data[1];
                    keymap->field_0x4 = JSULoHalf(data[3]);
                    keymap->field_0x8 = *(f32*)&data[4];
                    keymap->field_0xc = *(f32*)&data[5];
                    data += 2;
                    for (int k = 0; k < fVar4; k++) {
                        data += 4;
                    }
                }
                inst->setVolume(*(f32*)&data[0]);
                inst->setPitch(*(f32*)&data[1]);
                bank->setInst(i, inst);
                break;
            }

            case 'Perc': {
                JASDrumSet* drum = new (heap, 0) JASDrumSet();
                u32 count = *data;
                data++;
                drum->newPercArray(count, heap);
                for (int j = 0; j < count; j++) {
                    u32 offset = *data;
                    data++;
                    if (offset != 0) {
                        JASDrumSet::TPerc* perc = new (heap, 0) JASDrumSet::TPerc();
                        u32* ptr = (u32*)((int)stream + offset);
                        TPercData* perc_data = (TPercData*)(ptr + 1);
                        perc->setVolume(perc_data->mVolume);
                        perc->setPitch(perc_data->mPitch);
                        perc->setPan((f32)perc_data->mPan / 127.0f);
                        perc->setRelease(perc_data->mRelease);
                        ptr = (u32*)&perc_data->field_0xc;
                        u32 count2 = *ptr;
                        ptr++;
                        for (int k = 0; k < count2; k++) {
                            ptr++;
                        }
                        u32 pVar6 = ptr[0];
                        perc->field_0xe = JSULoHalf(ptr[2]);
                        perc->field_0x10 = *(f32*)&ptr[3];
                        perc->field_0x14 = *(f32*)&ptr[4];
                        for (int k = 0; k < pVar6; k++) {}
                        drum->setPerc(j, perc);
                    }
                }
                bank->setInst(i, drum);
                break;
            }
            }
        }
    }

    return bank;
}

/* 80299A3C-80299E68 29437C 042C+00 1/1 0/0 0/0 .text
 * createBasicBank__Q212JASBNKParser4Ver0FPCvP7JKRHeap          */
JASBasicBank* JASBNKParser::Ver0::createBasicBank(void const* stream, JKRHeap* heap) {
    // NONMATCHING
}

/* 80299E68-80299F8C 2947A8 0124+00 1/1 0/0 0/0 .text
 * findOscPtr__Q212JASBNKParser4Ver0FP12JASBasicBankPCQ312JASBNKParser4Ver07THeaderPCQ312JASBNKParser4Ver04TOsc
 */
void JASBNKParser::Ver0::findOscPtr(JASBasicBank* param_0, THeader const* param_1,
                                    TOsc const* param_2) {
    // NONMATCHING
}

/* 80299F8C-80299FA0 2948CC 0014+00 1/1 0/0 0/0 .text
 * getOscTableEndPtr__Q212JASBNKParser4Ver0FPCQ213JASOscillator5Point */
void JASBNKParser::Ver0::getOscTableEndPtr(JASOscillator::Point const* param_0) {
    // NONMATCHING
}
