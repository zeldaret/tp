//
// Generated By: dol2asm
// Translation Unit: m_Do/m_Do_main
//

#include "m_Do/m_Do_main.h"
#include "dol2asm.h"
#include "dolphin/types.h"
#include "msl_c/string.h"
#include "JSystem/JUtility/JUTReport.h"
#include "m_Do/m_Do_controller_pad.h"

//
// Types:
//

struct mDoRst {
    static u8 mResetData[4 + 4 /* padding */];
};

struct mDoMemCd_Ctrl_c {
    /* 80016894 */ void update();
};

struct mDoDvdThd_callback_c {
    /* 80015C74 */ void create(void* (*)(void*), void*);
};

struct dRes_control_c {
    /* 8003C638 */ void dump();
};

struct dComIfG_inf_c {
    /* 8002CBE4 */ void ct();
};

struct JUTConsole {
    /* 802E75EC */ void clear();
    /* 802E7F7C */ void dumpToTerminal(unsigned int);
    /* 802E80A8 */ void scroll(int);
    /* 802E81A8 */ void getLineOffset() const;
};

struct JUTAssertion {
    /* 802E4C3C */ void setMessageCount(int);
};

struct JKRSolidHeap {
    /* 802D0A24 */ void create(u32, JKRHeap*, bool);
};

struct JKRAramHeap {
    /* 802D3134 */ void getFreeSize();
    /* 802D31AC */ void getTotalFreeSize();
    /* 802D3218 */ void dump();
};

struct JKRAram {
    static u8 sAramObject[4];
};

struct JFWSystem {
    static u8 systemConsole[4];
};

struct DynamicModuleControlBase {
    /* 80262470 */ void dump();
};

//
// Forward References:
//

extern "C" static void version_check__Fv();
extern "C" void CheckHeap1__9HeapCheckFv();
extern "C" static void CheckHeap__FUl();
extern "C" static void countUsed__FP10JKRExpHeap();
extern "C" void getUsedCount__9HeapCheckCFv();
extern "C" void heapDisplay__9HeapCheckCFv();
extern "C" static void debugDisplay__Fv();
extern "C" static void Debug_console__FUl();
extern "C" static void LOAD_COPYDATE__FPv();
extern "C" static void debug__Fv();
extern "C" static void main01__Fv();
extern "C" void main();
extern "C" bool dump_sort__7JKRHeapFv();
extern "C" void __sinit_m_Do_main_cpp();
extern "C" extern char const* const m_Do_m_Do_main__stringBase0;
extern "C" u8 COPYDATE_STRING__7mDoMain[18 + 2 /* padding */];
extern "C" u32 memMargin__7mDoMain;
extern "C" u8 sPowerOnTime__7mDoMain[4];
extern "C" u8 sHungUpTime__7mDoMain[4];
extern "C" extern u8 data_80450B38[4];
extern "C" extern u8 data_80450B3C[4];
extern "C" extern u8 data_80450B40[4];
extern "C" extern u8 data_80450B44[4];
extern "C" extern u8 data_80450B48[4];
extern "C" extern u8 data_80450B4C[4];
extern "C" extern u8 data_80450B50[4];
extern "C" extern u8 data_80450B54[4];
extern "C" extern u8 data_80450B58[4];
extern "C" extern u8 data_80450B5C[4];
extern "C" extern u8 data_80450B60[4];
extern "C" extern u8 data_80450B64[4];
extern "C" extern u8 data_80450B68[4];
extern "C" extern u8 data_80450B6C[4];
extern "C" extern u8 data_80450B70[4];
extern "C" extern u8 data_80450B74[4];
extern "C" extern u8 data_80450B78[4];
extern "C" extern u8 data_80450B7C[4];
extern "C" extern u8 data_80450B80[4];
extern "C" extern u8 data_80450B84[4];
extern "C" extern u8 data_80450B88[4];
extern "C" extern u8 data_80450B8C[4];
extern "C" extern u8 data_80450B90[4 + 4 /* padding */];
extern "C" extern u8 struct_80450B98[4];
extern "C" extern u8 data_80450B9C[4];

//
// External References:
//

extern "C" void OSReportInit__Fv();
extern "C" void mDoAud_Execute__Fv();
extern "C" void create__8mDoCPd_cFv();
extern "C" void read__8mDoCPd_cFv();
extern "C" void mDoGph_Create__Fv();
extern "C" void mDoMch_HeapCheckAll__Fv();
extern "C" void mDoMch_Create__Fv();
extern "C" void mDoExt_getGameHeap__Fv();
extern "C" void mDoExt_getZeldaHeap__Fv();
extern "C" void mDoExt_getCommandHeap__Fv();
extern "C" void mDoExt_getArchiveHeap__Fv();
extern "C" void mDoExt_getJ2dHeap__Fv();
extern "C" void mDoExt_getHostIOHeap__Fv();
extern "C" void create__20mDoDvdThd_callback_cFPFPv_PvPv();
extern "C" void update__15mDoMemCd_Ctrl_cFv();
extern "C" void cDyl_InitAsync__Fv();
extern "C" void fapGm_Execute__Fv();
extern "C" void fapGm_Create__Fv();
extern "C" void fopAcM_initManager__Fv();
extern "C" void ct__13dComIfG_inf_cFv();
extern "C" void dump__14dRes_control_cFv();
extern "C" void dump__24DynamicModuleControlBaseFv();
extern "C" void getFreeSize__7JKRHeapFv();
extern "C" void getTotalFreeSize__7JKRHeapFv();
extern "C" void getTotalUsedSize__10JKRExpHeapCFv();
extern "C" void create__12JKRSolidHeapFUlP7JKRHeapb();
extern "C" void getFreeSize__11JKRAramHeapFv();
extern "C" void getTotalFreeSize__11JKRAramHeapFv();
extern "C" void dump__11JKRAramHeapFv();
extern "C" void JUTReport__FiiPCce();
extern "C" void JUTReport__FiiiPCce();
extern "C" void setMessageCount__12JUTAssertionFi();
extern "C" void clear__10JUTConsoleFv();
extern "C" void dumpToTerminal__10JUTConsoleFUi();
extern "C" void scroll__10JUTConsoleFi();
extern "C" void getLineOffset__10JUTConsoleCFv();
extern "C" void _savegpr_23();
extern "C" void _savegpr_26();
extern "C" void _savegpr_27();
extern "C" void _savegpr_28();
extern "C" void _restgpr_23();
extern "C" void _restgpr_26();
extern "C" void _restgpr_27();
extern "C" void _restgpr_28();
extern "C" u8 m_gamePad__8mDoCPd_c[16];
extern "C" u8 m_cpadInfo__8mDoCPd_c[256];
extern "C" extern u8 g_mDoMemCd_control[8192];
extern "C" extern u8 g_HIO[64 + 4 /* padding */];
extern "C" extern u8 g_dComIfG_gameInfo[122384];
extern "C" extern u8 g_mDoAud_audioHeap[4];
extern "C" extern u8 gameHeap[4];
extern "C" extern u8 zeldaHeap[4];
extern "C" extern u8 archiveHeap[4];
extern "C" u8 mResetData__6mDoRst[4 + 4 /* padding */];
extern "C" extern u8 struct_80450C80[8];
extern "C" u8 systemConsole__9JFWSystem[4];
extern "C" u8 sSystemHeap__7JKRHeap[4];
extern "C" u8 sCurrentHeap__7JKRHeap[4];
extern "C" u8 sRootHeap__7JKRHeap[4];
extern "C" u8 sAramObject__7JKRAram[4];

//
// Declarations:
//

static void version_check() {
    if ((!strcmp("20Apr2004", "20Apr2004")) && (!strcmp("Patch2", "Patch2"))) {
        return;
    }

    // "SDK version doesn't match. Stopping\n"
    OSReport_Error("SDKのバージョンが一致しません。停止します\n");
    do {
    } while (true);
}

void HeapCheck::CheckHeap1() {
    s32 totalUsedSize = mHeap->getTotalUsedSize();
    s32 freeSize = mHeap->getFreeSize();

    if (mMaxTotalUsedSize < totalUsedSize) {
        mMaxTotalUsedSize = totalUsedSize;
    }

    if (mMaxTotalFreeSize > freeSize) {
        mMaxTotalFreeSize = freeSize;
    }
}

/* ############################################################################################## */
/* 803D32E0-803D3308 000000 0028+00 3/2 0/0 0/0 .bss             RootHeapCheck */
extern "C" HeapCheck RootHeapCheck;

/* 803D3308-803D3330 000028 0028+00 1/2 0/0 0/0 .bss             SystemHeapCheck */
extern "C" HeapCheck SystemHeapCheck;

/* 803D3330-803D3358 000050 0028+00 1/2 0/0 0/0 .bss             ZeldaHeapCheck */
extern "C" HeapCheck ZeldaHeapCheck;

/* 803D3358-803D3380 000078 0028+00 1/2 0/0 0/0 .bss             GameHeapCheck */
extern "C" HeapCheck GameHeapCheck;

/* 803D3380-803D33A8 0000A0 0028+00 1/2 0/0 0/0 .bss             ArchiveHeapCheck */
extern "C" HeapCheck ArchiveHeapCheck;

/* 803D33A8-803D33D0 0000C8 0028+00 1/2 0/0 0/0 .bss             J2dHeapCheck */
extern "C" HeapCheck J2dHeapCheck;

/* 803D33D0-803D33F8 0000F0 0028+00 1/2 0/0 0/0 .bss             HostioHeapCheck */
extern "C" HeapCheck HostioHeapCheck;

/* 803D33F8-803D3420 000118 0028+00 1/2 0/0 0/0 .bss             CommandHeapCheck */
extern "C" HeapCheck CommandHeapCheck;

/* 803A2EE0-803A2EF4 000000 0012+02 2/2 1/1 0/0 .data            COPYDATE_STRING__7mDoMain */
// "??/??/?? ??:??:?"
SECTION_DATA u8 mDoMain::COPYDATE_STRING[18 + 2 /* padding */] = {
    0x3F,
    0x3F,
    0x2F,
    0x3F,
    0x3F,
    0x2F,
    0x3F,
    0x3F,
    0x20,
    0x3F,
    0x3F,
    0x3A,
    0x3F,
    0x3F,
    0x3A,
    0x3F,
    0x3F,
    0x00,
    /* padding */
    0x00,
    0x00,
};

/* 803A2EF4-803A2F14 -00001 0020+00 1/2 0/0 0/0 .data            HeapCheckTable */
SECTION_DATA static HeapCheck* HeapCheckTable[8] = {
    &RootHeapCheck,   &SystemHeapCheck,  &ZeldaHeapCheck,
    &GameHeapCheck,   &ArchiveHeapCheck, &J2dHeapCheck,
    &HostioHeapCheck, &CommandHeapCheck,
};

/* 803D32E0-803D3308 000000 0028+00 3/2 0/0 0/0 .bss             RootHeapCheck */
static HeapCheck RootHeapCheck;

/* 803D3308-803D3330 000028 0028+00 1/2 0/0 0/0 .bss             SystemHeapCheck */
static HeapCheck SystemHeapCheck;

/* 803D3330-803D3358 000050 0028+00 1/2 0/0 0/0 .bss             ZeldaHeapCheck */
static HeapCheck ZeldaHeapCheck;

/* 803D3358-803D3380 000078 0028+00 1/2 0/0 0/0 .bss             GameHeapCheck */
static HeapCheck GameHeapCheck;

/* 803D3380-803D33A8 0000A0 0028+00 1/2 0/0 0/0 .bss             ArchiveHeapCheck */
static HeapCheck ArchiveHeapCheck;

/* 803D33A8-803D33D0 0000C8 0028+00 1/2 0/0 0/0 .bss             J2dHeapCheck */
static HeapCheck J2dHeapCheck;

/* 803D33D0-803D33F8 0000F0 0028+00 1/2 0/0 0/0 .bss             HostioHeapCheck */
static HeapCheck HostioHeapCheck;

/* 803D33F8-803D3420 000118 0028+00 1/2 0/0 0/0 .bss             CommandHeapCheck */
static HeapCheck CommandHeapCheck;

/* 8000578C-80005848 0000CC 00BC+00 1/1 0/0 0/0 .text            CheckHeap__FUl */
#ifdef NONMATCHING
void CheckHeap(u32 controller_pad_no) {
    mDoMch_HeapCheckAll__Fv();
    OSCheckActiveThreads();

    bool unk = false;

    // if L + R + Z is pressed...
    if (((m_cpadInfo[controller_pad_no].mButtonFlags & ~0x10) == 0x60) &&
        m_cpadInfo[controller_pad_no].mPressedButtonFlags & 0x10) {
        unk = true;
    }

    for (int i = 0; i < 8; i++) {
        HeapCheckTable[i]->CheckHeap1();
        if (unk) {
            HeapCheck* currentHeap = HeapCheckTable[i];
            s32 used_count = currentHeap->getUsedCount();

            currentHeap->getUsedCountRef() = used_count;
            used_count = currentHeap->getHeap()->getTotalUsedSize();
            currentHeap->getTotalUsedSizeRef() = used_count;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void CheckHeap(u32 param_0) {
    nofralloc
#include "asm/m_Do/m_Do_main/CheckHeap__FUl.s"
}
#pragma pop
#endif

static int countUsed(JKRExpHeap* heap) {
    OSDisableScheduler();
    int counter = 0;
    JKRExpHeap::CMemBlock* used_blocks_head = heap->getHeadUsedList();

    while (used_blocks_head) {
        used_blocks_head = used_blocks_head->getNextBlock();
        counter++;
    };

    OSEnableScheduler();
    return counter;
}

s32 HeapCheck::getUsedCount() const {
    return countUsed(mHeap);
}

void HeapCheck::heapDisplay() const {
    s32 heap_size = mHeap->getSize();
    s32 used_count = heap_size - mTargetHeapSize;

    s32 total_used_size = mHeap->getTotalUsedSize();
    s32 total_free_size = mHeap->getTotalFreeSize();
    s32 heap_free_size = mHeap->getFreeSize();

    JUTReport(0x64, 0xd4, "[%sName]", mName);
    JUTReport(0x64, 0xe3, "HeapSize         %8ld", heap_size);
    JUTReport(0x64, 0xf0, "TargetHeapSize   %8ld", mTargetHeapSize);
    JUTReport(0x64, 0xfd, "TotalFree        %8ld", total_free_size - used_count);
    JUTReport(0x64, 0x10a, "FreeSize         %8ld", heap_free_size - used_count);
    JUTReport(0x64, 0x117, "TotalUsedSize    %8ld", total_used_size);
    JUTReport(0x64, 0x124, "TotalUsedRate        %3ld%%",
              (int)(total_used_size * 0x64) / (int)mTargetHeapSize);
    JUTReport(0x64, 0x131, "MaxTotalUsedSize %8ld", mMaxTotalUsedSize);
    JUTReport(0x64, 0x13e, "MaxTotalUsedRate     %3ld%%",
              (mMaxTotalUsedSize * 0x64) / (int)mTargetHeapSize);
    JUTReport(0x64, 0x14b, "MinFreeSize      %8ld", mMaxTotalFreeSize - used_count);
    JUTReport(0x64, 0x158, "MinFreeRate          %3ld%%",
              ((mMaxTotalFreeSize - used_count) * 0x64) / (int)mTargetHeapSize);
    used_count = countUsed(mHeap);
    JUTReport(0x64, 0x165, "UsedCount             %3ld%", used_count);
}


/* ############################################################################################## */
/* 803739A0-803739A0 000000 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80373AEF = "";
SECTION_DEAD static char const* const stringBase_80373AF0 = "TotalFree";
SECTION_DEAD static char const* const stringBase_80373AFA = "MaxUsed  ";
SECTION_DEAD static char const* const stringBase_80373B04 = "Used     ";
SECTION_DEAD static char const* const stringBase_80373B0E = "RelUsed  ";
SECTION_DEAD static char const* const stringBase_80373B18 = "/ MaxFree";
SECTION_DEAD static char const* const stringBase_80373B22 = "/HeapSize";
SECTION_DEAD static char const* const stringBase_80373B2C = "Blk/Bytes";
SECTION_DEAD static char const* const stringBase_80373B36 = "ARAM Free";
SECTION_DEAD static char const* const stringBase_80373B40 = "%d";
SECTION_DEAD static char const* const stringBase_80373B43 = "%s";
SECTION_DEAD static char const* const stringBase_80373B46 = " [%s]";
SECTION_DEAD static char const* const stringBase_80373B4C = "%10d";
#pragma pop

/* 803A2F14-803A2F28 -00001 0014+00 0/1 0/0 0/0 .data            desc1$3717 */
#pragma push
#pragma force_active on
SECTION_DATA static void* desc1[5] = {
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x14F),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x150),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x15A),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x164),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x16E),
};
#pragma pop

/* 803A2F28-803A2F40 -00001 0014+04 0/1 0/0 0/0 .data            desc2$3718 */
#pragma push
#pragma force_active on
SECTION_DATA static void* desc2[5 + 1 /* padding */] = {
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x14F),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x178),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x182),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x18C),
    (void*)(((char*)&m_Do_m_Do_main__stringBase0) + 0x18C),
    /* padding */
    NULL,
};
#pragma pop

/* 80450580-80450584 000000 0004+00 3/3 6/6 0/0 .sdata           None */
SECTION_SDATA extern s8 data_80450580 = 0xFF;

/* 80450584-80450588 000004 0004+00 0/0 1/1 0/0 .sdata           memMargin__7mDoMain */
SECTION_SDATA u32 mDoMain::memMargin = 0xFFFFFFFF;

/* 80450588-80450590 000008 0008+00 2/2 0/0 0/0 .sdata           None */
SECTION_SDATA static u8 data_80450588[8] = {
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

/* 80450B00-80450B08 000000 0008+00 1/1 0/0 0/0 .sbss            None */
static u8 data_80450B00[8];

/* 80450B08-80450B0C 000008 0004+00 1/1 1/1 0/0 .sbss            sPowerOnTime__7mDoMain */
// should be OSTime
u8 mDoMain::sPowerOnTime[4];
extern u8 data_80450B0C[4];
u8 data_80450B0C[4];

/* 80450B10-80450B14 000010 0004+00 0/0 2/2 0/0 .sbss            sHungUpTime__7mDoMain */
// should be OSTime
u8 mDoMain::sHungUpTime[4];
extern u8 data_80450B14[4];
u8 data_80450B14[4];

/* 80450B18-80450B1C -00001 0004+00 3/3 0/0 0/0 .sbss            None */
/* 80450B18 0001+00 data_80450B18 None */
/* 80450B19 0001+00 data_80450B19 None */
/* 80450B1A 0002+00 data_80450B1A None */
static u8 struct_80450B18[2];

static u8 data_80450B1A;
static u8 data_80450B1B;

/* 80005AD8-80005D4C 000418 0274+00 1/1 0/0 0/0 .text            debugDisplay__Fv */
#ifdef NONMATCHING
void debugDisplay(void) {
    int tmp1;
    int tmp2;
    HeapCheck** hct = (HeapCheck**)lbl_803A2EE0;

    if (lbl_80450B19 >= 1 && lbl_80450B19 <= 6) {
        hct[lbl_80450B19 - 1]->heapDisplay();
    }

    if (lbl_80450588 == 5) {
        JKRAramHeap* heap = sAramObject__7JKRAram->getAramHeap();
        if (heap) {
            JUTReport(0x1db, 100, lbl_803739A0 + 0x196);
            JUTReport(0x1db, 0x72, lbl_803739A0 + 0x1A0, heap->getFreeSize());
            JUTReport(0x1db, 0x80, lbl_803739A0 + 0x150);
            JUTReport(0x1db, 0x8e, lbl_803739A0 + 0x1A0, heap->getTotalFreeSize());
        }

    } else {
        if (lbl_80450588) {
            JUTReport(0x1db, 100, lbl_803739A0 + 0x1A3, lbl_803A2F14[lbl_80450588]);
            JUTReport(0x1db, 0x72, lbl_803739A0 + 0x1A3, lbl_803A2F28[lbl_80450588]);

            int k = 0;
            for (int i = 0; i < 8; i++, k += 0x2c) {
                // heap check table stuff
                HeapCheck* heap_check;
                heap_check = HeapCheckTable[i];

                switch (lbl_80450588) {
                case 3: {
                    tmp1 = heap_check->getUsedCount();
                    tmp2 = heap_check->getHeap()->getTotalUsedSize();
                    break;
                }
                case 1: {
                    tmp1 = heap_check->getHeap()->getTotalFreeSize();
                    tmp2 = heap_check->getHeap()->getFreeSize();
                    break;
                }
                case 2: {
                    tmp1 = heap_check->getMaxTotalUsedSize();
                    tmp2 = heap_check->getHeap()->getSize();
                    break;
                }
                case 4: {
                    tmp1 = heap_check->getUsedCount() - heap_check->getUsedCountRef();
                    tmp2 = heap_check->getHeap()->getTotalUsedSize() -
                           heap_check->getTotalUsedSizeRef();
                    break;
                }

                    JUTReport(0x1db, k + 0x96, lbl_80373B46, heap_check->getNames()[0]);
                    JUTReport(0x1db, k + 0xA4, lbl_80373B4C, tmp1);
                    JUTReport(0x1db, k + 0xB2, lbl_80373B4C, tmp2);
                }
            }
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void debugDisplay() {
    nofralloc
#include "asm/m_Do/m_Do_main/debugDisplay__Fv.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 803739A0-803739A0 000000 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80373B51 = "Press X+Y+START to CLEAR console.";
SECTION_DEAD static char const* const stringBase_80373B73 = "3DStick UP/Down to scroll";
SECTION_DEAD static char const* const stringBase_80373B8D =
    "Press A to output terminal from console.";
SECTION_DEAD static char const* const stringBase_80373BB6 = "SCROLL：%3d %3d %3d Output=%1x";
SECTION_DEAD static char const* const stringBase_80373BD5 = "Press L+R trigger to control console.";
SECTION_DEAD static char const* const stringBase_80373BFB =
    "Press [Z] trigger to close this window.";
#pragma pop

/* 80450B1C-80450B20 00001C 0004+00 1/1 0/0 0/0 .sbss            console_position_x$3776 */
static f32 console_position_x;

/* 80450B20-80450B24 000020 0004+00 1/1 0/0 0/0 .sbss            None */
static u8 data_80450B20[4];

/* 80450B24-80450B28 000024 0004+00 1/1 0/0 0/0 .sbss            console_position_y$3779 */
static f32 console_position_y;

/* 80450B28-80450B2C 000028 0004+00 1/1 0/0 0/0 .sbss            None */
static u8 data_80450B28[4];

/* 80450B2C-80450B30 00002C 0004+00 1/1 0/0 0/0 .sbss            console_scroll$3782 */
static f32 console_scroll;

/* 80450B30-80450B34 000030 0004+00 1/1 0/0 0/0 .sbss            None */
static u8 data_80450B30[4];

/* 80451A00-80451A04 000000 0004+00 1/1 0/0 0/0 .sdata2          @3884 */
SECTION_SDATA2 static f32 lit_3884 = 20.0f;

/* 80451A04-80451A08 000004 0004+00 1/1 0/0 0/0 .sdata2          @3885 */
SECTION_SDATA2 static f32 lit_3885 = 30.0f;

/* 80451A08-80451A0C 000008 0004+00 1/1 0/0 0/0 .sdata2          @3886 */
SECTION_SDATA2 static u8 lit_3886[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80451A0C-80451A10 00000C 0004+00 1/1 0/0 0/0 .sdata2          @3887 */
SECTION_SDATA2 static f32 lit_3887 = 1.0f;

/* 80451A10-80451A18 000010 0004+04 1/1 0/0 0/0 .sdata2          @3888 */
SECTION_SDATA2 static f32 lit_3888[1 + 1 /* padding */] = {
    -1.0f,
    /* padding */
    0.0f,
};

/* 80451A18-80451A20 000018 0008+00 1/1 0/0 0/0 .sdata2          @3890 */
SECTION_SDATA2 static f64 lit_3890 = 4503601774854144.0 /* cast s32 to float */;

/* 80005D4C-8000614C 00068C 0400+00 1/1 0/0 0/0 .text            Debug_console__FUl */
#ifdef NONMATCHING
void Debug_console(u32 controller_pad_no) {
    float tmp2;
    float tmp3;
    int tmp6;

    // systemConsole
    if (lbl_804511B8) {
        if (!lbl_80450B20) {
            lbl_80450B1C = lbl_80451A00;
            lbl_80450B20 = 1;
        }

        if (!lbl_80450B28) {
            lbl_80450B24 = lbl_80451A04;
            lbl_80450B28 = 1;
        }
        if (!lbl_80450B30) {
            lbl_80450B2C = lbl_80451A08;
            lbl_80450B30 = 1;
        }

        u32 tmp5 = m_cpadInfo[controller_pad_no].mPressedButtonFlags;

        if ((m_cpadInfo[controller_pad_no].mPressedButtonFlags & 0x10) &&
            !(m_cpadInfo[controller_pad_no].mButtonFlags & ~0x10)) {
            lbl_804511B8->field_0x68 = !lbl_804511B8->field_0x68;
            JUTAssertion::setMessageCount(0);
        }

        if (lbl_804511B8->field_0x68) {
            u32 tmp = m_cpadInfo[controller_pad_no].mButtonFlags;

            // if R and L are pressed
            if ((tmp & CButton::R && tmp & CButton::L) ||
                ((lbl_80451A08 > m_cpadInfo[controller_pad_no].mTriggerLeft) &&
                 (lbl_80451A08 > m_cpadInfo[controller_pad_no].mTriggerRight))) {
                tmp2 = m_cpadInfo[controller_pad_no].mMainStickPosX;
                tmp3 = m_cpadInfo[controller_pad_no].mMainStickPosY;

                // if x buttons are pressed, clear the console
                if (tmp & (CButton::Y | CButton::START) && tmp5 & CButton::START) {
                    lbl_804511B8->clear();
                }

                u32 tmp = m_cpadInfo[controller_pad_no].mButtonFlags;

                if (!(tmp & (CButton::Y | CButton::START))) {
                    // subtract console scroll value from stick Y
                    float tmp4 = lbl_80450B2C;
                    lbl_80450B2C = tmp4 - tmp3;
                    if (lbl_80450B2C <= lbl_80451A0C) {
                        lbl_80451A10 <= lbl_80450B2C ? tmp = 0 : tmp = lbl_80451A0C;
                    } else {
                        tmp = (tmp4 - tmp3);
                    }

                    if (tmp) {
                        lbl_80450B2C -= (tmp ^ 0x80000000) - 4503601774854144.00000000;
                        lbl_804511B8->scroll(tmp);
                    }
                } else {
                    if (tmp & CButton::X) {
                        lbl_80450B2C += tmp2;
                    }

                    if (tmp & CButton::Y) {
                        lbl_80450B2C -= tmp3;
                    }
                }

                if (tmp5 & CButton::A) {
                    lbl_804511B8->dumpToTerminal(0xFFFFFFFF);
                    lbl_804511B8->field_0x58 = 3;
                }

                JUTReport(0x1E, 0x186, 1, lbl_80373B51);
                JUTReport(0x1E, 400, 1, lbl_80373B73);
                JUTReport(0x1E, 0x19A, 1, lbl_80373B8D);
                tmp6 = lbl_804511B8->getLineOffset();
                JUTReport(0x1E, 0x1A4, 1, lbl_80373BB6, tmp6, lbl_804511B8->field_0x40,
                          lbl_804511B8->field_0x44, lbl_804511B8->field_0x58);
            }
        } else {
            if (tmp5 & 4) {
                g_HIO.field_0x15 ^= 1;
            }

            if (tmp5 & 1) {
                if (sAramObject__7JKRAram->getAramHeap()) {
                    sAramObject__7JKRAram->getAramHeap()->dump();
                }

                dump__24DynamicModuleControlBaseFv();
                dump__14dRes_control_cFv();
            }

            if (tmp5 & 2) {
                sSystemHeap__7JKRHeap->dump_sort();
            }

            if (tmp5 & 8) {
                lbl_80450C2C->dump_sort();
                lbl_80450C28->dump_sort();
                lbl_80450C34->dump_sort();
            }
            JUTReport(0x1E, 0x1B8, 1, lbl_80373BD5);
            JUTReport(0x1E, 0x1C2, 1, lbl_80373BFB);
        }
        lbl_804511B8->field_0x40 = lbl_80450B1C;
        lbl_804511B8->field_0x44 = lbl_80450B24;
        tmp6 = 1;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void Debug_console(u32 param_0) {
    nofralloc
#include "asm/m_Do/m_Do_main/Debug_console__FUl.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 803739A0-803739A0 000000 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80373C23 = "/str/Final/Release/COPYDATE";
#pragma pop

/* 8000614C-800061C8 000A8C 007C+00 1/1 0/0 0/0 .text            LOAD_COPYDATE__FPv */
#ifdef NONMATCHING
s32 LOAD_COPYDATE(void*) {
    s32 status;
    u8 buffer[32];
    u8 fileInfo[80];
    // DVDFileInfo fileInfo;

    status = DVDOpen("/str/Final/Release/COPYDATE", (DVDFileInfo*)&fileInfo);

    if (status) {
        DVDReadPrio((DVDFileInfo*)fileInfo, &buffer, 32, 0, 2);
        memcpy(lbl_803A2EE0, buffer, 17);
        status = DVDClose((DVDFileInfo*)fileInfo);
    }
    return status;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void LOAD_COPYDATE(void* param_0) {
    nofralloc
#include "asm/m_Do/m_Do_main/LOAD_COPYDATE__FPv.s"
}
#pragma pop
#endif

static void debug() {
    if (data_80450580) {
        if (data_80450B1A) {
            CheckHeap(2);
        }

        if (((mDoCPd_c::m_gamePad[2]->buttons.mButtonFlags & ~0x10) == 0x20) &&
            (mDoCPd_c::m_gamePad[2]->buttons.mPressedButtonFlags & 0x10)) {
            struct_80450B18[0] ^= 0x1;
        }

        if (struct_80450B18[0]) {
            if (((mDoCPd_c::m_gamePad[2]->buttons.mButtonFlags & ~0x10) == 0x40) &&
                (mDoCPd_c::m_gamePad[2]->buttons.mPressedButtonFlags & 0x10)) {
                data_80450588[0] < 0x5 ? data_80450588[0]++ : data_80450588[0] = 0x1;
            }

            debugDisplay();
        }

        Debug_console(2);
    }
}

/* ############################################################################################## */
/* 80450B34-80450B38 000034 0004+00 1/1 0/0 0/0 .sbss            frame$3939 */
static u8 frame[4];

/* 8000628C-80006454 000BCC 01C8+00 1/1 0/0 0/0 .text            main01__Fv */
#ifdef NONMATCHING
void main01(void) {
    HeapCheck* heaps = lbl_803D32E0;

    mDoMch_Create__Fv();
    mDoGph_Create();
    create__8mDoCPd_cFv();

    // mDoDVDThd_callback_c thread_callback;
    // JKRSolidHeap audio_heap;

    // Root Heap
    heaps[0].setHeap((JKRExpHeap*)JKRHeap::getRootHeap());
    if (JKRHeap::getRootHeap()) {
        heaps[0].setHeapSize(JKRHeap::getRootHeap()->getSize());
    }

    // System Heap
    heaps[1].setHeap((JKRExpHeap*)JKRHeap::getSystemHeap());
    if (JKRHeap::getSystemHeap()) {
        heaps[1].setHeapSize(JKRHeap::getSystemHeap()->getSize());
    }

    // Zelda Heap
    heaps[2].setHeap(mDoExt_getZeldaHeap());
    if (heaps[2].getHeap()) {
        heaps[2].setHeapSize(heaps[2].getHeap()->getSize());
    }

    // Game Heap
    heaps[3].setHeap(mDoExt_getGameHeap());
    if (heaps[3].getHeap()) {
        heaps[3].setHeapSize(heaps[3].getHeap()->getSize());
    }

    // Archive Heap
    heaps[4].setHeap(mDoExt_getArchiveHeap());
    if (heaps[4].getHeap()) {
        heaps[4].setHeapSize(heaps[4].getHeap()->getSize());
    }

    // J2D Heap
    heaps[5].setHeap(mDoExt_getJ2dHeap());
    if (heaps[5].getHeap()) {
        heaps[5].setHeapSize(heaps[5].getHeap()->getSize());
    }

    // HostIO Heap
    heaps[6].setHeap(mDoExt_getHostIOHeap());
    if (heaps[6].getHeap()) {
        heaps[6].setHeapSize(heaps[6].getHeap()->getSize());
    }

    // Command Heap
    heaps[7].setHeap(mDoExt_getCommandHeap());

    JUTConsole* systemConsole = lbl_804511B8;

    if (heaps[7].getHeap()) {
        heaps[7].setHeapSize(heaps[7].getHeap()->getSize());
    }

    u32 unk = 0;
    if (lbl_80450580) {
        unk = 3;
    }

    systemConsole->field_0x58 = unk;
    systemConsole->field_0x40 = 0x20;
    systemConsole->field_0x44 = 0x2A;

    // lol
    mDoDVDThd_callback_c::create(LOAD_COPYDATE, 0);
    fapGm_Create();
    fopAcM_initManager();
    lbl_80450B18 = 0;
    cDyl_InitAsync__Fv();

    // g_mDoAud_audioHeap

    lbl_80450BBC = JKRSolidHeap::create(0x14d800, JKRHeap::getCurrentHeap(), false);

    // main loop
    do {
        // global frame counter?
        lbl_80450B34++;

        if (lbl_80450B00 && (lbl_80450B34 == ((lbl_80450B34 / lbl_80450B00) * lbl_80450B00))) {
            mDoMch_HeapCheckAll__Fv();
        }

        if (lbl_80450C80) {
            update__15mDoMemCd_Ctrl_cFv();
        }
        mDoCPd_c_NS_read();
        fapGm_Execute();
        mDoAud_Execute();
        debug();
    } while (true);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void main01() {
    nofralloc
#include "asm/m_Do/m_Do_main/main01__Fv.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 803D3420-803DB420 000140 8000+00 1/1 0/0 0/0 .bss             mainThreadStack */
static u8 mainThreadStack[32768];

/* 803DB420-803DB740 008140 0318+08 1/1 0/0 0/0 .bss             mainThread */
static u8 mainThread[792 + 8 /* padding */];

/* 80006454-800065D8 000D94 0184+00 0/0 1/1 0/0 .text            main */
#ifdef NONMATCHING
void main() {
    u32 resetCode;
    OSThread* current_thread = OSGetCurrentThread();
    OSPriority* priority;
    mDoMain::sPowerOnTime = OSGetTime();
    OSReportInit();
    version_check();
    mDoRstData* reset_data = (mDoRstData*)OSAllocFromArenaLo(0x18, 4);
    mDoRst::setResetData(reset_data);

    if (!mDoRst::getResetData()) {
        do {
        } while (true);
    }

    if (!(OSGetResetCode() & 0x80000000)) {
        mDoRst::offReset();
        mDoRst::offResetPrepare();
        mDoRst::off3ButtonReset();
        mDoRst::off3ButtonResetPort(-1);
        mDoRst::setLogoScnFlag(0);
        mDoRst::setProgSeqFlag(0);
        mDoRst::setProgChgFlag(0);
        mDoRst::setWarningDispFlag(0);
        mDoRst::offShutdown();
        mDoRst::offReturnToMenu();
    }

    dComIfG_ct();

    if (data_80450580 < 0) {
        DVDDiskID* disk_id = DVDGetCurrentDiskID();

        if (disk_id->game_version <= 0x90) {
            if (disk_id->game_version <= 0x80) {
                data_80450580 = 0;
            } else {
                resetCode = OSGetConsoleType();
                data_80450580 = (-(resetCode & 0x10000000) >> 0x1f);
            }
        } else {
            data_80450580 = 1;
        }
    }

    priority = OSGetThreadPriority(current_thread);
    OSCreateThread(&mainThread, main01, 0, &mainThread, 0x8000, priority, 0);
    OSResumeThread(&mainThread);
    OSSetThreadPriority(current_thread, 0x1F);
    OSSuspendThread(current_thread);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void main() {
    nofralloc
#include "asm/m_Do/m_Do_main/main.s"
}
#pragma pop
#endif

/* 800065D8-800065E0 000F18 0008+00 0/0 2/0 0/0 .text            dump_sort__7JKRHeapFv */
bool JKRHeap::dump_sort() {
    return true;
}

/* ############################################################################################## */
/* 803739A0-803739A0 000000 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80373C3F = "Root";
SECTION_DEAD static char const* const stringBase_80373C44 = "ルート";
SECTION_DEAD static char const* const stringBase_80373C4B = "System";
SECTION_DEAD static char const* const stringBase_80373C52 = "システム";
SECTION_DEAD static char const* const stringBase_80373C5B = "Zelda";
SECTION_DEAD static char const* const stringBase_80373C61 = "ゼルダ";
SECTION_DEAD static char const* const stringBase_80373C68 = "Game";
SECTION_DEAD static char const* const stringBase_80373C6D = "ゲーム";
SECTION_DEAD static char const* const stringBase_80373C74 = "Archive";
SECTION_DEAD static char const* const stringBase_80373C7C = "アーカイブ";
SECTION_DEAD static char const* const stringBase_80373C87 = "J2d";
SECTION_DEAD static char const* const stringBase_80373C8B = "J2D";
SECTION_DEAD static char const* const stringBase_80373C8F = "Hostio";
SECTION_DEAD static char const* const stringBase_80373C96 = "ホストIO";
SECTION_DEAD static char const* const stringBase_80373C9F = "Command";
SECTION_DEAD static char const* const stringBase_80373CA7 = "コマンド";
#pragma pop

/* 800065E0-80006798 000F20 01B8+00 0/0 1/0 0/0 .text            __sinit_m_Do_main_cpp */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void __sinit_m_Do_main_cpp() {
    nofralloc
#include "asm/m_Do/m_Do_main/__sinit_m_Do_main_cpp.s"
}
#pragma pop

#pragma push
#pragma force_active on
REGISTER_CTORS(0x800065E0, __sinit_m_Do_main_cpp);
#pragma pop

/* ############################################################################################## */
/* 80450B38-80450B3C 000038 0004+00 0/0 2/2 0/0 .sbss
 * sInstance__34JASGlobalInstance<13Z2WolfHowlMgr>              */
extern u8 data_80450B38[4];
u8 data_80450B38[4];

/* 80450B3C-80450B40 00003C 0004+00 0/0 6/6 0/0 .sbss sInstance__31JASGlobalInstance<10Z2EnvSeMgr>
 */
extern u8 data_80450B3C[4];
u8 data_80450B3C[4];

/* 80450B40-80450B44 000040 0004+00 0/0 6/6 0/0 .sbss
 * sInstance__32JASGlobalInstance<11Z2FxLineMgr>                */
extern u8 data_80450B40[4];
u8 data_80450B40[4];

/* 80450B44-80450B48 000044 0004+00 0/0 18/18 0/0 .sbss
 * sInstance__31JASGlobalInstance<10Z2Audience>                 */
extern u8 data_80450B44[4];
u8 data_80450B44[4];

/* 80450B48-80450B4C 000048 0004+00 0/0 17/17 0/0 .sbss
 * sInstance__34JASGlobalInstance<13Z2SoundObjMgr>              */
extern u8 data_80450B48[4];
u8 data_80450B48[4];

/* 80450B4C-80450B50 00004C 0004+00 0/0 10/10 0/0 .sbss
 * sInstance__32JASGlobalInstance<11Z2SoundInfo>                */
extern u8 data_80450B4C[4];
u8 data_80450B4C[4];

/* 80450B50-80450B54 000050 0004+00 0/0 5/5 0/0 .sbss
 * sInstance__33JASGlobalInstance<12JAUSoundInfo>               */
extern u8 data_80450B50[4];
u8 data_80450B50[4];

/* 80450B54-80450B58 000054 0004+00 0/0 2/2 0/0 .sbss
 * sInstance__38JASGlobalInstance<17JAUSoundNameTable>          */
extern u8 data_80450B54[4];
u8 data_80450B54[4];

/* 80450B58-80450B5C 000058 0004+00 0/0 12/12 0/0 .sbss
 * sInstance__34JASGlobalInstance<13JAUSoundTable>              */
extern u8 data_80450B58[4];
u8 data_80450B58[4];

/* 80450B5C-80450B60 00005C 0004+00 0/0 6/6 0/0 .sbss
 * sInstance__33JASGlobalInstance<12JAISoundInfo>               */
extern u8 data_80450B5C[4];
u8 data_80450B5C[4];

/* 80450B60-80450B64 000060 0004+00 0/0 29/29 0/0 .sbss
 * sInstance__31JASGlobalInstance<10Z2SoundMgr>                 */
extern u8 data_80450B60[4];
u8 data_80450B60[4];

/* 80450B64-80450B68 000064 0004+00 0/0 2/2 0/0 .sbss
 * sInstance__33JASGlobalInstance<12JAIStreamMgr>               */
extern u8 data_80450B64[4];
u8 data_80450B64[4];

/* 80450B68-80450B6C 000068 0004+00 0/0 3/3 0/0 .sbss sInstance__29JASGlobalInstance<9JAISeqMgr>
 */
extern u8 data_80450B68[4];
u8 data_80450B68[4];

/* 80450B6C-80450B70 00006C 0004+00 0/0 4/4 0/0 .sbss sInstance__28JASGlobalInstance<8JAISeMgr> */
extern u8 data_80450B6C[4];
u8 data_80450B6C[4];

/* 80450B70-80450B74 000070 0004+00 0/0 9/9 0/0 .sbss
 * sInstance__33JASGlobalInstance<12Z2SpeechMgr2>               */
extern u8 data_80450B70[4];
u8 data_80450B70[4];

/* 80450B74-80450B78 000074 0004+00 0/0 22/22 0/0 .sbss
 * sInstance__35JASGlobalInstance<14Z2SoundStarter>             */
extern u8 data_80450B74[4];
u8 data_80450B74[4];

/* 80450B78-80450B7C 000078 0004+00 0/0 2/2 0/0 .sbss
 * sInstance__36JASGlobalInstance<15JAISoundStarter>            */
extern u8 data_80450B78[4];
u8 data_80450B78[4];

/* 80450B7C-80450B80 00007C 0004+00 0/0 34/34 0/0 .sbss
 * sInstance__32JASGlobalInstance<11Z2StatusMgr>                */
extern u8 data_80450B7C[4];
u8 data_80450B7C[4];

/* 80450B80-80450B84 000080 0004+00 0/0 46/46 0/0 .sbss
 * sInstance__31JASGlobalInstance<10Z2SceneMgr>                 */
extern u8 data_80450B80[4];
u8 data_80450B80[4];

/* 80450B84-80450B88 000084 0004+00 0/0 38/38 0/0 .sbss sInstance__28JASGlobalInstance<8Z2SeqMgr>
 */
extern u8 data_80450B84[4];
u8 data_80450B84[4];

/* 80450B88-80450B8C 000088 0004+00 0/0 25/25 0/0 .sbss sInstance__27JASGlobalInstance<7Z2SeMgr>
 */
extern u8 data_80450B88[4];
u8 data_80450B88[4];

/* 80450B8C-80450B90 00008C 0004+00 0/0 6/6 0/0 .sbss
 * sInstance__35JASGlobalInstance<14JASAudioThread>             */
extern u8 data_80450B8C[4];
u8 data_80450B8C[4];

/* 80450B90-80450B98 000090 0004+04 0/0 4/4 0/0 .sbss
 * sInstance__40JASGlobalInstance<19JASDefaultBankTable>        */
extern u8 data_80450B90[4 + 4 /* padding */];
u8 data_80450B90[4 + 4 /* padding */];

/* 80450B98-80450B9C -00001 0004+00 0/0 6/6 0/0 .sbss            None */
/* 80450B98 0001+00 data_80450B98 None */
/* 80450B99 0001+00 data_80450B99 None */
/* 80450B9A 0001+00 data_80450B9A None */
/* 80450B9B 0001+00 data_80450B9B None */
extern u8 struct_80450B98[4];
u8 struct_80450B98[4];

/* 80450B9C-80450BA0 00009C 0004+00 0/0 3/3 0/0 .sbss            None */
extern u8 data_80450B9C[4];
u8 data_80450B9C[4];

/* 803739A0-803739A0 000000 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
