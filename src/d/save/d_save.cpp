//
// Generated By: dol2asm
// Translation Unit: d/save/d_save
//

#include "d/save/d_save.h"
#include "Z2AudioLib/Z2AudioMgr.h"
#include "d/com/d_com_inf_game.h"
#include "d/meter/d_meter2_info.h"
#include "dol2asm.h"
#include "dolphin/types.h"
#include "rel/d/a/obj/d_a_obj_carry/d_a_obj_carry.h"

//
// Forward References:
//

extern "C" static void dSv_item_rename__FUc();
extern "C" void init__21dSv_player_status_a_cFv();
extern "C" void setSelectItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getSelectItemIndex__21dSv_player_status_a_cCFi();
extern "C" void setMixItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getMixItemIndex__21dSv_player_status_a_cCFi();
extern "C" void getRupeeMax__21dSv_player_status_a_cCFv();
extern "C" void isMagicFlag__21dSv_player_status_a_cCFUc();
extern "C" void init__21dSv_player_status_b_cFv();
extern "C" void onDarkClearLV__21dSv_player_status_b_cFi();
extern "C" void isDarkClearLV__21dSv_player_status_b_cCFi();
extern "C" void onTransformLV__21dSv_player_status_b_cFi();
extern "C" void isTransformLV__21dSv_player_status_b_cCFi();
extern "C" void init__17dSv_horse_place_cFv();
extern "C" void set__17dSv_horse_place_cFPCcRC4cXyzsSc();
extern "C" void init__25dSv_player_return_place_cFv();
extern "C" void set__25dSv_player_return_place_cFPCcScUc();
extern "C" void init__33dSv_player_field_last_stay_info_cFv();
extern "C" void set__33dSv_player_field_last_stay_info_cFPCcRC4cXyzsScUc();
extern "C" void onRegionBit__33dSv_player_field_last_stay_info_cFi();
extern "C" void isRegionBit__33dSv_player_field_last_stay_info_cCFi();
extern "C" void init__27dSv_player_last_mark_info_cFv();
extern "C" void setWarpItemData__27dSv_player_last_mark_info_cFPCcRC4cXyzsScUcUc();
extern "C" void init__17dSv_player_item_cFv();
extern "C" void setItem__17dSv_player_item_cFiUc();
extern "C" void getItem__17dSv_player_item_cCFib();
extern "C" void setLineUpItem__17dSv_player_item_cFv();
extern "C" void getLineUpItem__17dSv_player_item_cCFi();
extern "C" void setBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEmptyBottleItemIn__17dSv_player_item_cFUc();
extern "C" void setEmptyBottle__17dSv_player_item_cFv();
extern "C" void setEmptyBottle__17dSv_player_item_cFUc();
extern "C" void setEquipBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEquipBottleItemEmpty__17dSv_player_item_cFUc();
extern "C" void checkBottle__17dSv_player_item_cFUc();
extern "C" void checkInsectBottle__17dSv_player_item_cFv();
extern "C" void checkEmptyBottle__17dSv_player_item_cFv();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setEmptyBombBag__17dSv_player_item_cFv();
extern "C" void setEmptyBombBag__17dSv_player_item_cFUcUc();
extern "C" void checkBombBag__17dSv_player_item_cFUc();
extern "C" void setWarashibeItem__17dSv_player_item_cFUc();
extern "C" void setRodTypeLevelUp__17dSv_player_item_cFv();
extern "C" void setBaitItem__17dSv_player_item_cFUc();
extern "C" void init__21dSv_player_get_item_cFv();
extern "C" void onFirstBit__21dSv_player_get_item_cFUc();
extern "C" void offFirstBit__21dSv_player_get_item_cFUc();
extern "C" void isFirstBit__21dSv_player_get_item_cCFUc();
extern "C" void init__24dSv_player_item_record_cFv();
extern "C" void setBombNum__24dSv_player_item_record_cFUcUc();
extern "C" void getBombNum__24dSv_player_item_record_cCFUc();
extern "C" void setBottleNum__24dSv_player_item_record_cFUcUc();
extern "C" void addBottleNum__24dSv_player_item_record_cFUcs();
extern "C" void getBottleNum__24dSv_player_item_record_cCFUc();
extern "C" void init__21dSv_player_item_max_cFv();
extern "C" void setBombNum__21dSv_player_item_max_cFUcUc();
extern "C" void getBombNum__21dSv_player_item_max_cCFUc();
extern "C" void init__20dSv_player_collect_cFv();
extern "C" void setCollect__20dSv_player_collect_cFiUc();
extern "C" void isCollect__20dSv_player_collect_cCFiUc();
extern "C" void onCollectCrystal__20dSv_player_collect_cFUc();
extern "C" void isCollectCrystal__20dSv_player_collect_cCFUc();
extern "C" void onCollectMirror__20dSv_player_collect_cFUc();
extern "C" void isCollectMirror__20dSv_player_collect_cCFUc();
extern "C" void init__17dSv_player_wolf_cFv();
extern "C" void init__16dSv_light_drop_cFv();
extern "C" void setLightDropNum__16dSv_light_drop_cFUcUc();
extern "C" void getLightDropNum__16dSv_light_drop_cCFUc();
extern "C" void onLightDropGetFlag__16dSv_light_drop_cFUc();
extern "C" void isLightDropGetFlag__16dSv_light_drop_cCFUc();
extern "C" void init__17dSv_letter_info_cFv();
extern "C" void onLetterGetFlag__17dSv_letter_info_cFi();
extern "C" void isLetterGetFlag__17dSv_letter_info_cCFi();
extern "C" void onLetterReadFlag__17dSv_letter_info_cFi();
extern "C" void isLetterReadFlag__17dSv_letter_info_cCFi();
extern "C" void init__18dSv_fishing_info_cFv();
extern "C" void addFishCount__18dSv_fishing_info_cFUc();
extern "C" void init__17dSv_player_info_cFv();
extern "C" void init__19dSv_player_config_cFv();
extern "C" void checkVibration__19dSv_player_config_cCFv();
extern "C" void getSound__19dSv_player_config_cFv();
extern "C" void setSound__19dSv_player_config_cFUc();
extern "C" void getVibration__19dSv_player_config_cFv();
extern "C" void setVibration__19dSv_player_config_cFUc();
extern "C" void init__12dSv_player_cFv();
extern "C" void init__12dSv_memBit_cFv();
extern "C" void onTbox__12dSv_memBit_cFi();
extern "C" void offTbox__12dSv_memBit_cFi();
extern "C" void isTbox__12dSv_memBit_cCFi();
extern "C" void onSwitch__12dSv_memBit_cFi();
extern "C" void offSwitch__12dSv_memBit_cFi();
extern "C" void isSwitch__12dSv_memBit_cCFi();
extern "C" void revSwitch__12dSv_memBit_cFi();
extern "C" void onItem__12dSv_memBit_cFi();
extern "C" void isItem__12dSv_memBit_cCFi();
extern "C" void onDungeonItem__12dSv_memBit_cFi();
extern "C" void isDungeonItem__12dSv_memBit_cCFi();
extern "C" void init__11dSv_event_cFv();
extern "C" void onEventBit__11dSv_event_cFUs();
extern "C" void offEventBit__11dSv_event_cFUs();
extern "C" void isEventBit__11dSv_event_cCFUs();
extern "C" void setEventReg__11dSv_event_cFUsUc();
extern "C" void getEventReg__11dSv_event_cCFUs();
extern "C" void init__14dSv_MiniGame_cFv();
extern "C" void init__12dSv_memory_cFv();
extern "C" void init__13dSv_memory2_cFv();
extern "C" void onVisitedRoom__13dSv_memory2_cFi();
extern "C" void offVisitedRoom__13dSv_memory2_cFi();
extern "C" void isVisitedRoom__13dSv_memory2_cFi();
extern "C" void init__12dSv_danBit_cFSc();
extern "C" void onSwitch__12dSv_danBit_cFi();
extern "C" void offSwitch__12dSv_danBit_cFi();
extern "C" void isSwitch__12dSv_danBit_cCFi();
extern "C" void revSwitch__12dSv_danBit_cFi();
extern "C" void onItem__12dSv_danBit_cFi();
extern "C" void isItem__12dSv_danBit_cCFi();
extern "C" void init__13dSv_zoneBit_cFv();
extern "C" void clearRoomSwitch__13dSv_zoneBit_cFv();
extern "C" void clearRoomItem__13dSv_zoneBit_cFv();
extern "C" void onSwitch__13dSv_zoneBit_cFi();
extern "C" void offSwitch__13dSv_zoneBit_cFi();
extern "C" void isSwitch__13dSv_zoneBit_cCFi();
extern "C" void revSwitch__13dSv_zoneBit_cFi();
extern "C" void onOneSwitch__13dSv_zoneBit_cFi();
extern "C" void offOneSwitch__13dSv_zoneBit_cFi();
extern "C" void isOneSwitch__13dSv_zoneBit_cCFi();
extern "C" void revOneSwitch__13dSv_zoneBit_cFi();
extern "C" void onItem__13dSv_zoneBit_cFi();
extern "C" void isItem__13dSv_zoneBit_cCFi();
extern "C" void onOneItem__13dSv_zoneBit_cFi();
extern "C" void isOneItem__13dSv_zoneBit_cCFi();
extern "C" void init__15dSv_zoneActor_cFv();
extern "C" void on__15dSv_zoneActor_cFi();
extern "C" void off__15dSv_zoneActor_cFi();
extern "C" void is__15dSv_zoneActor_cCFi();
extern "C" void init__10dSv_zone_cFi();
extern "C" void setRoom__13dSv_restart_cFRC4cXyzsSc();
extern "C" void set__17dSv_turnRestart_cFRC4cXyzsScUl();
extern "C" void init__10dSv_info_cFv();
extern "C" void init__10dSv_save_cFv();
extern "C" void getSave2__10dSv_save_cFi();
extern "C" void getSave__10dSv_info_cFi();
extern "C" void putSave__10dSv_info_cFi();
extern "C" void initZone__10dSv_info_cFv();
extern "C" void createZone__10dSv_info_cFi();
extern "C" void onSwitch__10dSv_info_cFii();
extern "C" void offSwitch__10dSv_info_cFii();
extern "C" void isSwitch__10dSv_info_cCFii();
extern "C" void revSwitch__10dSv_info_cFii();
extern "C" void onItem__10dSv_info_cFii();
extern "C" void isItem__10dSv_info_cCFii();
extern "C" void onActor__10dSv_info_cFii();
extern "C" void offActor__10dSv_info_cFii();
extern "C" void isActor__10dSv_info_cCFii();
extern "C" void memory_to_card__10dSv_info_cFPci();
extern "C" void card_to_memory__10dSv_info_cFPci();
extern "C" void initdata_to_card__10dSv_info_cFPci();
extern "C" u8 const tempBitLabels__20dSv_event_tmp_flag_c[370 + 2 /* padding */];
extern "C" extern char const* const d_save_d_save__stringBase0;
extern "C" u8 saveBitLabels__16dSv_event_flag_c[1644 + 4 /* padding */];

//
// External References:
//

extern "C" void setNowVibration__14dComIfG_play_cFUc();
extern "C" void getNowVibration__14dComIfG_play_cFv();
extern "C" void getZoneNo__20dStage_roomControl_cFi();
extern "C" void dComIfGs_setSelectItemIndex__FiUc(int, u8);
extern "C" void dComIfGs_setMixItemIndex__FiUc(int, u8);
extern "C" u8 dComIfGs_getMixItemIndex__Fi(int);
extern "C" void dComIfGp_setSelectItem__Fi(int);
extern "C" u8 dComIfGs_getBottleMax__Fv();
extern "C" void dComIfGs_setKeyNum__FiUc();
extern "C" void __ct__13dSv_memory2_cFv();
extern "C" void __ct__12dSv_memory_cFv();
extern "C" void clrSaveFlag__12daObjCarry_cFv();
extern "C" void setSaveFlag__12daObjCarry_cFv();
extern "C" void setInitEventBit__Fv();
extern "C" void getString__13dMeter2Info_cFUlPcP14JMSMesgEntry_c();
extern "C" void setHotSpringTimer__13dMeter2Info_cFUc();
extern "C" void setSaveStageName__13dMeter2Info_cFPCc();
extern "C" void setOutputMode__10Z2AudioMgrFUl();
extern "C" void __construct_array();
extern "C" void _savegpr_22();
extern "C" void _savegpr_26();
extern "C" void _savegpr_27();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_22();
extern "C" void _restgpr_26();
extern "C" void _restgpr_27();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();
extern "C" void __div2i();
extern "C" u8 mAudioMgrPtr__10Z2AudioMgr[4 + 4 /* padding */];
extern "C" u8 sRumbleSupported__10JUTGamePad[4];

//
// Declarations:
//

static u8 dSv_item_rename(u8 i_itemNo) {
    switch (i_itemNo) {
    case OIL_BOTTLE_2:
        return OIL_BOTTLE;
    case RED_BOTTLE_2:
        return RED_BOTTLE;
    case OIL2:
        return OIL;
    default:
        return i_itemNo;
    }
}

void dSv_player_status_a_c::init() {
    mMaxLife = 15;
    mLife = 12;
    mRupee = 0;
    mMaxOil = 0;
    mOil = 0;
    unk10 = 0;

    for (int i = 0; i < MAX_SELECT_ITEM; i++) {
        mSelectItem[i] = 0xFF;
        mMixItem[i] = 0xFF;
        dComIfGp_setSelectItem(i);
    }

    for (int i = 0; i < MAX_EQUIPMENT; i++) {
        mSelectEquip[i] = 0;
    }

    mSelectEquip[COLLECT_CLOTHING] = WEAR_CASUAL;
    mSelectEquip[COLLECT_SWORD] = NO_ITEM;
    mSelectEquip[COLLECT_SHIELD] = NO_ITEM;
    mSelectEquip[COLLECT_SMELL] = NO_ITEM;
    mSelectEquip[B_BUTTON_ITEM] = NO_ITEM;
    mWalletSize = WALLET;
    mMaxMagic = 0;
    mMagic = 0;
    mMagicFlag = 0;
    unk29 = 0;
    mTransformStatus = TF_STATUS_HUMAN;

    for (int i = 0; i < 3; i++) {
        unk31[i] = 0;
    }
}

void dSv_player_status_a_c::setSelectItemIndex(int i_no, u8 i_slotNo) {
    if (i_no < MAX_SELECT_ITEM) {
        mSelectItem[i_no] = i_slotNo;
    }
}

u8 dSv_player_status_a_c::getSelectItemIndex(int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mSelectItem[i_no];
    }
    return 0;
}

void dSv_player_status_a_c::setMixItemIndex(int i_no, u8 i_slotNo) {
    if (i_no < MAX_SELECT_ITEM) {
        mMixItem[i_no] = i_slotNo;
    }
}

u8 dSv_player_status_a_c::getMixItemIndex(int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mMixItem[i_no];
    }
    return 0;
}

u16 dSv_player_status_a_c::getRupeeMax() const {
    if (mWalletSize < 3) {  // if you make this a default, it wont match. Compiler, pls.
        switch (mWalletSize) {
        case WALLET:
            return 300;
        case BIG_WALLET:
            return 600;
        case GIANT_WALLET:
            return 1000;
        }
    }
    return 0;
}

BOOL dSv_player_status_a_c::isMagicFlag(u8 i_magic) const {
    if (i_magic == 0) {
        return i_dComIfGs_isEventBit(0x2304);  // Magic Unlocked
    }

    return (mMagicFlag & (u8)(1 << i_magic)) ? TRUE : FALSE;
}

void dSv_player_status_b_c::init() {
    mDateIpl = 0;
    mTransformLevelFlag = 0;
    mDarkClearLevelFlag = 0;
    unk10 = 0;
    mTime = 255.0f;
    mDate = 0;

    for (int i = 0; i < 3; i++) {
        unk18[i] = 0;
    }
}

void dSv_player_status_b_c::onDarkClearLV(int i_no) {
    mDarkClearLevelFlag |= (u8)(1 << i_no);
}

BOOL dSv_player_status_b_c::isDarkClearLV(int i_no) const {
    return mDarkClearLevelFlag & (u8)(1 << i_no) ? TRUE : FALSE;
}

void dSv_player_status_b_c::onTransformLV(int i_no) {
    mTransformLevelFlag |= (u8)(1 << i_no);
}

BOOL dSv_player_status_b_c::isTransformLV(int i_no) const {
    return mTransformLevelFlag & (u8)(1 << i_no) ? TRUE : FALSE;
}

void dSv_horse_place_c::init() {
    strcpy(mName, "");
    mPos.set(0.0f, 0.0f, 0.0f);
    mAngleY = 0;
    mSpawnId = 0;
    mRoomNo = 0;
}

void dSv_horse_place_c::set(const char* i_name, const cXyz& i_pos, s16 i_angle, s8 i_roomNo) {
    strcpy(mName, i_name);
    mPos = i_pos;
    mAngleY = i_angle;
    mRoomNo = i_roomNo;
}

void dSv_player_return_place_c::init() {
    strcpy(mName, "F_SP108");
    mRoomNo = 1;
    mPlayerStatus = 0;
    unk10 = 21;
    unk11 = 0;
}

void dSv_player_return_place_c::set(const char* i_name, s8 i_roomNo, u8 i_status) {
    strcpy(mName, i_name);
    mRoomNo = i_roomNo;
    mPlayerStatus = i_status;
}

void dSv_player_field_last_stay_info_c::init() {
    strcpy(mName, "");
    mPos.set(0.0f, 0.0f, 0.0f);
    mAngleY = 0;
    mLastSpawnId = 0;
    mRegionNo = 1;
    mFieldDataExistFlag = false;
    mRegion = 0;

    for (int i = 0; i < 2; i++) {
        unk26[i] = 0;
    }
}

void dSv_player_field_last_stay_info_c::set(const char* i_name, const cXyz& i_pos, s16 i_angle,
                                            s8 i_spawn, u8 i_regionNo) {
    strcpy(mName, i_name);
    mPos = i_pos;
    mAngleY = i_angle;
    mLastSpawnId = i_spawn;
    mRegionNo = i_regionNo;
}

void dSv_player_field_last_stay_info_c::onRegionBit(int i_region) {
    if (i_region >= 0 && i_region < 8) {
        mRegion |= (u8)(1 << i_region);
    }
}

BOOL dSv_player_field_last_stay_info_c::isRegionBit(int i_region) const {
    if (i_region >= 0 && i_region < 8) {
        return (mRegion & (u8)(1 << i_region)) ? TRUE : FALSE;
    }
    return false;
}

void dSv_player_last_mark_info_c::init() {
    strcpy(mName, "");
    mPos.set(0.0f, 0.0f, 0.0f);
    mAngleY = 0;
    mRoomNo = 0;
    mSpawnId = 0;
    mWarpAcceptStage = -1;

    for (int i = 0; i < 3; i++) {
        unk25[i] = 0;
    }
}

void dSv_player_last_mark_info_c::setWarpItemData(const char* i_name, const cXyz& i_pos,
                                                  s16 i_angle, s8 i_roomNo, u8, u8) {
    strcpy(mName, i_name);
    mPos.set(i_pos);
    mAngleY = i_angle;
    mRoomNo = i_roomNo;
}

void dSv_player_item_c::init() {
    for (int i = 0; i < MAX_ITEM_SLOTS; i++) {
        mItems[i] = NO_ITEM;
        mItemSlots[i] = NO_ITEM;
    }
}

void dSv_player_item_c::setItem(int i_slotNo, u8 i_itemNo) {
    if (i_slotNo < MAX_ITEM_SLOTS) {
        mItems[i_slotNo] = i_itemNo;
        setLineUpItem();
    }

    for (int i = DEFAULT_SELECT_ITEM_INDEX; i < MAX_SELECT_ITEM - 1; i++) {
        if (i_slotNo == dComIfGs_getSelectItemIndex(i)) {
            dComIfGp_setSelectItem(i);
        }
    }
}

u8 dSv_player_item_c::getItem(int i_slotNo, bool i_checkCombo) const {
    if (i_slotNo < MAX_ITEM_SLOTS) {
        if (i_checkCombo) {
            for (int i = 0; i < SELECT_ITEM_NUM; i++) {
                if ((i_slotNo == dComIfGs_getSelectItemIndex(i) ||
                     i_slotNo == dComIfGs_getMixItemIndex(i)) &&
                    dComIfGs_getMixItemIndex(i) != NO_ITEM) {
                    u8 select_item = mItems[dComIfGs_getSelectItemIndex(i)];
                    u8 mix_item = mItems[dComIfGs_getMixItemIndex(i)];

                    // Get Bomb arrow check: Bow + Normal Bombs
                    if ((select_item == BOW && mix_item == NORMAL_BOMB) ||
                        (mix_item == BOW && select_item == NORMAL_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Water Bombs
                    if ((select_item == BOW && mix_item == WATER_BOMB) ||
                        (mix_item == BOW && select_item == WATER_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Bomblings
                    if ((select_item == BOW && mix_item == POKE_BOMB) ||
                        (mix_item == BOW && select_item == POKE_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Hawkeye check
                    if ((select_item == BOW && mix_item == HAWK_EYE) ||
                        (mix_item == BOW && select_item == HAWK_EYE)) {
                        return HAWK_ARROW;
                    }

                    // Get Rod w/ bee larva
                    if ((select_item == FISHING_ROD_1 && mix_item == BEE_CHILD) ||
                        (mix_item == FISHING_ROD_1 && select_item == BEE_CHILD)) {
                        return BEE_ROD;
                    }

                    // Get Rod w/ coral earring
                    if ((select_item == FISHING_ROD_1 && mix_item == ZORAS_JEWEL) ||
                        (mix_item == FISHING_ROD_1 && select_item == ZORAS_JEWEL)) {
                        return JEWEL_ROD;
                    }

                    // Get Rod w/ worm
                    if ((select_item == FISHING_ROD_1 && mix_item == WORM) ||
                        (mix_item == FISHING_ROD_1 && select_item == WORM)) {
                        return WORM_ROD;
                    }

                    // This block will only run on the Wii version
                    if (i == SELECT_ITEM_B) {
                        if (dComIfGs_getSelectItemIndex(i) == 0 &&
                            dComIfGs_getMixItemIndex(i) == 0) {
                            dComIfGs_setSelectItemIndex(i, NO_ITEM);
                            dComIfGs_setMixItemIndex(i, NO_ITEM);
                            return NO_ITEM;
                        }
                    }
                    // Uncertain combination item＝＝＝＞%d, %d\n
                    OSReport_Error("合成アイテム不定＝＝＝＞%d, %d\n", select_item, mix_item);
                }
            }
        }
        return mItems[i_slotNo];
    }

    return NO_ITEM;
}

static u8 i_item_lst[23] = {
    0x0A, 0x08, 0x06, 0x02, 0x09, 0x04, 0x03, 0x00, 0x01, 0x17, 0x14, 0x05,
    0x0F, 0x10, 0x11, 0x0B, 0x0C, 0x0D, 0x0E, 0x13, 0x12, 0x16, 0x15,
};

/* 800332F8-80033354 02DC38 005C+00 2/2 0/0 0/0 .text setLineUpItem__17dSv_player_item_cFv */
// this is close
#ifdef NONMATCHING
void dSv_player_item_c::setLineUpItem() {
    int i1 = 0;
    int i2 = 0;

    for (; i1 < 24; i1++) {
        mItemSlots[i1] = NO_ITEM;
    }

    for (int i1 = 0; i1 < 23; i1++) {
        if (mItems[i_item_lst[i1]] != NO_ITEM) {
            mItemSlots[i2] = i_item_lst[i1];
            i2++;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setLineUpItem() {
    nofralloc
#include "asm/d/save/d_save/setLineUpItem__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

u8 dSv_player_item_c::getLineUpItem(int i_slotNo) const {
    if (i_slotNo < MAX_ITEM_SLOTS) {
        return mItemSlots[i_slotNo];
    }

    return NO_ITEM;
}

/* 80033370-80033450 02DCB0 00E0+00 1/1 2/2 0/0 .text setBottleItemIn__17dSv_player_item_cFUcUc */
#ifdef NONMATCHING
void dSv_player_item_c::setBottleItemIn(u8 curItemIn, u8 newItemIn) {
    u8 cur_item = dSv_item_rename(curItemIn);
    u8 new_item = dSv_item_rename(newItemIn);

    for (int i = 0; i < 4; i++) {
        if (cur_item == mItems[i + SLOT_11]) {
            setItem(i + SLOT_11, new_item);
            if (new_item == HOT_SPRING) {
                dMeter2Info_setHotSpringTimer(i + SLOT_11);
            }

            for (int j = 0; j < 3; j++) {
                if (i + SLOT_11 == dComIfGs_getSelectItemIndex(j)) {
                    dComIfGp_setSelectItem(j);
                }
            }
            return;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBottleItemIn(u8 curItemIn, u8 newItemIn) {
    nofralloc
#include "asm/d/save/d_save/setBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop
#endif

/* 80033450-80033494 02DD90 0044+00 0/0 26/26 0/0 .text
 * setEmptyBottleItemIn__17dSv_player_item_cFUc                 */
// this is 1 instruction off
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBottleItemIn(u8 i_itemNo) {
    setBottleItemIn(EMPTY_BOTTLE, dSv_item_rename(i_itemNo));
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBottleItemIn(u8 i_itemNo) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBottleItemIn__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

void dSv_player_item_c::setEmptyBottle() {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_11), EMPTY_BOTTLE);
            return;
        }
    }
}

void dSv_player_item_c::setEmptyBottle(u8 i_itemNo) {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_11), i_itemNo);
            return;
        }
    }
}

/* 80033598-800336BC 02DED8 0124+00 1/1 3/3 0/0 .text
 * setEquipBottleItemIn__17dSv_player_item_cFUcUc               */
// one instruction
#ifdef NONMATCHING
void dSv_player_item_c::setEquipBottleItemIn(u8 curItemIn, u8 newItemIn) {
    u8 new_item = dSv_item_rename(newItemIn);

    if (dComIfGs_getSelectItemIndex(curItemIn) >= SLOT_11 &&
        dComIfGs_getSelectItemIndex(curItemIn) <= SLOT_14) {
        if (new_item == HOT_SPRING) {
            dMeter2Info_setHotSpringTimer(dComIfGs_getSelectItemIndex(curItemIn));
        }

        setItem(dComIfGs_getSelectItemIndex(curItemIn), new_item);
        dComIfGs_setItem(dComIfGs_getSelectItemIndex(curItemIn), new_item);
        dComIfGp_setItem(dComIfGs_getSelectItemIndex(curItemIn), new_item);
        dComIfGp_setSelectItem(curItemIn);
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEquipBottleItemIn(u8 curItemIn, u8 newItemIn) {
    nofralloc
#include "asm/d/save/d_save/setEquipBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop
#endif

void dSv_player_item_c::setEquipBottleItemEmpty(u8 curItemIn) {
    setEquipBottleItemIn(curItemIn, EMPTY_BOTTLE);
}

u8 dSv_player_item_c::checkBottle(u8 i_itemNo) {
    u8 num_bottles = 0;
    u8 item_id = dSv_item_rename(i_itemNo);

    for (int i = 0; i < BOTTLE_MAX; i++) {
        if (item_id == mItems[i + SLOT_11]) {
            num_bottles++;
        }
    }
    return num_bottles;
}

/* ############################################################################################## */
/* 803A7288-803A78F8 0043A8 066C+04 2/2 45/45 148/148 .data saveBitLabels__16dSv_event_flag_c */
u16 dSv_event_flag_c::saveBitLabels[822] = {
    0xFFFF, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001, 0x0180, 0x0140, 0x0120,
    0x0110, 0x0108, 0x0104, 0x0102, 0x0101, 0x0280, 0x0240, 0x0220, 0x0210, 0x0208, 0x0204, 0x0202,
    0x0201, 0x0380, 0x0340, 0x0320, 0x0310, 0x0308, 0x0304, 0x0302, 0x0301, 0x0480, 0x0440, 0x0420,
    0x0410, 0x0408, 0x0404, 0x0402, 0x0401, 0x0580, 0x0540, 0x0520, 0x0510, 0x0508, 0x0504, 0x0502,
    0x0501, 0x0680, 0x0640, 0x0620, 0x0610, 0x0608, 0x0604, 0x0602, 0x0601, 0x0780, 0x0740, 0x0720,
    0x0710, 0x0708, 0x0704, 0x0702, 0x0701, 0x0880, 0x0840, 0x0820, 0x0810, 0x0808, 0x0804, 0x0802,
    0x0801, 0x0980, 0x0940, 0x0920, 0x0910, 0x0908, 0x0904, 0x0902, 0x0901, 0x0A80, 0x0A40, 0x0A20,
    0x0A10, 0x0A08, 0x0A04, 0x0A02, 0x0A01, 0x0B80, 0x0B40, 0x0B20, 0x0B10, 0x0B08, 0x0B04, 0x0B02,
    0x0B01, 0x0C80, 0x0C40, 0x0C20, 0x0C10, 0x0C08, 0x0C04, 0x0C02, 0x0C01, 0x0D80, 0x0D40, 0x0D20,
    0x0D10, 0x0D08, 0x0D04, 0x0D02, 0x0D01, 0x0E80, 0x0E40, 0x0E20, 0x0E10, 0x0E08, 0x0E04, 0x0E02,
    0x0E01, 0x0F80, 0x0F40, 0x0F20, 0x0F10, 0x0F08, 0x0F04, 0x0F02, 0x0F01, 0x1080, 0x1040, 0x1020,
    0x1010, 0x1008, 0x1004, 0x1002, 0x1001, 0x1180, 0x1140, 0x1120, 0x1110, 0x1108, 0x1104, 0x1102,
    0x1101, 0x1280, 0x1240, 0x1220, 0x1210, 0x1208, 0x1204, 0x1202, 0x1201, 0x1380, 0x1340, 0x1320,
    0x1310, 0x1308, 0x1304, 0x1302, 0x1301, 0x1480, 0x1440, 0x1420, 0x1410, 0x1408, 0x1404, 0x1402,
    0x1401, 0x1580, 0x1540, 0x1520, 0x1510, 0x1508, 0x1504, 0x1502, 0x1501, 0x1680, 0x1640, 0x1620,
    0x1610, 0x1608, 0x1604, 0x1602, 0x1601, 0xFF1F, 0x1780, 0x1740, 0x1720, 0x1710, 0x1708, 0x1704,
    0x1702, 0x1701, 0x1880, 0x1840, 0x1820, 0x1810, 0xFEFF, 0xFDFF, 0xFCFF, 0xFBFF, 0x1808, 0x1804,
    0x1802, 0x1801, 0x1980, 0x1940, 0x1920, 0x1910, 0x1908, 0x1904, 0x1902, 0x1901, 0x1A80, 0x1A40,
    0x1A20, 0x1A10, 0x1A08, 0x1A04, 0x1A02, 0x1A01, 0x1B80, 0x1B40, 0x1B20, 0x1B10, 0x1B08, 0x1B04,
    0x1B02, 0x1B01, 0x1C80, 0x1C40, 0x1C20, 0x1C10, 0x1C08, 0x1C04, 0x1C02, 0x1C01, 0x1D80, 0x1D40,
    0x1D20, 0x1D10, 0x1D08, 0x1D04, 0x1D02, 0x1D01, 0x1E80, 0x1E40, 0x1E20, 0x1E10, 0x1E08, 0x1E04,
    0x1E02, 0x1E01, 0x1F80, 0x1F40, 0x1F20, 0x1F10, 0x1F08, 0x1F04, 0x1F02, 0x1F01, 0x2080, 0x2040,
    0x2020, 0x2010, 0x2008, 0x2004, 0x2002, 0x2001, 0x2180, 0x2140, 0x2120, 0x2110, 0x2108, 0x2104,
    0x2102, 0x2101, 0x2280, 0x2240, 0x2220, 0x2210, 0x2208, 0x2204, 0x2202, 0x2201, 0x2380, 0x2340,
    0x2320, 0x2310, 0x2308, 0x2304, 0x2302, 0x2301, 0x2480, 0x2440, 0x2420, 0x2410, 0x2408, 0x2404,
    0x2402, 0x2401, 0x2580, 0x2540, 0x2520, 0x2510, 0x2508, 0x2504, 0x2502, 0x2501, 0x2680, 0x2640,
    0x2620, 0x2610, 0x2608, 0x2604, 0x2602, 0x2601, 0x2780, 0x2740, 0x2720, 0x2710, 0x2708, 0x2704,
    0x2702, 0x2701, 0x2880, 0x2840, 0x2820, 0x2810, 0x2808, 0x2804, 0x2802, 0x2801, 0x2980, 0x2940,
    0x2920, 0x2910, 0x2908, 0x2904, 0x2902, 0x2901, 0x2A80, 0x2A40, 0x2A20, 0x2A10, 0x2A08, 0x2A04,
    0x2A02, 0x2A01, 0x2B80, 0x2B40, 0x2B20, 0x2B10, 0x2B08, 0x2B04, 0x2B02, 0x2B01, 0x2C80, 0x2C40,
    0x2C20, 0x2C10, 0x2C08, 0x2C04, 0x2C02, 0x2C01, 0x2D80, 0x2D40, 0x2D20, 0x2D10, 0x2D08, 0x2D04,
    0x2D02, 0x2D01, 0x2E80, 0x2E40, 0x2E20, 0x2E10, 0x2E08, 0x2E04, 0x2E02, 0x2E01, 0x2F80, 0x2F40,
    0x2F20, 0x2F10, 0x2F08, 0x2F04, 0x2F02, 0x2F01, 0x3080, 0x3040, 0x3020, 0x3010, 0x3008, 0x3004,
    0x3002, 0x3001, 0x3180, 0x3140, 0x3120, 0x3110, 0x3108, 0x3104, 0x3102, 0x3101, 0x3280, 0x3240,
    0x3220, 0x3210, 0x3208, 0x3204, 0x3202, 0x3201, 0x3380, 0x3340, 0x3320, 0x3310, 0x3308, 0x3304,
    0x3302, 0x3301, 0x3480, 0x3440, 0x3420, 0x3410, 0x3408, 0x3404, 0x3402, 0x3401, 0x3580, 0x3540,
    0x3520, 0x3510, 0x3508, 0x3504, 0x3502, 0x3501, 0x3680, 0x3640, 0x3620, 0x3610, 0x3608, 0x3604,
    0x3602, 0x3601, 0x3780, 0x3740, 0x3720, 0x3710, 0x3708, 0xFAFF, 0xF9FF, 0x3704, 0x3702, 0x3701,
    0x3880, 0x3840, 0x3820, 0x3810, 0x3808, 0x3804, 0x3802, 0x3801, 0x3980, 0x3940, 0x3920, 0x3910,
    0x3908, 0x3904, 0x3902, 0x3901, 0x3A80, 0x3A40, 0x3A20, 0x3A10, 0x3A08, 0x3A04, 0x3A02, 0x3A01,
    0x3B80, 0x3B40, 0x3B20, 0x3B10, 0x3B08, 0x3B04, 0x3B02, 0x3B01, 0x3C80, 0x3C40, 0x3C20, 0x3C10,
    0x3C08, 0x3C04, 0x3C02, 0x3C01, 0x3D80, 0x3D40, 0x3D20, 0x3D10, 0x3D08, 0x3D04, 0x3D02, 0x3D01,
    0x3E80, 0x3E40, 0x3E20, 0x3E10, 0x3E08, 0x3E04, 0x3E02, 0xF8FF, 0xF7FF, 0x3E01, 0x3F80, 0x3F40,
    0x3F20, 0x3F10, 0x3F08, 0x3F04, 0x3F02, 0x3F01, 0x4080, 0x4040, 0x4020, 0x4010, 0x4008, 0x4004,
    0x4002, 0x4001, 0x4180, 0x4140, 0x4120, 0x4110, 0x4108, 0x4104, 0x4102, 0x4101, 0x4280, 0x4240,
    0x4220, 0x4210, 0x4208, 0x4204, 0x4202, 0x4201, 0x4380, 0x4340, 0x4320, 0x4310, 0x4308, 0x4304,
    0x4302, 0x4301, 0x4480, 0x4440, 0x4420, 0x4410, 0x4408, 0x4404, 0x4402, 0x4401, 0x4580, 0x4540,
    0x4520, 0x4510, 0x4508, 0x4504, 0x4502, 0x4501, 0x4680, 0x4640, 0x4620, 0x4610, 0x4608, 0x4604,
    0x4602, 0x4601, 0x4780, 0x4740, 0x4720, 0x4710, 0x4708, 0x4704, 0x4702, 0x4701, 0x4880, 0x4840,
    0x4820, 0x4810, 0x4808, 0x4804, 0x4802, 0x4801, 0x4980, 0x4940, 0x4920, 0x4910, 0x4908, 0x4904,
    0x4902, 0x4901, 0xFFFF, 0x4A40, 0x4A20, 0x4A10, 0x4A08, 0x4A04, 0x4A02, 0x4A01, 0x4B80, 0x4B40,
    0x4B20, 0x4B10, 0x4B08, 0x4B04, 0x4B02, 0x4B01, 0x4C80, 0x4C40, 0x4C20, 0x4C10, 0x4C08, 0x4C04,
    0x4C02, 0x4C01, 0x4D80, 0x4D40, 0x4D20, 0x4D10, 0x4D08, 0x4A80, 0x4D04, 0x4D02, 0x4D01, 0x4E80,
    0x4E40, 0x4E20, 0x4E10, 0x4E08, 0x4E04, 0x4E02, 0x4E01, 0x4F80, 0x4F40, 0x4F20, 0x4F10, 0x4F08,
    0x4F04, 0x4F02, 0x4F01, 0x5080, 0x5040, 0x5020, 0x5010, 0x5008, 0x5004, 0x5002, 0x5001, 0x5180,
    0x5140, 0x5120, 0x5110, 0x5108, 0x5104, 0x5102, 0x5101, 0x5280, 0x5240, 0x5220, 0x5210, 0x5208,
    0x5204, 0x5202, 0x5201, 0x5380, 0x5340, 0x5320, 0x5310, 0x5308, 0x5304, 0x5302, 0x5301, 0x5480,
    0x5440, 0x5420, 0x5410, 0x5408, 0x5404, 0x5402, 0x5401, 0x5580, 0x5540, 0x5520, 0x5510, 0x5508,
    0x5504, 0x5502, 0x5501, 0x5680, 0x5640, 0x5620, 0x5610, 0x5608, 0x5604, 0x5602, 0x5601, 0x5780,
    0x5740, 0x5720, 0xF63F, 0xF57F, 0xF47F, 0xF37F, 0xF27F, 0x5710, 0x5708, 0x5704, 0x5702, 0x5701,
    0x5880, 0x5840, 0x5820, 0x5810, 0x5808, 0x5804, 0x5802, 0x5801, 0x5980, 0x5940, 0x5920, 0xF11F,
    0x5910, 0x5908, 0x5904, 0x5902, 0x5901, 0x5A80, 0x5A40, 0x5A20, 0x5A10, 0x5A08, 0x5A04, 0x5A02,
    0x5A01, 0x5B80, 0x5B40, 0x5B20, 0x5B10, 0x5B08, 0x5B04, 0x5B02, 0x5B01, 0x5C80, 0x5C40, 0x5C20,
    0x5C10, 0x5C08, 0x5C04, 0x5C02, 0xF0FF, 0xEFFF, 0xEEFF, 0xEDFF, 0xECFF, 0xEBFF, 0x5C01, 0x5D80,
    0x5D40, 0x5D20, 0x5D10, 0x5D08, 0x5D04, 0x5D02, 0x5D01, 0x5E80, 0x5E40, 0x5E20, 0x5E10, 0x5E08,
    0x5E04, 0x5E02, 0x5E01, 0x5F80, 0x5F40, 0x5F20, 0x5F10, 0x5F08, 0x5F04, 0x5F02, 0x5F01, 0x6080,
    0x6040, 0x6020, 0x6010, 0x6008, 0x6004, 0x6002, 0x6001, 0x6180, 0x6140, 0x6120, 0x6110, 0x6108,
    0x6104, 0x6102, 0x6101, 0x6280, 0x6240, 0x6220, 0x6210, 0x6208, 0x6204, 0x6202, 0x6201, 0x6380,
    0x6340, 0x6320, 0x6310, 0x6308, 0x6304, 0x6302,
};

BOOL dSv_player_item_c::checkInsectBottle() {
    for (int i = 0; i < 24; i++) {
        if (i_dComIfGs_isItemFirstBit(M_BEETLE + i) &&
            !i_dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[0x191 + i])) {
            return TRUE;
        }
    }
    return FALSE;
}

u8 dSv_player_item_c::checkEmptyBottle() {
    u8 bottleNum = 0;

    for (int i = 0; i < BOTTLE_MAX; i++) {
        if (mItems[i + SLOT_11] == EMPTY_BOTTLE) {
            bottleNum++;
        }
    }
    return bottleNum;
}

void dSv_player_item_c::setBombBagItemIn(u8 i_curBomb, u8 i_newBomb, bool i_setNum) {
    for (int i = 0; i < 3; i++) {
        if (i_curBomb == mItems[i + SLOT_15]) {
            setItem(i + SLOT_15, i_newBomb);

            if (i_setNum == true && i_newBomb != BOMB_BAG_LV1) {
                dComIfGs_setBombNum(i, dComIfGs_getBombMax(i_newBomb));
            }

            for (int j = 0; j < 3; j++) {
                if (i + SLOT_15 == dComIfGs_getSelectItemIndex(j)) {
                    dComIfGp_setSelectItem(j);
                }
            }
            break;
        }
    }
}

void dSv_player_item_c::setBombBagItemIn(u8 i_curBomb, u8 i_newBomb, u8 i_bombNum, bool i_setNum) {
    for (int i = 0; i < 3; i++) {
        if (i_curBomb == mItems[i + SLOT_15]) {
            setItem(i + SLOT_15, i_newBomb);

            if (i_setNum == 1 && i_newBomb != BOMB_BAG_LV1) {
                if (i_bombNum > dComIfGs_getBombMax(i_newBomb)) {
                    i_bombNum = dComIfGs_getBombMax(i_newBomb);
                }
                dComIfGs_setBombNum(i, i_bombNum);
            }

            for (int j = 0; j < 3; j++) {
                if (i + SLOT_15 == dComIfGs_getSelectItemIndex(j)) {
                    dComIfGp_setSelectItem(j);
                }
            }
            break;
        }
    }
}

void dSv_player_item_c::setEmptyBombBagItemIn(u8 i_newBomb, bool i_setNum) {
    setBombBagItemIn(BOMB_BAG_LV1, i_newBomb, i_setNum);
}

void dSv_player_item_c::setEmptyBombBagItemIn(u8 i_newBomb, u8 i_bombNum, bool i_setNum) {
    setBombBagItemIn(BOMB_BAG_LV1, i_newBomb, i_bombNum, i_setNum);
}

void dSv_player_item_c::setEmptyBombBag() {
    for (int i = 0; i < 3; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_15), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_15), BOMB_BAG_LV1);
            return;
        }
    }
}

void dSv_player_item_c::setEmptyBombBag(u8 i_newBomb, u8 i_bombNum) {
    for (int i = 0; i < 3; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_15), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_15), i_newBomb);

            if (i_newBomb == BOMB_BAG_LV1) {
                return;
            }

            if (i_bombNum > dComIfGs_getBombMax(i_newBomb)) {
                i_bombNum = dComIfGs_getBombMax(i_newBomb);
            }

            dComIfGs_setBombNum(i, i_bombNum);
            return;
        }
    }
}

u8 dSv_player_item_c::checkBombBag(u8 i_itemNo) {
    u8 bombBags = 0;

    for (int i = 0; i < BOMB_BAG_MAX; i++) {
        if (i_itemNo == mItems[i + SLOT_15]) {
            bombBags++;
        }
    }
    return bombBags;
}

void dSv_player_item_c::setWarashibeItem(u8 i_itemNo) {
    dComIfGs_setItem(SLOT_21, i_itemNo);
    dComIfGp_setItem(SLOT_21, i_itemNo);

    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getSelectItemIndex((u8)i) == SLOT_21) {
            dComIfGp_setSelectItem((u8)i);
        }
    }
}

void dSv_player_item_c::setRodTypeLevelUp() {
    switch (mItems[SLOT_20]) {
    case BEE_ROD: {
        mItems[SLOT_20] = JEWEL_BEE_ROD;
        break;
    }
    case WORM_ROD: {
        mItems[SLOT_20] = JEWEL_WORM_ROD;
        break;
    }
    case FISHING_ROD_1: {
        mItems[SLOT_20] = JEWEL_ROD;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem(i);
    }
}

void dSv_player_item_c::setBaitItem(u8 i_itemNo) {
    switch (i_itemNo) {
    case BEE_CHILD: {
        i_dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_BEE_ROD :
                                                 mItems[SLOT_20] = BEE_ROD;
        break;
    }
    case WORM: {
        i_dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_WORM_ROD :
                                                 mItems[SLOT_20] = WORM_ROD;
        break;
    }
    case NO_ITEM: {
        i_dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_ROD :
                                                 mItems[SLOT_20] = FISHING_ROD_1;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem(i);
    }
}

void dSv_player_get_item_c::init() {
    for (int i = 0; i < 8; i++) {
        mItemFlags[i] = 0;
    }
}

/* 80033E60-80033E94 02E7A0 0034+00 0/0 3/3 1/1 .text onFirstBit__21dSv_player_get_item_cFUc */
void dSv_player_get_item_c::onFirstBit(u8 i_itemNo) {
    mItemFlags[i_itemNo / 32] |= (1 << (i_itemNo % 32));
}

/* 80033E94-80033EC8 02E7D4 0034+00 0/0 7/7 1/1 .text offFirstBit__21dSv_player_get_item_cFUc */
void dSv_player_get_item_c::offFirstBit(u8 i_itemNo) {
    mItemFlags[i_itemNo / 32] &= ~(1 << (i_itemNo % 32));
}

/* 80033EC8-80033F00 02E808 0038+00 4/4 87/87 2/2 .text isFirstBit__21dSv_player_get_item_cCFUc */
int dSv_player_get_item_c::isFirstBit(u8 i_itemNo) const {
    return mItemFlags[i_itemNo / 32] & (1 << (i_itemNo % 32)) ? TRUE : FALSE;
}

void dSv_player_item_record_c::init() {
    mArrowNum = 0;

    for (int i = 0; i < 3; i++) {
        mBombNum[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mBottleNum[i] = 0;
    }

    mPachinkoNum = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_player_item_record_c::setBombNum(u8 i_bagIdx, u8 i_bombNum) {
    mBombNum[i_bagIdx] = i_bombNum;
}

u8 dSv_player_item_record_c::getBombNum(u8 i_bagIdx) const {
    return mBombNum[i_bagIdx];
}

void dSv_player_item_record_c::setBottleNum(u8 i_bottleIdx, u8 i_bottleNum) {
    mBottleNum[i_bottleIdx] = i_bottleNum;
}

u8 dSv_player_item_record_c::addBottleNum(u8 i_bottleIdx, s16 i_no) {
    int bottleNum = mBottleNum[i_bottleIdx] + i_no;

    dComIfGs_getItem((u8)(i_bottleIdx + SLOT_11), true);

    if (bottleNum < 0) {
        mBottleNum[i_bottleIdx] = 0;
    } else if (bottleNum > dComIfGs_getBottleMax()) {
        mBottleNum[i_bottleIdx] = dComIfGs_getBottleMax();
    } else {
        mBottleNum[i_bottleIdx] = bottleNum;
    }

    return mBottleNum[i_bottleIdx];
}

u8 dSv_player_item_record_c::getBottleNum(u8 i_bottleIdx) const {
    return mBottleNum[i_bottleIdx];
}

void dSv_player_item_max_c::init() {
    for (int i = 0; i < 7; i++) {
        mItemMax[i] = 30;
    }
    setBombNum(NORMAL_BOMB, 30);
    setBombNum(WATER_BOMB, 15);
    setBombNum(POKE_BOMB, 10);
    mItemMax[7] = 0;
}

void dSv_player_item_max_c::setBombNum(u8 i_bombType, u8 i_maxNum) {
    switch (i_bombType) {
    case NORMAL_BOMB:
        mItemMax[NORMAL_BOMB_MAX] = i_maxNum;
        return;
    case WATER_BOMB:
        mItemMax[WATER_BOMB_MAX] = i_maxNum;
        return;
    case POKE_BOMB:
        mItemMax[POKE_BOMB_MAX] = i_maxNum;
        return;
    }
}

u8 dSv_player_item_max_c::getBombNum(u8 i_bombType) const {
    u8 lv_multiplier = 1;
    if (i_dComIfGs_isItemFirstBit(BOMB_BAG_LV2)) {
        lv_multiplier = 2;
    }

    switch (i_bombType) {
    case NORMAL_BOMB:
        return (u8)(mItemMax[NORMAL_BOMB_MAX] * lv_multiplier);
    case WATER_BOMB:
        return (u8)(mItemMax[WATER_BOMB_MAX] * lv_multiplier);
    case POKE_BOMB:
        return (u8)(mItemMax[POKE_BOMB_MAX] * lv_multiplier);
    default:
        return 0;
    }
}

void dSv_player_collect_c::init() {
    for (int i = 0; i < 8; i++) {
        mItem[i] = 0;
    }

    unk8 = 0;
    mCrystal = 0;
    mMirror = 0;
    unk11 = 0xFF;
    mPohNum = 0;
}

void dSv_player_collect_c::setCollect(int i_item_type, u8 i_item) {
    mItem[i_item_type] |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollect(int i_item_type, u8 i_item) const {
    return mItem[i_item_type] & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectCrystal(u8 i_item) {
    mCrystal |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectCrystal(u8 i_item) const {
    return mCrystal & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectMirror(u8 i_item) {
    mMirror |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectMirror(u8 i_item) const {
    return mMirror & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_wolf_c::init() {
    for (int i = 0; i < 3; i++) {
        unk0[i] = 0;
    }

    unk3 = 0;
}

void dSv_light_drop_c::init() {
    for (int i = 0; i < 4; i++) {
        mLightDropNum[i] = 0;
    }

    mLightDropGetFlag = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_light_drop_c::setLightDropNum(u8 i_nowLevel, u8 i_dropNum) {
    if (i_nowLevel < LIGHT_DROP_STAGE || i_nowLevel > 6) {
        mLightDropNum[i_nowLevel] = i_dropNum;
    }
}

u8 dSv_light_drop_c::getLightDropNum(u8 i_nowLevel) const {
    if (i_nowLevel >= LIGHT_DROP_STAGE && i_nowLevel <= 6) {
        return 0;
    }
    return mLightDropNum[i_nowLevel];
}

void dSv_light_drop_c::onLightDropGetFlag(u8 i_nowLevel) {
    if (i_nowLevel < LIGHT_DROP_STAGE || i_nowLevel > 6) {
        mLightDropGetFlag |= (u8)(1 << i_nowLevel);
    }
}

BOOL dSv_light_drop_c::isLightDropGetFlag(u8 i_nowLevel) const {
    if (i_nowLevel >= LIGHT_DROP_STAGE && i_nowLevel <= 6) {
        return 0;
    }
    return mLightDropGetFlag & (u8)(1 << i_nowLevel) ? TRUE : FALSE;
}

void dSv_letter_info_c::init() {
    for (int i = 0; i < 2; i++) {
        mLetterGetFlags[i] = 0;
        mLetterReadFlags[i] = 0;
    }

    for (int i = 0; i < LETTER_INFO_BIT; i++) {
        mGetNumber[i] = 0;
    }
}

void dSv_letter_info_c::onLetterGetFlag(int i_no) {
    mLetterGetFlags[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterGetFlag(int i_no) const {
    return mLetterGetFlags[i_no >> 5] & (1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_letter_info_c::onLetterReadFlag(int i_no) {
    mLetterReadFlags[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterReadFlag(int i_no) const {
    return mLetterReadFlags[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_fishing_info_c::init() {
    for (int i = 0; i < 16; i++) {
        mFishCount[i] = 0;
        mMaxSize[i] = 0;
    }
}

void dSv_fishing_info_c::addFishCount(u8 i_fishIdx) {
    if (mFishCount[i_fishIdx] < 999) {
        mFishCount[i_fishIdx] += 1;
    }
}

void dSv_player_info_c::init() {
    dMeter2Info_getString(0x382, mPlayerName, NULL);  // Link
    dMeter2Info_getString(0x383, mHorseName, NULL);   // Epona

    unk4 = 0;
    unk0 = 0;
    mTotalTime = 0;
    unk16 = 0;
    mDeathCount = 0;
    mClearCount = 0;

    for (int i = 0; i < 5; i++) {
        unk55[i] = 0;
    }
}

void dSv_player_config_c::init() {
    unk0 = 1;

    if (OSGetSoundMode() == SOUND_MODE_MONO) {
        mSoundMode = SOUND_MODE_MONO;
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_MONO);
    } else {
        mSoundMode = SOUND_MODE_STEREO;
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_STEREO);
    }

    mAttentionType = 0;
    mVibration = 1;
    unk4 = 0;
    unk5 = 0;
    mShortCut = 0;
    mCalibrateDist = 350;
    mCalValue = 0;
    mCameraControl = 0;
    mPointer = 1;
}

u32 dSv_player_config_c::checkVibration() const {
    return JUTGamePad::sRumbleSupported & 0x80000000 ? dComIfGp_getNowVibration() : 0;
}

u8 dSv_player_config_c::getSound() {
    return mSoundMode;
}

void dSv_player_config_c::setSound(u8 i_mode) {
    mSoundMode = i_mode;
}

u8 dSv_player_config_c::getVibration() {
    return mVibration;
}

void dSv_player_config_c::setVibration(u8 i_status) {
    mVibration = i_status;
}

void dSv_player_c::init() {
    mPlayerStatusA.init();
    mPlayerStatusB.init();
    mHorsePlace.init();
    mPlayerReturnPlace.init();
    mPlayerFieldLastStayInfo.init();
    mPlayerLastMarkInfo.init();
    mItem.init();
    mGetItem.init();
    mItemRecord.init();
    mItemMax.init();
    mCollect.init();
    mWolf.init();
    mLightDrop.init();
    mLetterInfo.init();
    mFishingInfo.init();
    mPlayerInfo.init();
    mConfig.init();
}

void dSv_memBit_c::init() {
    for (int i = 0; i < 2; i++) {
        mTbox[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mSwitch[i] = 0;
    }

    mItem[0] = 0;
    mKeyNum = 0;
    mDungeonItem = 0;
}

void dSv_memBit_c::onTbox(int i_no) {
    mTbox[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memBit_c::offTbox(int i_no) {
    mTbox[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isTbox(int i_no) const {
    return 1 << (i_no & 0x1f) & mTbox[i_no >> 5] ? TRUE : FALSE;
}

void dSv_memBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}
void dSv_memBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isSwitch(int i_no) const {
    return (mSwitch[i_no >> 5] & 1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

/* 8003488C-800348C4 02F1CC 0038+00 1/1 0/0 0/0 .text            revSwitch__12dSv_memBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_memBit_c::revSwitch(int i_no) {
    u32 tmp = 1 << (i_no & 0x1F);
    mSwitch[i_no >> 5] ^= tmp;
    return mSwitch[i_no >> 5] & tmp ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_memBit_c::revSwitch(int i_no) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__12dSv_memBit_cFi.s"
}
#pragma pop
#endif

void dSv_memBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_memBit_c::isItem(int i_no) const {
    return (mItem[i_no >> 5] & 1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_memBit_c::onDungeonItem(int i_no) {
    mDungeonItem |= (u8)(1 << i_no);
}

s32 dSv_memBit_c::isDungeonItem(int i_no) const {
    return mDungeonItem & (u8)(1 << i_no) ? TRUE : FALSE;
}

void dSv_event_c::init() {
    for (int i = 0; i < MAX_EVENTS; i++) {
        mEvent[i] = 0;
    }
    setInitEventBit__Fv();
}

void dSv_event_c::onEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] |= (u8)i_no;
}

void dSv_event_c::offEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] &= ~(u8)i_no;
}

BOOL dSv_event_c::isEventBit(u16 i_no) const {
    return mEvent[(i_no >> 8)] & (i_no & 0xFF) ? TRUE : FALSE;
}

void dSv_event_c::setEventReg(u16 i_reg, u8 i_no) {
    mEvent[i_reg >> 8] &= ~(u8)i_reg;
    mEvent[i_reg >> 8] |= i_no;
}

u8 dSv_event_c::getEventReg(u16 i_reg) const {
    return (u8)i_reg & mEvent[i_reg >> 8];
}

void dSv_MiniGame_c::init() {
    unk0 = 0;
    for (int i = 0; i < 3; i++) {
        unk1[i] = 0;
    }
    mStarTime = 120000;
    mBalloonScore = 0;
    mRaceGameTime = 0;
    unk16 = 0;
    unk20 = 0;
}

void dSv_memory_c::init() {
    mBit.init();
}

void dSv_memory2_c::init() {
    for (int i = 0; i < 2; i++) {
        mVisitedRoom[i] = 0;
    }
}

void dSv_memory2_c::onVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memory2_c::offVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memory2_c::isVisitedRoom(int i_no) {
    return (1 << (i_no & 0x1F) & mVisitedRoom[i_no >> 5]) ? TRUE : FALSE;
}

bool dSv_danBit_c::init(s8 i_stageNo) {
    if (i_stageNo != mStageNo) {
        mSwitch[0] = 0;
        mSwitch[1] = 0;
        mItem[0] = 0;
        mItem[1] = 0;
        mItem[2] = 0;
        mItem[3] = 0;
        mStageNo = i_stageNo;
        unk1 = 0;

        for (int i = 0; i < 16; i++) {
            unk28[i] = 0xFFFF;
        }

        daObjCarry_c::clrSaveFlag();
        return true;

    } else {
        daObjCarry_c::setSaveFlag();
        return false;
    }
}

void dSv_danBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_danBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_danBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 5] & (1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

BOOL dSv_danBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0x1F);
    mSwitch[i_no >> 5] ^= uVar1;
    return mSwitch[i_no >> 5] & uVar1 ? TRUE : FALSE;
}

void dSv_danBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_danBit_c::isItem(int i_no) const {
    return mItem[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_zoneBit_c::init() {
    for (int i = 0; i < 2; i++) {
        mSwitch[i] = 0;
    }

    for (int i = 0; i < 2; i++) {
        mItem[i] = 0;
    }

    mRoomSwitch = 0;
    mRoomItem = 0;
}

void dSv_zoneBit_c::clearRoomSwitch() {
    mRoomSwitch = 0;
}

void dSv_zoneBit_c::clearRoomItem() {
    mRoomItem = 0;
}

void dSv_zoneBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

void dSv_zoneBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 4] &= ~(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

/* 80034D78-80034DAC 02F6B8 0034+00 1/1 0/0 0/0 .text            revSwitch__13dSv_zoneBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_zoneBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0xF);
    mSwitch[i_no >> 4] ^= uVar1;
    return mSwitch[i_no >> 4] & uVar1 ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_zoneBit_c::revSwitch(int i_no) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__13dSv_zoneBit_cFi.s"
}
#pragma pop
#endif

void dSv_zoneBit_c::onOneSwitch(int i_no) {
    mRoomSwitch |= (u16)(1 << i_no);
}

void dSv_zoneBit_c::offOneSwitch(int i_no) {
    mRoomSwitch &= ~(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneSwitch(int i_no) const {
    return mRoomSwitch & 1 << i_no ? TRUE : FALSE;
}

BOOL dSv_zoneBit_c::revOneSwitch(int i_no) {
    int iVar1 = 1 << i_no;
    mRoomSwitch ^= iVar1;
    return mRoomSwitch & iVar1 ? TRUE : FALSE;
}

void dSv_zoneBit_c::onItem(int i_no) {
    mItem[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isItem(int i_no) const {
    return mItem[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

void dSv_zoneBit_c::onOneItem(int i_no) {
    mRoomItem |= (u16)(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneItem(int i_no) const {
    return mRoomItem & 1 << i_no ? TRUE : FALSE;
}

void dSv_zoneActor_c::init() {
    for (int i = 0; i < 4; i++) {
        mActorFlags[i] = 0;
    }
}

void dSv_zoneActor_c::on(int i_id) {
    mActorFlags[i_id >> 5] |= 1 << (i_id & 0x1F);
}

void dSv_zoneActor_c::off(int i_id) {
    mActorFlags[i_id >> 5] &= ~(1 << (i_id & 0x1F));
}

BOOL dSv_zoneActor_c::is(int i_id) const {
    return mActorFlags[i_id >> 5] & 1 << (i_id & 0x1F) ? TRUE : FALSE;
}

void dSv_zone_c::init(int i_roomNo) {
    mRoomNo = i_roomNo;
    mBit.init();
    mActor.init();
}

void dSv_restart_c::setRoom(const cXyz& i_position, s16 i_angleY, s8 i_roomNo) {
    mRoomNo = i_roomNo;
    mRoomPos = i_position;
    mRoomAngleY = i_angleY;
}

void dSv_turnRestart_c::set(const cXyz& i_position, s16 i_angleY, s8 param_3, u32 i_param) {
    mPosition = i_position;
    mAngleY = i_angleY;
    unk18 = param_3;
    mParam = i_param;
}

void dSv_info_c::init() {
    mSavedata.init();
    mMemory.init();
    initDan(-1);
    initZone();
    mTmp.init();
}

void dSv_save_c::init() {
    mPlayer.init();
    for (int i = 0; i < STAGE_MAX; i++) {
        mSave[i].init();
    }

    for (int i = 0; i < STAGE2_MAX; i++) {
        mSave2[i].init();
    }

    mEvent.init();
    mMiniGame.init();
}

dSv_memory2_c* dSv_save_c::getSave2(int i_stage2No) {
    return &mSave2[i_stage2No];
}

void dSv_info_c::getSave(int i_stageNo) {
    mMemory = mSavedata.getSave(i_stageNo);
}

void dSv_info_c::putSave(int i_stageNo) {
    mSavedata.putSave(i_stageNo, mMemory);
}

void dSv_info_c::initZone() {
    for (int i = 0; i < 0x20; i++) {
        mZone[i].init(-1);
    }
}

u32 dSv_info_c::createZone(int i_roomNo) {
    dSv_zone_c* zone = mZone;
    for (int i = 0; i < 0x20; zone++, i++) {
        if (zone->getRoomNo() < 0) {
            zone->init(i_roomNo);
            return i;
        }
    }
    return -1;
}

void dSv_info_c::onSwitch(int i_no, int i_roomNo) {
    if (i_no == -1 || i_no == 255) {
        return;
    }

    if (i_no < MEMORY_SWITCH) {
        mMemory.getBit().onSwitch(i_no);
    } else if (i_no < (MEMORY_SWITCH + DAN_SWITCH)) {
        mDan.onSwitch(i_no - MEMORY_SWITCH);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH)) {
            mZone[zoneId].getZoneBit().onSwitch(i_no - (MEMORY_SWITCH + DAN_SWITCH));
        } else {
            mZone[zoneId].getZoneBit().onOneSwitch(i_no -
                                                   (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH));
        }
    }
}

void dSv_info_c::offSwitch(int i_no, int i_roomNo) {
    if (i_no == -1 || i_no == 255) {
        return;
    }

    if (i_no < MEMORY_SWITCH) {
        mMemory.getBit().offSwitch(i_no);
    } else if (i_no < (MEMORY_SWITCH + DAN_SWITCH)) {
        mDan.offSwitch(i_no - MEMORY_SWITCH);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH)) {
            mZone[zoneId].getZoneBit().offSwitch(i_no - (MEMORY_SWITCH + DAN_SWITCH));
        } else {
            mZone[zoneId].getZoneBit().offOneSwitch(i_no -
                                                    (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH));
        }
    }
}

BOOL dSv_info_c::isSwitch(int i_no, int i_roomNo) const {
    if (i_no == -1 || i_no == 255) {
        return FALSE;
    }

    if (i_no < MEMORY_SWITCH) {
        return mMemory.getBit().isSwitch(i_no);
    } else if (i_no < (MEMORY_SWITCH + DAN_SWITCH)) {
        return mDan.isSwitch(i_no - MEMORY_SWITCH);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (zoneId < 0 || zoneId >= ZONE_MAX) {
            return FALSE;
        } else {
            if (i_no < (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH)) {
                return mZone[zoneId].getBit().isSwitch(i_no - (MEMORY_SWITCH + DAN_SWITCH));
            } else {
                return mZone[zoneId].getBit().isOneSwitch(
                    i_no - (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH));
            }
        }
    }
}

BOOL dSv_info_c::revSwitch(int i_no, int i_roomNo) {
    if (i_no == -1 || i_no == 255) {
        return FALSE;
    }

    if (i_no < MEMORY_SWITCH) {
        return mMemory.getBit().revSwitch(i_no);
    } else if (i_no < (MEMORY_SWITCH + DAN_SWITCH)) {
        return mDan.revSwitch(i_no - MEMORY_SWITCH);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH)) {
            return mZone[zoneNo].getZoneBit().revSwitch(i_no - (MEMORY_SWITCH + DAN_SWITCH));
        } else {
            return mZone[zoneNo].getZoneBit().revOneSwitch(
                i_no - (MEMORY_SWITCH + DAN_SWITCH + ZONE_SWITCH));
        }
    }
}

void dSv_info_c::onItem(int i_no, int i_roomNo) {
    if (i_no == -1 || i_no == 255) {
        return;
    }

    if (i_no < MEMORY_ITEM) {
        mDan.onItem(i_no);
    } else if (i_no < (MEMORY_ITEM + DAN_ITEM)) {
        mMemory.getBit().onItem(i_no - MEMORY_ITEM);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < (MEMORY_ITEM + DAN_ITEM + ZONE_ITEM)) {
            mZone[zoneNo].getZoneBit().onItem(i_no - (MEMORY_ITEM + DAN_ITEM));
        } else {
            mZone[zoneNo].getZoneBit().onOneItem(i_no - (MEMORY_ITEM + DAN_ITEM + ZONE_ITEM));
        }
    }
}

BOOL dSv_info_c::isItem(int i_no, int i_roomNo) const {
    if (i_no == -1 || i_no == 255) {
        return FALSE;
    }

    if (i_no < MEMORY_ITEM) {
        return mDan.isItem(i_no);
    } else if (i_no < (MEMORY_ITEM + DAN_ITEM)) {
        return mMemory.getBit().isItem(i_no - MEMORY_ITEM);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < (MEMORY_ITEM + DAN_ITEM + ZONE_ITEM)) {
            return mZone[zoneNo].getBit().isItem(i_no - (MEMORY_ITEM + DAN_ITEM));
        } else {
            return mZone[zoneNo].getBit().isOneItem(i_no - (MEMORY_ITEM + DAN_ITEM + ZONE_ITEM));
        }
    }
}

void dSv_info_c::onActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getActor().on(i_id);
}

void dSv_info_c::offActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getActor().off(i_id);
}

BOOL dSv_info_c::isActor(int i_id, int i_roomNo) const {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return FALSE;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    return mZone[zoneNo].getActor().is(i_id);
}

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037925D = "Write size:%d\n";
SECTION_DEAD static char const* const stringBase_8037926C = "SAVE size:%d\n";
#pragma pop

/* 80035798-80035A04 0300D8 026C+00 0/0 1/1 0/0 .text            memory_to_card__10dSv_info_cFPci */
// lots of regalloc issues
#ifdef NONMATCHING
int dSv_info_c::memory_to_card(char* card_ptr, int dataNum) {
    bool lantern_not_recovered = false;
    s32 lantern_stolen;
    s32 lantern_dropped;
    bool phi_r30 = false;
    u16 current_lantern_oil = 0;

    if (!i_dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[226])) {
        lantern_stolen = i_dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[224]);
        lantern_dropped = i_dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[225]);
        dComIfGs_offEventBit(dSv_event_flag_c::saveBitLabels[224]);
        dComIfGs_offEventBit(dSv_event_flag_c::saveBitLabels[225]);
        lantern_not_recovered = true;
    }

    if (i_dComIfGs_isItemFirstBit(KANTERA) && dComIfGs_getItem(SLOT_1, 1) == NO_ITEM) {
        dComIfGs_setItem(SLOT_1, KANTERA);
        current_lantern_oil = dComIfGs_getOil();
        dComIfGs_setOil(dMeter2Info_getOilGaugeBackUp());
        phi_r30 = true;
    }

    char* save_ptr = card_ptr + (dataNum * 0xA94);  // 0xA94 = Quest Log size
    dSv_save_c* savedata = dComIfGs_getSaveData();

    s64 play_time = (OSGetTime() - dComIfGs_getSaveStartTime());
    s64 total_time = (play_time + dComIfGs_getSaveTotalTime()) / (OS_BUS_CLOCK / 4);

    // 3599940 = 999:59 in seconds
    if (total_time < 3599940) {
        savedata->getPlayer().getPlayerInfo().setTotalTime(total_time);
    }
    savedata->getPlayer().getPlayerStatusB().setDateIpl(OSGetTime());

    memcpy(save_ptr, savedata, sizeof(dSv_save_c));
    printf("Write size:%d\n", sizeof(dSv_save_c));

    if (lantern_not_recovered == true) {
        if (lantern_stolen) {
            dComIfGs_onEventBit(dSv_event_flag_c::saveBitLabels[224]);
        }
        if (lantern_dropped) {
            dComIfGs_onEventBit(dSv_event_flag_c::saveBitLabels[225]);
        }
    }

    if (phi_r30 == true) {
        dComIfGs_setItem(SLOT_1, NO_ITEM);
        dComIfGs_setOil(current_lantern_oil);
    }

    printf("SAVE size:%d\n", sizeof(dSv_save_c));
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_info_c::memory_to_card(char* card_ptr, int dataNum) {
    nofralloc
#include "asm/d/save/d_save/memory_to_card__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037927A = "LOAD size:%d\n";
#pragma pop

/* 80035A04-80035BD0 030344 01CC+00 0/0 2/2 0/0 .text            card_to_memory__10dSv_info_cFPci */
// memcpy param loads out of order
#ifdef NONMATCHING
int dSv_info_c::card_to_memory(char* card_ptr, int dataNum) {
    memcpy(dComIfGs_getSaveData(), card_ptr + dataNum * 0xa94, sizeof(dSv_save_c));

    if (OSGetSoundMode() == SOUND_MODE_MONO) {
        g_dComIfG_gameInfo.info.getPlayer().getConfig().setSound(SOUND_MODE_MONO);
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_MONO);
    } else if (g_dComIfG_gameInfo.info.getPlayer().getConfig().getSound() == 2) {
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(2);
    } else {
        g_dComIfG_gameInfo.info.getPlayer().getConfig().setSound(SOUND_MODE_STEREO);
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_STEREO);
    }

    dSv_save_c* savedata = dComIfGs_getSaveData();
    if (savedata->getPlayer().getPlayerStatusA().getLife() < 12) {
        savedata->getPlayer().getPlayerStatusA().setLife(12);
    }

    dComIfGs_setKeyNum(6, 0);

    if (dComIfGs_getItem(SLOT_9, 1) == W_HOOKSHOT) {
        dComIfGs_setItem(SLOT_10, W_HOOKSHOT);
        dComIfGs_setItem(SLOT_9, NO_ITEM);
    }

    if (dComIfGs_getItem(SLOT_9, 1) == HOOKSHOT && dComIfGs_getItem(SLOT_10, 1) == W_HOOKSHOT) {
        dComIfGs_setItem(SLOT_9, NO_ITEM);
    }

    dComIfGs_setLineUpItem();

    u8 save_vibration = savedata->getPlayer().getConfig().getVibration();
    dComIfGp_setNowVibration(save_vibration);

    char* save_stage = g_dComIfG_gameInfo.info.getPlayer().getPlayerReturnPlace().getName();
    dMeter2Info_setSaveStageName(save_stage);

    printf("LOAD size:%d\n", sizeof(dSv_save_c));
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_info_c::card_to_memory(char* card_ptr, int dataNum) {
    nofralloc
#include "asm/d/save/d_save/card_to_memory__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80379288 = "INIT size:%d\n";
/* @stringBase0 padding */
SECTION_DEAD static char const* const pad_80379296 = "\0";
#pragma pop

/* 80035BD0-80035C88 030510 00B8+00 0/0 3/3 0/0 .text            initdata_to_card__10dSv_info_cFPci
 */
#ifdef NONMATCHING
int dSv_info_c::initdata_to_card(char* card_ptr, int dataNum) {
    char* ptr = card_ptr + (dataNum * 0xa94);
    dSv_save_c tmp;

    tmp.init();
    tmp.getPlayer().getPlayerInfo().setPlayerName("");
    tmp.getPlayer().getPlayerInfo().setHorseName("");
    memcpy(&ptr, &tmp, 0x958);
    printf("INIT size:%d\n", 0x958);
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_info_c::initdata_to_card(char* card_ptr, int dataNum){nofralloc
#include "asm/d/save/d_save/initdata_to_card__10dSv_info_cFPci.s"
}
#pragma pop
#endif

u16 const dSv_event_tmp_flag_c::tempBitLabels[185] = {
    0xFFFF, 0xFFFF, 0xFF0F, 0xFEFF, 0x0040, 0xFDFF, 0xFCFF, 0x0020, 0x0080, 0x0010, 0x0008, 0x0004,
    0x0002, 0x0001, 0x0180, 0x0140, 0x0120, 0x0110, 0x0108, 0x0104, 0x0102, 0x0101, 0x0280, 0x0240,
    0x0220, 0x0210, 0x0208, 0x0204, 0x0202, 0x0201, 0x0380, 0x0340, 0x0320, 0x0310, 0xFBFF, 0x0308,
    0x0304, 0x0302, 0x0301, 0x0480, 0x0440, 0x0420, 0x0410, 0x0408, 0x0404, 0x0402, 0x0401, 0x0580,
    0x0540, 0x0520, 0x0510, 0x0508, 0x0504, 0x0502, 0x0501, 0x0680, 0x0640, 0x0620, 0x0610, 0x0608,
    0x0604, 0x0602, 0x0601, 0x0780, 0x0740, 0x0720, 0x0710, 0x0708, 0x0704, 0x0702, 0x0701, 0x0880,
    0x0840, 0x0820, 0x0810, 0x0808, 0x0804, 0x0802, 0x0801, 0x0980, 0x0940, 0x0920, 0x0910, 0x0908,
    0x0904, 0x0902, 0x0901, 0x0A80, 0x0A40, 0x0A20, 0x0A10, 0x0A08, 0x0A04, 0x0A02, 0x0A01, 0x0B80,
    0x0B40, 0x0B20, 0x0B10, 0x0B08, 0x0B04, 0xFAFF, 0xF9FF, 0xF8FF, 0xF7FF, 0xF6FF, 0xF5FF, 0x0B02,
    0x0B01, 0x0C80, 0x0C40, 0x0C20, 0x0C10, 0x0C08, 0xF4FF, 0xF3FF, 0x0C04, 0x0C02, 0x0C01, 0x0D80,
    0x0D40, 0x0D20, 0x0D10, 0x0D08, 0x0D04, 0x0D02, 0x0D01, 0x0E80, 0x0E40, 0x0E20, 0x0E10, 0x0E08,
    0x0E04, 0x0E02, 0x0E01, 0x0F80, 0x0F40, 0x0F20, 0x0F10, 0x0F08, 0x0F04, 0x0F02, 0x0F01, 0x1080,
    0x1040, 0x1020, 0x1010, 0x1008, 0x1004, 0x1002, 0x1001, 0x1180, 0x1140, 0x1120, 0x1110, 0x1108,
    0x1104, 0x1102, 0x1101, 0x1280, 0x1240, 0x1220, 0x1210, 0x1208, 0x1204, 0x1202, 0x1201, 0x1380,
    0x1340, 0x1320, 0x1310, 0x1308, 0x1304, 0x1302, 0x1301, 0x1480, 0x1440, 0x1420, 0x1410, 0x1408,
    0x1404, 0x1402, 0x1401, 0x1580, 0xF2FF};

/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
