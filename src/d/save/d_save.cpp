//
// Generated By: dol2asm
// Translation Unit: d/save/d_save
//

#include "d/save/d_save.h"
#include "Z2AudioLib/Z2AudioMgr.h"
#include "d/com/d_com_inf_game.h"
#include "d/meter/d_meter2_info.h"
#include "dol2asm.h"
#include "dolphin/types.h"

//
// Types:
//

struct daObjCarry_c {
    /* 80031CF8 */ void clrSaveFlag();
    /* 80031D04 */ void setSaveFlag();
};

struct dSv_event_tmp_flag_c {
    static u8 const tempBitLabels[370 + 2 /* padding */];
};

//
// Forward References:
//

extern "C" static void dSv_item_rename__FUc();
extern "C" void init__21dSv_player_status_a_cFv();
extern "C" void setSelectItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getSelectItemIndex__21dSv_player_status_a_cCFi();
extern "C" void setMixItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getMixItemIndex__21dSv_player_status_a_cCFi();
extern "C" void getRupeeMax__21dSv_player_status_a_cCFv();
extern "C" void isMagicFlag__21dSv_player_status_a_cCFUc();
extern "C" void init__21dSv_player_status_b_cFv();
extern "C" void onDarkClearLV__21dSv_player_status_b_cFi();
extern "C" void isDarkClearLV__21dSv_player_status_b_cCFi();
extern "C" void onTransformLV__21dSv_player_status_b_cFi();
extern "C" void isTransformLV__21dSv_player_status_b_cCFi();
extern "C" void init__17dSv_horse_place_cFv();
extern "C" void set__17dSv_horse_place_cFPCcRC4cXyzsSc();
extern "C" void init__25dSv_player_return_place_cFv();
extern "C" void set__25dSv_player_return_place_cFPCcScUc();
extern "C" void init__33dSv_player_field_last_stay_info_cFv();
extern "C" void set__33dSv_player_field_last_stay_info_cFPCcRC4cXyzsScUc();
extern "C" void onRegionBit__33dSv_player_field_last_stay_info_cFi();
extern "C" void isRegionBit__33dSv_player_field_last_stay_info_cCFi();
extern "C" void init__27dSv_player_last_mark_info_cFv();
extern "C" void setWarpItemData__27dSv_player_last_mark_info_cFPCcRC4cXyzsScUcUc();
extern "C" void init__17dSv_player_item_cFv();
extern "C" void setItem__17dSv_player_item_cFiUc();
extern "C" void getItem__17dSv_player_item_cCFib();
extern "C" void setLineUpItem__17dSv_player_item_cFv();
extern "C" void getLineUpItem__17dSv_player_item_cCFi();
extern "C" void setBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEmptyBottleItemIn__17dSv_player_item_cFUc();
extern "C" void setEmptyBottle__17dSv_player_item_cFv();
extern "C" void setEmptyBottle__17dSv_player_item_cFUc();
extern "C" void setEquipBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEquipBottleItemEmpty__17dSv_player_item_cFUc();
extern "C" void checkBottle__17dSv_player_item_cFUc();
extern "C" void checkInsectBottle__17dSv_player_item_cFv();
extern "C" void checkEmptyBottle__17dSv_player_item_cFv();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setEmptyBombBag__17dSv_player_item_cFv();
extern "C" void setEmptyBombBag__17dSv_player_item_cFUcUc();
extern "C" void checkBombBag__17dSv_player_item_cFUc();
extern "C" void setWarashibeItem__17dSv_player_item_cFUc();
extern "C" void setRodTypeLevelUp__17dSv_player_item_cFv();
extern "C" void setBaitItem__17dSv_player_item_cFUc();
extern "C" void init__21dSv_player_get_item_cFv();
extern "C" void onFirstBit__21dSv_player_get_item_cFUc();
extern "C" void offFirstBit__21dSv_player_get_item_cFUc();
extern "C" void isFirstBit__21dSv_player_get_item_cCFUc();
extern "C" void init__24dSv_player_item_record_cFv();
extern "C" void setBombNum__24dSv_player_item_record_cFUcUc();
extern "C" void getBombNum__24dSv_player_item_record_cCFUc();
extern "C" void setBottleNum__24dSv_player_item_record_cFUcUc();
extern "C" void addBottleNum__24dSv_player_item_record_cFUcs();
extern "C" void getBottleNum__24dSv_player_item_record_cCFUc();
extern "C" void init__21dSv_player_item_max_cFv();
extern "C" void setBombNum__21dSv_player_item_max_cFUcUc();
extern "C" void getBombNum__21dSv_player_item_max_cCFUc();
extern "C" void init__20dSv_player_collect_cFv();
extern "C" void setCollect__20dSv_player_collect_cFiUc();
extern "C" void isCollect__20dSv_player_collect_cCFiUc();
extern "C" void onCollectCrystal__20dSv_player_collect_cFUc();
extern "C" void isCollectCrystal__20dSv_player_collect_cCFUc();
extern "C" void onCollectMirror__20dSv_player_collect_cFUc();
extern "C" void isCollectMirror__20dSv_player_collect_cCFUc();
extern "C" void init__17dSv_player_wolf_cFv();
extern "C" void init__16dSv_light_drop_cFv();
extern "C" void setLightDropNum__16dSv_light_drop_cFUcUc();
extern "C" void getLightDropNum__16dSv_light_drop_cCFUc();
extern "C" void onLightDropGetFlag__16dSv_light_drop_cFUc();
extern "C" void isLightDropGetFlag__16dSv_light_drop_cCFUc();
extern "C" void init__17dSv_letter_info_cFv();
extern "C" void onLetterGetFlag__17dSv_letter_info_cFi();
extern "C" void isLetterGetFlag__17dSv_letter_info_cCFi();
extern "C" void onLetterReadFlag__17dSv_letter_info_cFi();
extern "C" void isLetterReadFlag__17dSv_letter_info_cCFi();
extern "C" void init__18dSv_fishing_info_cFv();
extern "C" void addFishCount__18dSv_fishing_info_cFUc();
extern "C" void init__17dSv_player_info_cFv();
extern "C" void init__19dSv_player_config_cFv();
extern "C" void checkVibration__19dSv_player_config_cCFv();
extern "C" void getSound__19dSv_player_config_cFv();
extern "C" void setSound__19dSv_player_config_cFUc();
extern "C" void getVibration__19dSv_player_config_cFv();
extern "C" void setVibration__19dSv_player_config_cFUc();
extern "C" void init__12dSv_player_cFv();
extern "C" void init__12dSv_memBit_cFv();
extern "C" void onTbox__12dSv_memBit_cFi();
extern "C" void offTbox__12dSv_memBit_cFi();
extern "C" void isTbox__12dSv_memBit_cCFi();
extern "C" void onSwitch__12dSv_memBit_cFi();
extern "C" void offSwitch__12dSv_memBit_cFi();
extern "C" void isSwitch__12dSv_memBit_cCFi();
extern "C" void revSwitch__12dSv_memBit_cFi();
extern "C" void onItem__12dSv_memBit_cFi();
extern "C" void isItem__12dSv_memBit_cCFi();
extern "C" void onDungeonItem__12dSv_memBit_cFi();
extern "C" void isDungeonItem__12dSv_memBit_cCFi();
extern "C" void init__11dSv_event_cFv();
extern "C" void onEventBit__11dSv_event_cFUs();
extern "C" void offEventBit__11dSv_event_cFUs();
extern "C" void isEventBit__11dSv_event_cCFUs();
extern "C" void setEventReg__11dSv_event_cFUsUc();
extern "C" void getEventReg__11dSv_event_cCFUs();
extern "C" void init__14dSv_MiniGame_cFv();
extern "C" void init__12dSv_memory_cFv();
extern "C" void init__13dSv_memory2_cFv();
extern "C" void onVisitedRoom__13dSv_memory2_cFi();
extern "C" void offVisitedRoom__13dSv_memory2_cFi();
extern "C" void isVisitedRoom__13dSv_memory2_cFi();
extern "C" void init__12dSv_danBit_cFSc();
extern "C" void onSwitch__12dSv_danBit_cFi();
extern "C" void offSwitch__12dSv_danBit_cFi();
extern "C" void isSwitch__12dSv_danBit_cCFi();
extern "C" void revSwitch__12dSv_danBit_cFi();
extern "C" void onItem__12dSv_danBit_cFi();
extern "C" void isItem__12dSv_danBit_cCFi();
extern "C" void init__13dSv_zoneBit_cFv();
extern "C" void clearRoomSwitch__13dSv_zoneBit_cFv();
extern "C" void clearRoomItem__13dSv_zoneBit_cFv();
extern "C" void onSwitch__13dSv_zoneBit_cFi();
extern "C" void offSwitch__13dSv_zoneBit_cFi();
extern "C" void isSwitch__13dSv_zoneBit_cCFi();
extern "C" void revSwitch__13dSv_zoneBit_cFi();
extern "C" void onOneSwitch__13dSv_zoneBit_cFi();
extern "C" void offOneSwitch__13dSv_zoneBit_cFi();
extern "C" void isOneSwitch__13dSv_zoneBit_cCFi();
extern "C" void revOneSwitch__13dSv_zoneBit_cFi();
extern "C" void onItem__13dSv_zoneBit_cFi();
extern "C" void isItem__13dSv_zoneBit_cCFi();
extern "C" void onOneItem__13dSv_zoneBit_cFi();
extern "C" void isOneItem__13dSv_zoneBit_cCFi();
extern "C" void init__15dSv_zoneActor_cFv();
extern "C" void on__15dSv_zoneActor_cFi();
extern "C" void off__15dSv_zoneActor_cFi();
extern "C" void is__15dSv_zoneActor_cCFi();
extern "C" void init__10dSv_zone_cFi();
extern "C" void setRoom__13dSv_restart_cFRC4cXyzsSc();
extern "C" void set__17dSv_turnRestart_cFRC4cXyzsScUl();
extern "C" void init__10dSv_info_cFv();
extern "C" void init__10dSv_save_cFv();
extern "C" void getSave2__10dSv_save_cFi();
extern "C" void getSave__10dSv_info_cFi();
extern "C" void putSave__10dSv_info_cFi();
extern "C" void initZone__10dSv_info_cFv();
extern "C" void createZone__10dSv_info_cFi();
extern "C" void onSwitch__10dSv_info_cFii();
extern "C" void offSwitch__10dSv_info_cFii();
extern "C" void isSwitch__10dSv_info_cCFii();
extern "C" void revSwitch__10dSv_info_cFii();
extern "C" void onItem__10dSv_info_cFii();
extern "C" void isItem__10dSv_info_cCFii();
extern "C" void onActor__10dSv_info_cFii();
extern "C" void offActor__10dSv_info_cFii();
extern "C" void isActor__10dSv_info_cCFii();
extern "C" void memory_to_card__10dSv_info_cFPci();
extern "C" void card_to_memory__10dSv_info_cFPci();
extern "C" void initdata_to_card__10dSv_info_cFPci();
extern "C" u8 const tempBitLabels__20dSv_event_tmp_flag_c[370 + 2 /* padding */];
extern "C" extern char const* const d_save_d_save__stringBase0;
extern "C" u8 saveBitLabels__16dSv_event_flag_c[1644 + 4 /* padding */];

//
// External References:
//

extern "C" void setNowVibration__14dComIfG_play_cFUc();
extern "C" void getNowVibration__14dComIfG_play_cFv();
extern "C" void getZoneNo__20dStage_roomControl_cFi();
extern "C" void dComIfGs_setSelectItemIndex__FiUc(int, u8);
extern "C" void dComIfGs_setMixItemIndex__FiUc(int, u8);
extern "C" u8 dComIfGs_getMixItemIndex__Fi(int);
extern "C" void dComIfGp_setSelectItem__Fi(int);
extern "C" u8 dComIfGs_getBottleMax__Fv();
extern "C" void dComIfGs_setKeyNum__FiUc();
extern "C" void __ct__13dSv_memory2_cFv();
extern "C" void __ct__12dSv_memory_cFv();
extern "C" void clrSaveFlag__12daObjCarry_cFv();
extern "C" void setSaveFlag__12daObjCarry_cFv();
extern "C" void setInitEventBit__Fv();
extern "C" void getString__13dMeter2Info_cFUlPcP14JMSMesgEntry_c();
extern "C" void setHotSpringTimer__13dMeter2Info_cFUc();
extern "C" void setSaveStageName__13dMeter2Info_cFPCc();
extern "C" void setOutputMode__10Z2AudioMgrFUl();
extern "C" void __construct_array();
extern "C" void _savegpr_22();
extern "C" void _savegpr_26();
extern "C" void _savegpr_27();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_22();
extern "C" void _restgpr_26();
extern "C" void _restgpr_27();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();
extern "C" void __div2i();
extern "C" int printf(char*, ...);
extern "C" u8 mAudioMgrPtr__10Z2AudioMgr[4 + 4 /* padding */];
extern "C" u8 sRumbleSupported__10JUTGamePad[4];

//
// Declarations:
//

inline int dComIfGs_isItemFirstBit(u8 i_no) {
    return g_dComIfG_gameInfo.info.getPlayer().getGetItem().isFirstBit(i_no);
}

static u8 dSv_item_rename(u8 item_id) {
    switch (item_id) {
    case OIL_BOTTLE_2:
        return OIL_BOTTLE;
    case RED_BOTTLE_2:
        return RED_BOTTLE;
    case OIL2:
        return OIL;
    default:
        return item_id;
    }
}

void dSv_player_status_a_c::init() {
    mMaxLife = 15;
    mLife = 12;
    mRupee = 0;
    mMaxOil = 0;
    mOil = 0;
    unk10 = 0;

    for (int i = 0; i < MAX_SELECT_ITEM; i++) {
        mSelectItem[i] = NO_ITEM;
        mMixItem[i] = NO_ITEM;
        dComIfGp_setSelectItem__Fi(i);
    }

    for (int i = 0; i < MAX_EQUIPMENT; i++) {
        mSelectEquip[i] = 0;
    }

    mSelectEquip[COLLECT_CLOTHING] = WEARS_CASUAL;
    mSelectEquip[COLLECT_SWORD] = NO_ITEM;
    mSelectEquip[COLLECT_SHIELD] = NO_ITEM;
    mSelectEquip[COLLECT_SMELL] = NO_ITEM;
    mSelectEquip[B_BUTTON_ITEM] = NO_ITEM;
    mWalletSize = WALLET;
    mMaxMagic = 0;
    mMagic = 0;
    mMagicFlag = 0;
    unk29 = 0;
    mTransformStatus = 0;

    for (int i = 0; i < 3; i++) {
        unk31[i] = 0;
    }
}

void dSv_player_status_a_c::setSelectItemIndex(signed int i_no, u8 item_index) {
    if (i_no < MAX_SELECT_ITEM) {
        mSelectItem[i_no] = item_index;
    }
}

u8 dSv_player_status_a_c::getSelectItemIndex(signed int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mSelectItem[i_no];
    }
    return 0;
}

void dSv_player_status_a_c::setMixItemIndex(signed int i_no, u8 item_index) {
    if (i_no < MAX_SELECT_ITEM) {
        mMixItem[i_no] = item_index;
    }
}

u8 dSv_player_status_a_c::getMixItemIndex(signed int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mMixItem[i_no];
    }
    return 0;
}

u16 dSv_player_status_a_c::getRupeeMax() const {
    if (mWalletSize < 3) {  // if you make this a default, it wont match. Compiler, pls.
        switch (mWalletSize) {
        case WALLET:
            return 300;
        case BIG_WALLET:
            return 600;
        case GIANT_WALLET:
            return 1000;
        }
    }
    return 0;
}

BOOL dSv_player_status_a_c::isMagicFlag(u8 i_magic) const {
    if (i_magic == 0) {
        return dComIfGs_isEventBit(0x2304);
    }
    return (mMagicFlag & (u8)(1 << i_magic)) ? TRUE : FALSE;
}

void dSv_player_status_b_c::init() {
    mDateIpl = 0;
    mTransformLevelFlag = 0;
    mDarkClearLevelFlag = 0;
    unk10 = 0;
    mTime = 255.0f;
    mDate = 0;

    for (int i = 0; i < 3; i++) {
        unk18[i] = 0;
    }
}

void dSv_player_status_b_c::onDarkClearLV(int i_no) {
    mDarkClearLevelFlag |= (u8)(1 << i_no);
}

BOOL dSv_player_status_b_c::isDarkClearLV(int i_no) const {
    return mDarkClearLevelFlag & (u8)(1 << i_no) ? TRUE : FALSE;
}

void dSv_player_status_b_c::onTransformLV(int i_no) {
    mTransformLevelFlag |= (u8)(1 << i_no);
}

BOOL dSv_player_status_b_c::isTransformLV(int i_no) const {
    return mTransformLevelFlag & (u8)(1 << i_no) ? TRUE : FALSE;
}

/* 80451D5C-80451D60 00035C 0004+00 3/3 0/0 0/0 .sdata2          @3813 */
SECTION_SDATA2 static u8 lit_3813[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

void dSv_horse_place_c::init() {
    strcpy(mName, "");
    mPos.set(FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813));
    mAngleY = 0;
    mSpawnId = 0;
    mRoomNo = 0;
}

void dSv_horse_place_c::set(const char* i_name, const cXyz& i_position, s16 i_x_rot,
                            signed char i_room_id) {
    strcpy(mName, i_name);
    mPos = i_position;
    mAngleY = i_x_rot;
    mRoomNo = i_room_id;
}

void dSv_player_return_place_c::init() {
    strcpy(mName, "F_SP108");
    mRoomNo = 1;
    mPlayerStatus = 0;
    unk10 = 21;
    unk11 = 0;
}

void dSv_player_return_place_c::set(const char* i_name, s8 i_room_id, u8 i_spawn_id) {
    strcpy(mName, i_name);
    mRoomNo = i_room_id;
    mPlayerStatus = i_spawn_id;
}

void dSv_player_field_last_stay_info_c::init() {
    strcpy(mName, "");
    mPos.set(FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813));
    mAngleY = 0;
    mLastSpawnId = 0;
    mRegionNo = 1;
    mFieldDataExistFlag = false;
    mRegion = 0;

    for (int i = 0; i < 2; i++) {
        unk26[i] = 0;
    }
}

void dSv_player_field_last_stay_info_c::set(const char* i_name, const cXyz& i_last_position,
                                            s16 i_last_angle, signed char i_last_spawn_id,
                                            u8 i_last_room_id) {
    strcpy(mName, i_name);

    mPos = i_last_position;
    mAngleY = i_last_angle;
    mLastSpawnId = i_last_spawn_id;
    mRegionNo = i_last_room_id;
}

void dSv_player_field_last_stay_info_c::onRegionBit(int i_region_bit) {
    if (i_region_bit < 0) {
        return;
    }
    if (8 <= i_region_bit) {
        return;
    }
    mRegion |= (u8)(1 << i_region_bit);
}

BOOL dSv_player_field_last_stay_info_c::isRegionBit(int i_region_bit) const {
    if ((i_region_bit >= 0) && (i_region_bit < 8)) {
        return (mRegion & (u8)(1 << i_region_bit)) ? TRUE : FALSE;
    }
    return false;
}

void dSv_player_last_mark_info_c::init() {
    strcpy(mName, "");
    mPos.set(FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813), FLOAT_LABEL(lit_3813));
    mAngleY = 0;
    mRoomNo = 0;
    mSpawnId = 0;
    mWarpAcceptStage = -1;

    for (int i = 0; i < 3; i++) {
        unk25[i] = 0;
    }
}

void dSv_player_last_mark_info_c::setWarpItemData(const char* i_ooccoo_stage,
                                                  const cXyz& i_ooccoo_position, s16 i_ooccoo_angle,
                                                  s8 i_ooccoo_room_id, u8 unk1, u8 unk2) {
    strcpy(mName, i_ooccoo_stage);
    mPos.set(i_ooccoo_position);
    mAngleY = i_ooccoo_angle;
    mRoomNo = i_ooccoo_room_id;
}

void dSv_player_item_c::init() {
    for (int i = 0; i < 24; i++) {
        mItems[i] = NO_ITEM;
        mItemSlots[i] = NO_ITEM;
    }
}

void dSv_player_item_c::setItem(int item_slot, u8 item_id) {
    if (item_slot < MAX_ITEM_SLOTS) {
        mItems[item_slot] = item_id;
        setLineUpItem();
    }

    int select_item_index = DEFAULT_SELECT_ITEM_INDEX;

    do {
        if (item_slot == dComIfGs_getSelectItemIndex(select_item_index)) {
            dComIfGp_setSelectItem__Fi(select_item_index);
        }
        select_item_index++;
    } while (select_item_index < MAX_SELECT_ITEM - 1);
}

u8 dSv_player_item_c::getItem(int item_idx, bool isComboItem) const {
    if (item_idx < MAX_ITEM_SLOTS) {
        if (isComboItem) {
            for (int i = 0; i < 2; i++) {
                if ((dComIfGs_getSelectItemIndex(i) == item_idx ||
                     item_idx == dComIfGs_getMixItemIndex__Fi(i)) &&
                    dComIfGs_getMixItemIndex__Fi(i) != NO_ITEM) {
                    u8 item_id_2 = mItems[dComIfGs_getSelectItemIndex(i)];
                    u8 item_id_1 = mItems[dComIfGs_getMixItemIndex__Fi(i)];

                    // Get Bomb arrow check: Bow + Normal Bombs
                    if ((item_id_2 == BOW && item_id_1 == NORMAL_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == NORMAL_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Water Bombs
                    if ((item_id_2 == BOW && item_id_1 == WATER_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == WATER_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Bomblings
                    if ((item_id_2 == BOW && item_id_1 == POKE_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == POKE_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Hawkeye check
                    if ((item_id_2 == BOW && item_id_1 == HAWK_EYE) ||
                        (item_id_1 == BOW && item_id_2 == HAWK_EYE)) {
                        return HAWK_ARROW;
                    }

                    // Get Rod w/ bee larva
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == BEE_CHILD) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == BEE_CHILD)) {
                        return BEE_ROD;
                    }

                    // Get Rod w/ coral earring
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == ZORAS_JEWEL) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == ZORAS_JEWEL)) {
                        return JEWEL_ROD;
                    }

                    // Get Rod w/ worm
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == WORM) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == WORM)) {
                        return WORM_ROD;
                    }

                    if (i == 3) {
                        if (dComIfGs_getSelectItemIndex(i) == 0 &&
                            dComIfGs_getMixItemIndex__Fi(i) == 0) {
                            dComIfGs_setSelectItemIndex__FiUc(i, 0xFF);
                            dComIfGs_setMixItemIndex__FiUc(i, 0xFF);
                            return 0xFF;
                        }
                    }
                    // Uncertain combination item＝＝＝＞%d, %d\n
                    OSReport_Error("合成アイテム不定＝＝＝＞%d, %d\n", item_id_2, item_id_1);
                }
            }
        }
        return mItems[item_idx];
    } else {
        return NO_ITEM;
    }
}

static u8 i_item_lst[23] = {0x0A, 0x08, 0x06, 0x02, 0x09, 0x04, 0x03, 0x00, 0x01, 0x17, 0x14, 0x05,
                            0x0F, 0x10, 0x11, 0x0B, 0x0C, 0x0D, 0x0E, 0x13, 0x12, 0x16, 0x15};

/* 800332F8-80033354 02DC38 005C+00 2/2 0/0 0/0 .text setLineUpItem__17dSv_player_item_cFv */
// this is close
#ifdef NONMATCHING
void dSv_player_item_c::setLineUpItem() {
    int i1 = 0;
    int i2 = 0;

    for (; i1 < 24; i1++) {
        mItemSlots[i1] = NO_ITEM;
    }

    for (int i1 = 0; i1 < 23; i1++) {
        if (mItems[i_item_lst[i1]] != NO_ITEM) {
            mItemSlots[i2] = i_item_lst[i2];
            i2++;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setLineUpItem() {
    nofralloc
#include "asm/d/save/d_save/setLineUpItem__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

u8 dSv_player_item_c::getLineUpItem(int slot_number) const {
    if (slot_number < MAX_ITEM_SLOTS) {
        return mItemSlots[slot_number];
    }
    return NO_ITEM;
}

/* 80033370-80033450 02DCB0 00E0+00 1/1 2/2 0/0 .text setBottleItemIn__17dSv_player_item_cFUcUc */
#ifdef NONMATCHING
void dSv_player_item_c::setBottleItemIn(u8 i_item_id_1, u8 i_item_id_2) {
    u8 current_item_index;
    u8 new_item_index;

    current_item_index = dSv_item_rename(i_item_id_1);
    new_item_index = dSv_item_rename(i_item_id_2);

    for (int i = 0; i < 4; i++) {
        // sanitize input to make sure it's only a bottle
        if (current_item_index == items[i + SLOT_11]) {
            setItem(i + SLOT_11, new_item_index);
            // if hotsprings water, turn on the timer
            if (new_item_index == 107) {
                dMeter2Info_setHotSpringTimer(i + SLOT_11);
            }
            for (int j = 0; j < 4; j++) {
                j = getSelectItemIndex(i);
                if (i + SLOT_11 == j) {
                    dComIfGp_setSelectItem__Fi(j);
                }
            }
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBottleItemIn(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop
#endif

/* 80033450-80033494 02DD90 0044+00 0/0 26/26 0/0 .text
 * setEmptyBottleItemIn__17dSv_player_item_cFUc                 */
// this is 1 instruction off
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBottleItemIn(u8 i_item_id) {
    setBottleItemIn(EMPTY_BOTTLE, dSv_item_rename(i_item_id));
    return;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBottleItemIn(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBottleItemIn__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

void dSv_player_item_c::setEmptyBottle() {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_11), EMPTY_BOTTLE);
            return;
        }
    }
}

void dSv_player_item_c::setEmptyBottle(u8 item_id) {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + SLOT_11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + SLOT_11), item_id);
            return;
        }
    }
}

/* 80033598-800336BC 02DED8 0124+00 1/1 3/3 0/0 .text
 * setEquipBottleItemIn__17dSv_player_item_cFUcUc               */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEquipBottleItemIn(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setEquipBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop

void dSv_player_item_c::setEquipBottleItemEmpty(u8 selected_index) {
    setEquipBottleItemIn(selected_index, EMPTY_BOTTLE);
}

u8 dSv_player_item_c::checkBottle(u8 i_item_id) {
    u8 item_id;
    u8 num_bottles = 0;

    item_id = dSv_item_rename(i_item_id);
    for (int i = 0; i < BOTTLE_MAX; i++) {
        if (item_id == mItems[i + SLOT_11]) {
            num_bottles++;
        }
    }
    return num_bottles;
}

/* ############################################################################################## */
/* 803A7288-803A78F8 0043A8 066C+04 2/2 45/45 148/148 .data saveBitLabels__16dSv_event_flag_c */
u16 dSv_event_flag_c::saveBitLabels[822] = {
    0xFFFF, 0x0080, 0x0040, 0x0020, 0x0010, 0x0008, 0x0004, 0x0002, 0x0001, 0x0180, 0x0140, 0x0120,
    0x0110, 0x0108, 0x0104, 0x0102, 0x0101, 0x0280, 0x0240, 0x0220, 0x0210, 0x0208, 0x0204, 0x0202,
    0x0201, 0x0380, 0x0340, 0x0320, 0x0310, 0x0308, 0x0304, 0x0302, 0x0301, 0x0480, 0x0440, 0x0420,
    0x0410, 0x0408, 0x0404, 0x0402, 0x0401, 0x0580, 0x0540, 0x0520, 0x0510, 0x0508, 0x0504, 0x0502,
    0x0501, 0x0680, 0x0640, 0x0620, 0x0610, 0x0608, 0x0604, 0x0602, 0x0601, 0x0780, 0x0740, 0x0720,
    0x0710, 0x0708, 0x0704, 0x0702, 0x0701, 0x0880, 0x0840, 0x0820, 0x0810, 0x0808, 0x0804, 0x0802,
    0x0801, 0x0980, 0x0940, 0x0920, 0x0910, 0x0908, 0x0904, 0x0902, 0x0901, 0x0A80, 0x0A40, 0x0A20,
    0x0A10, 0x0A08, 0x0A04, 0x0A02, 0x0A01, 0x0B80, 0x0B40, 0x0B20, 0x0B10, 0x0B08, 0x0B04, 0x0B02,
    0x0B01, 0x0C80, 0x0C40, 0x0C20, 0x0C10, 0x0C08, 0x0C04, 0x0C02, 0x0C01, 0x0D80, 0x0D40, 0x0D20,
    0x0D10, 0x0D08, 0x0D04, 0x0D02, 0x0D01, 0x0E80, 0x0E40, 0x0E20, 0x0E10, 0x0E08, 0x0E04, 0x0E02,
    0x0E01, 0x0F80, 0x0F40, 0x0F20, 0x0F10, 0x0F08, 0x0F04, 0x0F02, 0x0F01, 0x1080, 0x1040, 0x1020,
    0x1010, 0x1008, 0x1004, 0x1002, 0x1001, 0x1180, 0x1140, 0x1120, 0x1110, 0x1108, 0x1104, 0x1102,
    0x1101, 0x1280, 0x1240, 0x1220, 0x1210, 0x1208, 0x1204, 0x1202, 0x1201, 0x1380, 0x1340, 0x1320,
    0x1310, 0x1308, 0x1304, 0x1302, 0x1301, 0x1480, 0x1440, 0x1420, 0x1410, 0x1408, 0x1404, 0x1402,
    0x1401, 0x1580, 0x1540, 0x1520, 0x1510, 0x1508, 0x1504, 0x1502, 0x1501, 0x1680, 0x1640, 0x1620,
    0x1610, 0x1608, 0x1604, 0x1602, 0x1601, 0xFF1F, 0x1780, 0x1740, 0x1720, 0x1710, 0x1708, 0x1704,
    0x1702, 0x1701, 0x1880, 0x1840, 0x1820, 0x1810, 0xFEFF, 0xFDFF, 0xFCFF, 0xFBFF, 0x1808, 0x1804,
    0x1802, 0x1801, 0x1980, 0x1940, 0x1920, 0x1910, 0x1908, 0x1904, 0x1902, 0x1901, 0x1A80, 0x1A40,
    0x1A20, 0x1A10, 0x1A08, 0x1A04, 0x1A02, 0x1A01, 0x1B80, 0x1B40, 0x1B20, 0x1B10, 0x1B08, 0x1B04,
    0x1B02, 0x1B01, 0x1C80, 0x1C40, 0x1C20, 0x1C10, 0x1C08, 0x1C04, 0x1C02, 0x1C01, 0x1D80, 0x1D40,
    0x1D20, 0x1D10, 0x1D08, 0x1D04, 0x1D02, 0x1D01, 0x1E80, 0x1E40, 0x1E20, 0x1E10, 0x1E08, 0x1E04,
    0x1E02, 0x1E01, 0x1F80, 0x1F40, 0x1F20, 0x1F10, 0x1F08, 0x1F04, 0x1F02, 0x1F01, 0x2080, 0x2040,
    0x2020, 0x2010, 0x2008, 0x2004, 0x2002, 0x2001, 0x2180, 0x2140, 0x2120, 0x2110, 0x2108, 0x2104,
    0x2102, 0x2101, 0x2280, 0x2240, 0x2220, 0x2210, 0x2208, 0x2204, 0x2202, 0x2201, 0x2380, 0x2340,
    0x2320, 0x2310, 0x2308, 0x2304, 0x2302, 0x2301, 0x2480, 0x2440, 0x2420, 0x2410, 0x2408, 0x2404,
    0x2402, 0x2401, 0x2580, 0x2540, 0x2520, 0x2510, 0x2508, 0x2504, 0x2502, 0x2501, 0x2680, 0x2640,
    0x2620, 0x2610, 0x2608, 0x2604, 0x2602, 0x2601, 0x2780, 0x2740, 0x2720, 0x2710, 0x2708, 0x2704,
    0x2702, 0x2701, 0x2880, 0x2840, 0x2820, 0x2810, 0x2808, 0x2804, 0x2802, 0x2801, 0x2980, 0x2940,
    0x2920, 0x2910, 0x2908, 0x2904, 0x2902, 0x2901, 0x2A80, 0x2A40, 0x2A20, 0x2A10, 0x2A08, 0x2A04,
    0x2A02, 0x2A01, 0x2B80, 0x2B40, 0x2B20, 0x2B10, 0x2B08, 0x2B04, 0x2B02, 0x2B01, 0x2C80, 0x2C40,
    0x2C20, 0x2C10, 0x2C08, 0x2C04, 0x2C02, 0x2C01, 0x2D80, 0x2D40, 0x2D20, 0x2D10, 0x2D08, 0x2D04,
    0x2D02, 0x2D01, 0x2E80, 0x2E40, 0x2E20, 0x2E10, 0x2E08, 0x2E04, 0x2E02, 0x2E01, 0x2F80, 0x2F40,
    0x2F20, 0x2F10, 0x2F08, 0x2F04, 0x2F02, 0x2F01, 0x3080, 0x3040, 0x3020, 0x3010, 0x3008, 0x3004,
    0x3002, 0x3001, 0x3180, 0x3140, 0x3120, 0x3110, 0x3108, 0x3104, 0x3102, 0x3101, 0x3280, 0x3240,
    0x3220, 0x3210, 0x3208, 0x3204, 0x3202, 0x3201, 0x3380, 0x3340, 0x3320, 0x3310, 0x3308, 0x3304,
    0x3302, 0x3301, 0x3480, 0x3440, 0x3420, 0x3410, 0x3408, 0x3404, 0x3402, 0x3401, 0x3580, 0x3540,
    0x3520, 0x3510, 0x3508, 0x3504, 0x3502, 0x3501, 0x3680, 0x3640, 0x3620, 0x3610, 0x3608, 0x3604,
    0x3602, 0x3601, 0x3780, 0x3740, 0x3720, 0x3710, 0x3708, 0xFAFF, 0xF9FF, 0x3704, 0x3702, 0x3701,
    0x3880, 0x3840, 0x3820, 0x3810, 0x3808, 0x3804, 0x3802, 0x3801, 0x3980, 0x3940, 0x3920, 0x3910,
    0x3908, 0x3904, 0x3902, 0x3901, 0x3A80, 0x3A40, 0x3A20, 0x3A10, 0x3A08, 0x3A04, 0x3A02, 0x3A01,
    0x3B80, 0x3B40, 0x3B20, 0x3B10, 0x3B08, 0x3B04, 0x3B02, 0x3B01, 0x3C80, 0x3C40, 0x3C20, 0x3C10,
    0x3C08, 0x3C04, 0x3C02, 0x3C01, 0x3D80, 0x3D40, 0x3D20, 0x3D10, 0x3D08, 0x3D04, 0x3D02, 0x3D01,
    0x3E80, 0x3E40, 0x3E20, 0x3E10, 0x3E08, 0x3E04, 0x3E02, 0xF8FF, 0xF7FF, 0x3E01, 0x3F80, 0x3F40,
    0x3F20, 0x3F10, 0x3F08, 0x3F04, 0x3F02, 0x3F01, 0x4080, 0x4040, 0x4020, 0x4010, 0x4008, 0x4004,
    0x4002, 0x4001, 0x4180, 0x4140, 0x4120, 0x4110, 0x4108, 0x4104, 0x4102, 0x4101, 0x4280, 0x4240,
    0x4220, 0x4210, 0x4208, 0x4204, 0x4202, 0x4201, 0x4380, 0x4340, 0x4320, 0x4310, 0x4308, 0x4304,
    0x4302, 0x4301, 0x4480, 0x4440, 0x4420, 0x4410, 0x4408, 0x4404, 0x4402, 0x4401, 0x4580, 0x4540,
    0x4520, 0x4510, 0x4508, 0x4504, 0x4502, 0x4501, 0x4680, 0x4640, 0x4620, 0x4610, 0x4608, 0x4604,
    0x4602, 0x4601, 0x4780, 0x4740, 0x4720, 0x4710, 0x4708, 0x4704, 0x4702, 0x4701, 0x4880, 0x4840,
    0x4820, 0x4810, 0x4808, 0x4804, 0x4802, 0x4801, 0x4980, 0x4940, 0x4920, 0x4910, 0x4908, 0x4904,
    0x4902, 0x4901, 0xFFFF, 0x4A40, 0x4A20, 0x4A10, 0x4A08, 0x4A04, 0x4A02, 0x4A01, 0x4B80, 0x4B40,
    0x4B20, 0x4B10, 0x4B08, 0x4B04, 0x4B02, 0x4B01, 0x4C80, 0x4C40, 0x4C20, 0x4C10, 0x4C08, 0x4C04,
    0x4C02, 0x4C01, 0x4D80, 0x4D40, 0x4D20, 0x4D10, 0x4D08, 0x4A80, 0x4D04, 0x4D02, 0x4D01, 0x4E80,
    0x4E40, 0x4E20, 0x4E10, 0x4E08, 0x4E04, 0x4E02, 0x4E01, 0x4F80, 0x4F40, 0x4F20, 0x4F10, 0x4F08,
    0x4F04, 0x4F02, 0x4F01, 0x5080, 0x5040, 0x5020, 0x5010, 0x5008, 0x5004, 0x5002, 0x5001, 0x5180,
    0x5140, 0x5120, 0x5110, 0x5108, 0x5104, 0x5102, 0x5101, 0x5280, 0x5240, 0x5220, 0x5210, 0x5208,
    0x5204, 0x5202, 0x5201, 0x5380, 0x5340, 0x5320, 0x5310, 0x5308, 0x5304, 0x5302, 0x5301, 0x5480,
    0x5440, 0x5420, 0x5410, 0x5408, 0x5404, 0x5402, 0x5401, 0x5580, 0x5540, 0x5520, 0x5510, 0x5508,
    0x5504, 0x5502, 0x5501, 0x5680, 0x5640, 0x5620, 0x5610, 0x5608, 0x5604, 0x5602, 0x5601, 0x5780,
    0x5740, 0x5720, 0xF63F, 0xF57F, 0xF47F, 0xF37F, 0xF27F, 0x5710, 0x5708, 0x5704, 0x5702, 0x5701,
    0x5880, 0x5840, 0x5820, 0x5810, 0x5808, 0x5804, 0x5802, 0x5801, 0x5980, 0x5940, 0x5920, 0xF11F,
    0x5910, 0x5908, 0x5904, 0x5902, 0x5901, 0x5A80, 0x5A40, 0x5A20, 0x5A10, 0x5A08, 0x5A04, 0x5A02,
    0x5A01, 0x5B80, 0x5B40, 0x5B20, 0x5B10, 0x5B08, 0x5B04, 0x5B02, 0x5B01, 0x5C80, 0x5C40, 0x5C20,
    0x5C10, 0x5C08, 0x5C04, 0x5C02, 0xF0FF, 0xEFFF, 0xEEFF, 0xEDFF, 0xECFF, 0xEBFF, 0x5C01, 0x5D80,
    0x5D40, 0x5D20, 0x5D10, 0x5D08, 0x5D04, 0x5D02, 0x5D01, 0x5E80, 0x5E40, 0x5E20, 0x5E10, 0x5E08,
    0x5E04, 0x5E02, 0x5E01, 0x5F80, 0x5F40, 0x5F20, 0x5F10, 0x5F08, 0x5F04, 0x5F02, 0x5F01, 0x6080,
    0x6040, 0x6020, 0x6010, 0x6008, 0x6004, 0x6002, 0x6001, 0x6180, 0x6140, 0x6120, 0x6110, 0x6108,
    0x6104, 0x6102, 0x6101, 0x6280, 0x6240, 0x6220, 0x6210, 0x6208, 0x6204, 0x6202, 0x6201, 0x6380,
    0x6340, 0x6320, 0x6310, 0x6308, 0x6304, 0x6302,
};

BOOL dSv_player_item_c::checkInsectBottle() {
    int i = 0;
    int j = 0;
    for (; i < 24; i++) {
        if (dComIfGs_isItemFirstBit(M_BEETLE + i) &&
            !dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[0x191 + i])) {
            return TRUE;
        }
        j += 1;
    }
    return FALSE;
}

u8 dSv_player_item_c::checkEmptyBottle() {
    u8 num = 0;

    for (int i = 0; i < BOTTLE_MAX; i++) {
        // Loop through the bottle slots (11 - 14) and increment counter for every empty bottle
        if (mItems[i + SLOT_11] == EMPTY_BOTTLE) {
            num++;
        }
    }
    return num;
}

/* 80033828-80033910 02E168 00E8+00 1/1 0/0 0/0 .text setBombBagItemIn__17dSv_player_item_cFUcUcb
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBombBagItemIn(u8 param_0, u8 param_1, bool param_2) {
    nofralloc
#include "asm/d/save/d_save/setBombBagItemIn__17dSv_player_item_cFUcUcb.s"
}
#pragma pop

/* 80033910-80033A20 02E250 0110+00 1/1 0/0 0/0 .text
 * setBombBagItemIn__17dSv_player_item_cFUcUcUcb                */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBombBagItemIn(u8 param_0, u8 param_1, u8 param_2, bool param_3) {
    nofralloc
#include "asm/d/save/d_save/setBombBagItemIn__17dSv_player_item_cFUcUcUcb.s"
}
#pragma pop

void dSv_player_item_c::setEmptyBombBagItemIn(u8 param_1, bool param_2) {
    setBombBagItemIn(BOMB_BAG_LV1, param_1, param_2);
}

void dSv_player_item_c::setEmptyBombBagItemIn(u8 param_1, u8 param_2, bool param_3) {
    setBombBagItemIn(BOMB_BAG_LV1, param_1, param_2, param_3);
}

/* 80033A88-80033B08 02E3C8 0080+00 0/0 2/2 0/0 .text setEmptyBombBag__17dSv_player_item_cFv */
// this is a few instructions off
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBombBag() {
    int current_item_index;
    u8 uVar1;

    for (int i = 0; i < 3; i++) {
        current_item_index = (u8)(i + 15);
        uVar1 = getItem(current_item_index, true);

        if (uVar1 == 0xff) {
            setItem(current_item_index, 80);
            return;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBombBag() {
    nofralloc
#include "asm/d/save/d_save/setEmptyBombBag__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

/* 80033B08-80033BEC 02E448 00E4+00 0/0 3/3 0/0 .text setEmptyBombBag__17dSv_player_item_cFUcUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBombBag(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBombBag__17dSv_player_item_cFUcUc.s"
}
#pragma pop

u8 dSv_player_item_c::checkBombBag(u8 param_1) {
    u8 counter = 0;

    for (int i = 0; i < BOMB_BAG_MAX; i++) {
        // Loop through the bomb bag slots (15 - 17) and increment counter for every match
        if (param_1 == mItems[i + SLOT_15]) {
            counter++;
        }
    }
    return counter;
}

void dSv_player_item_c::setWarashibeItem(u8 i_item_id) {
    u32 select_item_index;

    dComIfGs_setItem(SLOT_21, i_item_id);
    dComIfGp_setItem(SLOT_21, i_item_id);

    for (int i = 0; i < 4; i++) {
        select_item_index = dComIfGs_getSelectItemIndex((u8)i);
        if (select_item_index == SLOT_21) {
            dComIfGp_setSelectItem__Fi((u8)i);
        }
    }
}

void dSv_player_item_c::setRodTypeLevelUp() {
    int current_fishing_rod_item_id = mItems[SLOT_20];

    switch (current_fishing_rod_item_id) {
    case BEE_ROD: {
        mItems[SLOT_20] = JEWEL_BEE_ROD;
        break;
    }
    case WORM_ROD: {
        mItems[SLOT_20] = JEWEL_WORM_ROD;
        break;
    }
    case FISHING_ROD_1: {
        mItems[SLOT_20] = JEWEL_ROD;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem__Fi(i);
    }
}

void dSv_player_item_c::setBaitItem(u8 param_1) {
    switch (param_1) {
    case BEE_CHILD: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_BEE_ROD :
                                               mItems[SLOT_20] = BEE_ROD;
        break;
    }
    case WORM: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_WORM_ROD :
                                               mItems[SLOT_20] = WORM_ROD;
        break;
    }
    case NO_ITEM: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_ROD :
                                               mItems[SLOT_20] = FISHING_ROD_1;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem__Fi(i);
    }
}

void dSv_player_get_item_c::init() {
    for (int i = 0; i < 8; i++) {
        mItemFlags[i] = 0;
    }
}

/* 80033E60-80033E94 02E7A0 0034+00 0/0 3/3 1/1 .text onFirstBit__21dSv_player_get_item_cFUc */
// this is a few instructions off
#ifdef NONMATCHING
void dSv_player_get_item_c::onFirstBit(u8 i_itemno) {
    int tmp = (int)i_itemno;
    int tmp2 = (i_itemno >> 3) & 0xE0;
    // int uVar1 = ;
    mItemFlags[tmp2] |= 1 << (tmp & 0x1F);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_get_item_c::onFirstBit(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/onFirstBit__21dSv_player_get_item_cFUc.s"
}
#pragma pop
#endif

/* 80033E94-80033EC8 02E7D4 0034+00 0/0 7/7 1/1 .text offFirstBit__21dSv_player_get_item_cFUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_get_item_c::offFirstBit(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/offFirstBit__21dSv_player_get_item_cFUc.s"
}
#pragma pop

/* 80033EC8-80033F00 02E808 0038+00 4/4 87/87 2/2 .text isFirstBit__21dSv_player_get_item_cCFUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_player_get_item_c::isFirstBit(u8 param_0) const {
    nofralloc
#include "asm/d/save/d_save/isFirstBit__21dSv_player_get_item_cCFUc.s"
}
#pragma pop

void dSv_player_item_record_c::init() {
    mArrowNum = 0;

    for (int i = 0; i < 3; i++) {
        mBombNum[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mBottleNum[i] = 0;
    }

    mPachinkoNum = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_player_item_record_c::setBombNum(u8 i_bagIdx, u8 bag_id) {
    mBombNum[i_bagIdx] = bag_id;
}

u8 dSv_player_item_record_c::getBombNum(u8 i_bagIdx) const {
    return mBombNum[i_bagIdx];
}

void dSv_player_item_record_c::setBottleNum(u8 i_bottleIdx, u8 bottle_num) {
    mBottleNum[i_bottleIdx] = bottle_num;
}

u8 dSv_player_item_record_c::addBottleNum(u8 i_bottleIdx, s16 param_2) {
    int iVar3 = mBottleNum[i_bottleIdx] + param_2;

    dComIfGs_getItem((u8)(i_bottleIdx + 0xB), true);

    if (iVar3 < 0) {
        mBottleNum[i_bottleIdx] = 0;
    } else if (iVar3 > dComIfGs_getBottleMax__Fv()) {
        mBottleNum[i_bottleIdx] = dComIfGs_getBottleMax__Fv();
    } else {
        mBottleNum[i_bottleIdx] = iVar3;
    }
    return mBottleNum[i_bottleIdx];
}

u8 dSv_player_item_record_c::getBottleNum(u8 i_bottleIdx) const {
    return mBottleNum[i_bottleIdx];
}

void dSv_player_item_max_c::init() {
    for (int i = 0; i < 7; i++) {
        mItemMax[i] = 30;
    }
    setBombNum(NORMAL_BOMB, 30);
    setBombNum(WATER_BOMB, 15);
    setBombNum(POKE_BOMB, 10);
    mItemMax[7] = 0;
}

void dSv_player_item_max_c::setBombNum(u8 bomb_id, u8 bomb_max) {
    switch (bomb_id) {
    case NORMAL_BOMB:
        mItemMax[NORMAL_BOMB_MAX] = bomb_max;
        return;
    case WATER_BOMB:
        mItemMax[WATER_BOMB_MAX] = bomb_max;
        return;
    case POKE_BOMB:
        mItemMax[POKE_BOMB_MAX] = bomb_max;
        return;
    }
}

u8 dSv_player_item_max_c::getBombNum(u8 param_1) const {
    u8 iVar3;

    iVar3 = 0x1;
    if (dComIfGs_isItemFirstBit(BOMB_BAG_LV2)) {
        iVar3 = 0x2;
    }

    switch (param_1) {
    case NORMAL_BOMB:
        return (u8)(mItemMax[NORMAL_BOMB_MAX] * iVar3);
    case WATER_BOMB:
        return (u8)(mItemMax[WATER_BOMB_MAX] * iVar3);
    case POKE_BOMB:
        return (u8)(mItemMax[POKE_BOMB_MAX] * iVar3);
    default:
        return 0;
    }
}

void dSv_player_collect_c::init() {
    for (int i = 0; i < 8; i++) {
        mItem[i] = 0;
    }

    unk8 = 0;
    mCrystal = 0;
    mMirror = 0;
    unk11 = 0xFF;
    mPohNum = 0;
}

void dSv_player_collect_c::setCollect(int i_item_type, u8 i_item) {
    mItem[i_item_type] |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollect(int i_item_type, u8 i_item) const {
    return mItem[i_item_type] & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectCrystal(u8 i_item) {
    mCrystal |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectCrystal(u8 i_item) const {
    return mCrystal & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectMirror(u8 i_item) {
    mMirror |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectMirror(u8 i_item) const {
    return mMirror & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_wolf_c::init() {
    for (int i = 0; i < 3; i++) {
        unk0[i] = 0;
    }

    unk3 = 0;
}

void dSv_light_drop_c::init() {
    for (int i = 0; i < 4; i++) {
        mLightDropNum[i] = 0;
    }

    mLightDropGetFlag = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_light_drop_c::setLightDropNum(u8 i_nowLevel, u8 param_2) {
    if ((i_nowLevel < LIGHT_DROP_STAGE) || (i_nowLevel > 6)) {
        mLightDropNum[i_nowLevel] = param_2;
    }
}

u8 dSv_light_drop_c::getLightDropNum(u8 i_nowLevel) const {
    if ((i_nowLevel >= LIGHT_DROP_STAGE) && (i_nowLevel <= 6)) {
        return 0;
    }
    return mLightDropNum[i_nowLevel];
}

void dSv_light_drop_c::onLightDropGetFlag(u8 i_nowLevel) {
    if ((i_nowLevel < LIGHT_DROP_STAGE) || (i_nowLevel > 6)) {
        mLightDropGetFlag |= (u8)(1 << i_nowLevel);
    }
}

BOOL dSv_light_drop_c::isLightDropGetFlag(u8 i_nowLevel) const {
    if ((i_nowLevel >= LIGHT_DROP_STAGE) && (i_nowLevel <= 6)) {
        return 0;
    }
    return mLightDropGetFlag & (u8)(1 << i_nowLevel) ? TRUE : FALSE;
}

void dSv_letter_info_c::init() {
    for (int i = 0; i < 2; i++) {
        mLetterGetFlags[i] = 0;
        mLetterReadFlags[i] = 0;
    }

    for (int i = 0; i < LETTER_INFO_BIT; i++) {
        mGetNumber[i] = 0;
    }
}

void dSv_letter_info_c::onLetterGetFlag(int i_no) {
    mLetterGetFlags[i_no >> 0x5] |= 0x1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterGetFlag(int i_no) const {
    return mLetterGetFlags[i_no >> 0x5] & (1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_letter_info_c::onLetterReadFlag(int i_no) {
    mLetterReadFlags[i_no >> 0x5] |= 0x1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterReadFlag(int i_no) const {
    return mLetterReadFlags[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_fishing_info_c::init() {
    for (int i = 0; i < 16; i++) {
        mFishCount[i] = 0;
        mMaxSize[i] = 0;
    }
}

void dSv_fishing_info_c::addFishCount(u8 fish_index) {
    if (mFishCount[fish_index] < 999) {
        mFishCount[fish_index] += 1;
    }
}

void dSv_player_info_c::init() {
    dMeter2Info_getString(0x382, (char*)mPlayerName, NULL);
    dMeter2Info_getString(0x383, (char*)mHorseName, NULL);

    unk4 = 0;
    unk0 = 0;
    mTotalTime = 0;
    unk16 = 0;
    mDeathCount = 0;
    mClearCount = 0;

    for (int i = 0; i < 5; i++) {
        unk55[i] = 0;
    }
}

void dSv_player_config_c::init() {
    u32 os_soundMode;

    unk0 = 1;
    os_soundMode = OSGetSoundMode();
    if (os_soundMode == SOUND_MODE_MONO) {
        mSoundMode = SOUND_MODE_MONO;
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_MONO);
    } else {
        mSoundMode = SOUND_MODE_STEREO;
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_STEREO);
    }

    mAttentionType = 0;
    mVibration = 1;
    unk4 = 0;
    unk5 = 0;
    mShortCut = 0;
    mCalibrateDist = 350;
    mCalValue = 0;
    mCameraControl = 0;
    mPointer = 1;
}

u32 dSv_player_config_c::checkVibration() const {
    return JUTGamePad::sRumbleSupported & 0x80000000 ? dComIfGp_getNowVibration() : 0;
}

u8 dSv_player_config_c::getSound() {
    return mSoundMode;
}

void dSv_player_config_c::setSound(u8 i_mode) {
    mSoundMode = i_mode;
}

u8 dSv_player_config_c::getVibration() {
    return mVibration;
}

void dSv_player_config_c::setVibration(u8 i_status) {
    mVibration = i_status;
}

void dSv_player_c::init() {
    mPlayerStatusA.init();
    mPlayerStatusB.init();
    mHorsePlace.init();
    mPlayerReturnPlace.init();
    mPlayerFieldLastStayInfo.init();
    mPlayerLastMarkInfo.init();
    mItem.init();
    mGetItem.init();
    mItemRecord.init();
    mItemMax.init();
    mCollect.init();
    mWolf.init();
    mLightDrop.init();
    mLetterInfo.init();
    mFishingInfo.init();
    mPlayerInfo.init();
    mConfig.init();
}

void dSv_memBit_c::init() {
    for (int i = 0; i < 2; i++) {
        mTbox[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mSwitch[i] = 0;
    }

    mItem[0] = 0;
    mKeyNum = 0;
    mDungeonItem = 0;
}

void dSv_memBit_c::onTbox(int i_no) {
    mTbox[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memBit_c::offTbox(int i_no) {
    mTbox[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isTbox(int i_no) const {
    return 1 << (i_no & 0x1f) & mTbox[i_no >> 0x5] ? TRUE : FALSE;
}

void dSv_memBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}
void dSv_memBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isSwitch(int i_no) const {
    return (mSwitch[i_no >> 0x5] & 0x1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

/* 8003488C-800348C4 02F1CC 0038+00 1/1 0/0 0/0 .text            revSwitch__12dSv_memBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_memBit_c::revSwitch(int i_no) {
    unsigned int tmp = 1 << (i_no & 0x1F);
    (mTbox + (i_no >> 0x5))[0x2] ^= tmp;
    return (mTbox + (i_no >> 0x5))[0x2] & tmp ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_memBit_c::revSwitch(int param_0) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__12dSv_memBit_cFi.s"
}
#pragma pop
#endif

void dSv_memBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_memBit_c::isItem(int i_no) const {
    return (mItem[i_no >> 0x5] & 1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_memBit_c::onDungeonItem(int i_no) {
    mDungeonItem |= (u8)(1 << i_no);
}

bool dSv_memBit_c::isDungeonItem(int i_no) const {
    return mDungeonItem & (u8)(1 << i_no) ? true : false;
}

void dSv_event_c::init() {
    for (int i = 0; i < MAX_EVENTS; i++) {
        mEvent[i] = 0;
    }
    setInitEventBit__Fv();
}

void dSv_event_c::onEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] |= (u8)i_no;
}

void dSv_event_c::offEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] &= ~(u8)i_no;
}

BOOL dSv_event_c::isEventBit(u16 i_no) const {
    return mEvent[(i_no >> 8)] & (i_no & 0xFF) ? TRUE : FALSE;
}

void dSv_event_c::setEventReg(u16 param_1, u8 param_2) {
    u8 uVar1 = (param_1 >> 8);
    mEvent[uVar1] &= ~(u8)param_1;
    mEvent[uVar1] |= param_2;
}

u8 dSv_event_c::getEventReg(u16 param_1) const {
    return (u8)param_1 & mEvent[param_1 >> 8];
}

void dSv_MiniGame_c::init() {
    unk0 = 0;
    for (int i = 0; i < 3; i++) {
        unk1[i] = 0;
    }
    mStarTime = 120000;
    mBalloonScore = 0;
    mRaceGameTime = 0;
    unk16 = 0;
    unk20 = 0;
}

void dSv_memory_c::init() {
    mBit.init();
}

void dSv_memory2_c::init() {
    for (int i = 0; i < 2; i++) {
        mVisitedRoom[i] = 0;
    }
}

void dSv_memory2_c::onVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memory2_c::offVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memory2_c::isVisitedRoom(int param_1) {
    return (1 << (param_1 & 0x1F) & mVisitedRoom[param_1 >> 5]) ? TRUE : FALSE;
}

bool dSv_danBit_c::init(s8 i_stage) {
    if (i_stage != mStageNo) {
        mSwitch[0] = 0;
        mSwitch[1] = 0;
        mItem[0] = 0;
        mItem[1] = 0;
        mItem[2] = 0;
        mItem[3] = 0;
        mStageNo = i_stage;
        unk1 = 0;

        for (int i = 0; i < 16; i++) {
            unk28[i] = 0xFFFF;
        }

        clrSaveFlag__12daObjCarry_cFv();
        return true;

    } else {
        setSaveFlag__12daObjCarry_cFv();
        return false;
    }
}

void dSv_danBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_danBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_danBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 0x5] & (0x1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

BOOL dSv_danBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0x1F);
    mSwitch[i_no >> 5] ^= uVar1;
    return mSwitch[i_no >> 5] & uVar1 ? TRUE : FALSE;
}

void dSv_danBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_danBit_c::isItem(int i_no) const {
    return mItem[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_zoneBit_c::init() {
    for (int i = 0; i < 2; i++) {
        mSwitch[i] = 0;
    }

    for (int i = 0; i < 2; i++) {
        mItem[i] = 0;
    }

    mRoomSwitch = 0;
    mRoomItem = 0;
}

void dSv_zoneBit_c::clearRoomSwitch() {
    mRoomSwitch = 0;
}

void dSv_zoneBit_c::clearRoomItem() {
    mRoomItem = 0;
}

void dSv_zoneBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

void dSv_zoneBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 4] &= ~(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

/* 80034D78-80034DAC 02F6B8 0034+00 1/1 0/0 0/0 .text            revSwitch__13dSv_zoneBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_zoneBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0xF);
    switch_bitfield[i_no >> 4] ^= uVar1;
    return switch_bitfield[i_no >> 4] & uVar1 ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_zoneBit_c::revSwitch(int param_0) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__13dSv_zoneBit_cFi.s"
}
#pragma pop
#endif

void dSv_zoneBit_c::onOneSwitch(int i_no) {
    mRoomSwitch |= (u16)(1 << i_no);
}

void dSv_zoneBit_c::offOneSwitch(int i_no) {
    mRoomSwitch &= ~(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneSwitch(int i_no) const {
    return mRoomSwitch & 1 << i_no ? TRUE : FALSE;
}

BOOL dSv_zoneBit_c::revOneSwitch(int i_no) {
    int iVar1 = 1 << i_no;
    mRoomSwitch ^= iVar1;
    return mRoomSwitch & iVar1 ? TRUE : FALSE;
}

void dSv_zoneBit_c::onItem(int i_no) {
    mItem[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isItem(int i_no) const {
    return mItem[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

void dSv_zoneBit_c::onOneItem(int i_no) {
    mRoomItem |= (u16)(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneItem(int i_no) const {
    return mRoomItem & 1 << i_no ? TRUE : FALSE;
}

void dSv_zoneActor_c::init() {
    for (int i = 0; i < 4; i++) {
        mActorFlags[i] = 0;
    }
}

void dSv_zoneActor_c::on(int i_id) {
    mActorFlags[i_id >> 5] |= 1 << (i_id & 0x1F);
}

void dSv_zoneActor_c::off(int i_id) {
    mActorFlags[i_id >> 5] &= ~(1 << (i_id & 0x1F));
}

BOOL dSv_zoneActor_c::is(int i_id) const {
    return mActorFlags[i_id >> 5] & 1 << (i_id & 0x1F) ? TRUE : FALSE;
}

void dSv_zone_c::init(int i_roomNo) {
    mRoomNo = i_roomNo;
    mBit.init();
    mActor.init();
}

void dSv_restart_c::setRoom(const cXyz& i_position, s16 i_angleY, s8 i_roomNo) {
    mRoomNo = i_roomNo;
    mRoomPos = i_position;
    mRoomAngleY = i_angleY;
}

void dSv_turnRestart_c::set(const cXyz& i_position, s16 i_angleY, s8 param_3, u32 i_param) {
    mPosition = i_position;
    mAngleY = i_angleY;
    unk18 = param_3;
    mParam = i_param;
}

void dSv_info_c::init() {
    mSavedata.init();
    mMemory.init();
    initDan(-1);
    initZone();
    mTmp.init();
}

void dSv_save_c::init() {
    mPlayer.init();
    for (int i = 0; i < STAGE_MAX; i++) {
        mSave[i].init();
    }

    for (int i = 0; i < STAGE2_MAX; i++) {
        mSave2[i].init();
    }

    mEvent.init();
    mMiniGame.init();
}

dSv_memory2_c* dSv_save_c::getSave2(int i_stage2No) {
    return &mSave2[i_stage2No];
}

void dSv_info_c::getSave(int i_stageNo) {
    mMemory = mSavedata.getSave(i_stageNo);
}

void dSv_info_c::putSave(int i_stageNo) {
    mSavedata.putSave(i_stageNo, mMemory);
}

void dSv_info_c::initZone() {
    for (int i = 0; i < 0x20; i++) {
        mZone[i].init(-1);
    }
}

u32 dSv_info_c::createZone(int param_1) {
    dSv_zone_c* zone = mZone;
    for (int i = 0; i < 0x20; zone++, i++) {
        if (zone->getRoomNo() < 0) {
            zone->init(param_1);
            return i;
        }
    }
    return -1;
}

void dSv_info_c::onSwitch(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mMemory.getBit().onSwitch(i_no);
    } else if (i_no < 0xc0) {
        mDan.onSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            mZone[zoneId].getZoneBit().onSwitch(i_no - 0xC0);
        } else {
            mZone[zoneId].getZoneBit().onOneSwitch(i_no - 0xE0);
        }
    }
}

void dSv_info_c::offSwitch(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mMemory.getBit().offSwitch(i_no);
    } else if (i_no < 0xc0) {
        mDan.offSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            mZone[zoneId].getZoneBit().offSwitch(i_no - 0xC0);
        } else {
            mZone[zoneId].getZoneBit().offOneSwitch(i_no - 0xE0);
        }
    }
}

BOOL dSv_info_c::isSwitch(int i_no, int i_roomNo) const {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mMemory.getBit().isSwitch(i_no);
    } else if (i_no < 0xc0) {
        value = mDan.isSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if ((zoneId < 0) || (zoneId >= 0x20)) {
            value = FALSE;
        } else {
            if (i_no < 0xE0) {
                value = mZone[zoneId].getBit().isSwitch(i_no - 0xC0);
            } else {
                value = mZone[zoneId].getBit().isOneSwitch(i_no - 0xE0);
            }
        }
    }
    return value;
}

BOOL dSv_info_c::revSwitch(int i_no, int i_roomNo) {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mMemory.getBit().revSwitch(i_no);
    } else if (i_no < 0xC0) {
        value = mDan.revSwitch(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            value = mZone[zoneNo].getZoneBit().revSwitch(i_no - 0xC0);
        } else {
            value = mZone[zoneNo].getZoneBit().revOneSwitch(i_no - 0xE0);
        }
    }

    return value;
}

void dSv_info_c::onItem(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mDan.onItem(i_no);
    } else if (i_no < 0xA0) {
        mMemory.getBit().onItem(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xC0) {
            mZone[zoneNo].getZoneBit().onItem(i_no - 0xA0);
        } else {
            mZone[zoneNo].getZoneBit().onOneItem(i_no - 0xC0);
        }
    }
}

BOOL dSv_info_c::isItem(int i_no, int i_roomNo) const {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mDan.isItem(i_no);
    } else if (i_no < 0xA0) {
        value = mMemory.getBit().isItem(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xC0) {
            value = mZone[zoneNo].getBit().isItem(i_no - 0xA0);
        } else {
            value = mZone[zoneNo].getBit().isOneItem(i_no - 0xC0);
        }
    }

    return value;
}

void dSv_info_c::onActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getActor().on(i_id);
}

void dSv_info_c::offActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getActor().off(i_id);
}

BOOL dSv_info_c::isActor(int i_id, int i_roomNo) const {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return FALSE;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    return mZone[zoneNo].getActor().is(i_id);
}

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037925D = "Write size:%d\n";
SECTION_DEAD static char const* const stringBase_8037926C = "SAVE size:%d\n";
#pragma pop

/* 80035798-80035A04 0300D8 026C+00 0/0 1/1 0/0 .text            memory_to_card__10dSv_info_cFPci */
// few wrong instructions, lots of regalloc issues
#ifdef NONMATCHING
int dSv_info_c::memory_to_card(char* param_0, int param_1) {
    BOOL bVar1 = FALSE;
    u32 unaff27;
    int unaff23;
    int unkr27 = 0;
    u16 current_lantern_oil = 0;

    if (!dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[226])) {
        unaff27 = dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[224]);
        unaff23 = dComIfGs_isEventBit(dSv_event_flag_c::saveBitLabels[225]);
        dComIfGs_offEventBit(dSv_event_flag_c::saveBitLabels[224]);
        dComIfGs_offEventBit(dSv_event_flag_c::saveBitLabels[225]);
        unkr27 = 1;
    }

    if (dComIfGs_isItemFirstBit(KANTERA) && dComIfGs_getItem(1, 1) == 0xFF) {
        dComIfGs_setItem(SLOT_1, KANTERA);
        current_lantern_oil = dComIfGs_getOil();
        u16 oil_gauge_backup = dMeter2Info_getOilGaugeBackUp();
        dComIfGs_setOil(oil_gauge_backup);
        bVar1 = TRUE;
    }

    char* ptr = param_0 + param_1 * 0xa94;

    // weird time stuff going on here. not really sure about any of it
    s64 start_time = dComIfGs_getSaveStartTime();
    s64 new_time = OSGetTime() - start_time;
    // new_time = 0;
    s64 ivar7 = new_time + start_time;

    s64 total_time = dComIfGs_getSaveTotalTime();
    new_time += total_time;

    if (new_time < start_time) {
        g_dComIfG_gameInfo.info.getPlayer().getPlayerInfo().setTotalTime(new_time);
    }

    s64 tmp = OSGetTime();
    g_dComIfG_gameInfo.info.getPlayer().getPlayerStatusB().setDateIpl(tmp);
    memcpy(ptr, &g_dComIfG_gameInfo, sizeof(dSv_save_c));
    printf("Write size:%d\n", sizeof(dSv_save_c));

    if ((u8)unkr27 == 1) {
        if (unaff27) {
            dComIfGs_onEventBit(dSv_event_flag_c::saveBitLabels[224]);
        }
        if ((u8)unaff23 != 0) {
            dComIfGs_onEventBit(dSv_event_flag_c::saveBitLabels[225]);
        }
    }

    if (!bVar1) {
        dComIfGs_setItem(SLOT_1, NO_ITEM);
        dComIfGs_setOil(current_lantern_oil);
    }

    printf("SAVE size:%d\n", sizeof(dSv_save_c));
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_info_c::memory_to_card(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/memory_to_card__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037927A = "LOAD size:%d\n";
#pragma pop

/* 80035A04-80035BD0 030344 01CC+00 0/0 2/2 0/0 .text            card_to_memory__10dSv_info_cFPci */
// close, some instructions out of order / regalloc
#ifdef NONMATCHING
int dSv_info_c::card_to_memory(char* param_0, int param_1) {
    char* ptr = param_0 + param_1 * 0xa94;
    dSv_save_c* tmp = &g_dComIfG_gameInfo.info.getSavedata();
    memcpy(tmp, ptr, sizeof(dSv_save_c));

    if (!OSGetSoundMode()) {
        g_dComIfG_gameInfo.info.getPlayer().getConfig().setSound(SOUND_MODE_MONO);
        Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_MONO);
    } else {
        u8 save_sound = g_dComIfG_gameInfo.info.getPlayer().getConfig().getSound();

        if (save_sound == 2) {
            Z2AudioMgr::mAudioMgrPtr->setOutputMode(2);
        } else {
            g_dComIfG_gameInfo.info.getPlayer().getConfig().setSound(SOUND_MODE_STEREO);
            Z2AudioMgr::mAudioMgrPtr->setOutputMode(SOUND_MODE_STEREO);
        }
    }

    if (dComIfGs_getSaveData().getPlayer().getPlayerStatusA().getLife() < 12) {
        dComIfGs_setLife(12);
    }

    dComIfGs_setKeyNum(6, 0);

    if (dComIfGs_getItem(SLOT_9, 1) == W_HOOKSHOT) {
        dComIfGs_setItem(SLOT_10, W_HOOKSHOT);
        dComIfGs_setItem(SLOT_9, NO_ITEM);
    }

    if (dComIfGs_getItem(SLOT_9, 1) == HOOKSHOT && dComIfGs_getItem(SLOT_9, 1) == W_HOOKSHOT) {
        dComIfGs_setItem(SLOT_9, NO_ITEM);
    }

    dComIfGs_setLineUpItem();

    u8 save_vibration = dComIfGs_getSaveData().getPlayer().getConfig().getVibration();
    dComIfGp_setNowVibration(save_vibration);

    char* save_stage = dComIfGs_getSaveData().getPlayer().getPlayerReturnPlace().getName();
    dMeter2Info_setSaveStageName(save_stage);

    printf("LOAD size:%d\n", sizeof(dSv_save_c));
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_info_c::card_to_memory(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/card_to_memory__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80379288 = "INIT size:%d\n";
/* @stringBase0 padding */
SECTION_DEAD static char const* const pad_80379296 = "\0";
#pragma pop

/* 80035BD0-80035C88 030510 00B8+00 0/0 3/3 0/0 .text            initdata_to_card__10dSv_info_cFPci
 */
#ifdef NONMATCHING
void dSv_info_c::initdata_to_card(char* param_0, int fileNo) {
    dSv_save_c tmp;

    tmp.init();
    tmp.getPlayer().getPlayerInfo().setPlayerName("");
    tmp.getPlayer().getPlayerInfo().setHorseName("");
    memcpy(&param_0 + fileNo * 0xa94, &tmp, 0x958);
    printf("INIT size:%d\n", 0x958);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::initdata_to_card(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/initdata_to_card__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 803790C0-80379234 005720 0172+02 0/0 17/17 7/7 .rodata tempBitLabels__20dSv_event_tmp_flag_c */
SECTION_RODATA u8 const dSv_event_tmp_flag_c::tempBitLabels[370 + 2 /* padding */] = {
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x0F,
    0xFE,
    0xFF,
    0x00,
    0x40,
    0xFD,
    0xFF,
    0xFC,
    0xFF,
    0x00,
    0x20,
    0x00,
    0x80,
    0x00,
    0x10,
    0x00,
    0x08,
    0x00,
    0x04,
    0x00,
    0x02,
    0x00,
    0x01,
    0x01,
    0x80,
    0x01,
    0x40,
    0x01,
    0x20,
    0x01,
    0x10,
    0x01,
    0x08,
    0x01,
    0x04,
    0x01,
    0x02,
    0x01,
    0x01,
    0x02,
    0x80,
    0x02,
    0x40,
    0x02,
    0x20,
    0x02,
    0x10,
    0x02,
    0x08,
    0x02,
    0x04,
    0x02,
    0x02,
    0x02,
    0x01,
    0x03,
    0x80,
    0x03,
    0x40,
    0x03,
    0x20,
    0x03,
    0x10,
    0xFB,
    0xFF,
    0x03,
    0x08,
    0x03,
    0x04,
    0x03,
    0x02,
    0x03,
    0x01,
    0x04,
    0x80,
    0x04,
    0x40,
    0x04,
    0x20,
    0x04,
    0x10,
    0x04,
    0x08,
    0x04,
    0x04,
    0x04,
    0x02,
    0x04,
    0x01,
    0x05,
    0x80,
    0x05,
    0x40,
    0x05,
    0x20,
    0x05,
    0x10,
    0x05,
    0x08,
    0x05,
    0x04,
    0x05,
    0x02,
    0x05,
    0x01,
    0x06,
    0x80,
    0x06,
    0x40,
    0x06,
    0x20,
    0x06,
    0x10,
    0x06,
    0x08,
    0x06,
    0x04,
    0x06,
    0x02,
    0x06,
    0x01,
    0x07,
    0x80,
    0x07,
    0x40,
    0x07,
    0x20,
    0x07,
    0x10,
    0x07,
    0x08,
    0x07,
    0x04,
    0x07,
    0x02,
    0x07,
    0x01,
    0x08,
    0x80,
    0x08,
    0x40,
    0x08,
    0x20,
    0x08,
    0x10,
    0x08,
    0x08,
    0x08,
    0x04,
    0x08,
    0x02,
    0x08,
    0x01,
    0x09,
    0x80,
    0x09,
    0x40,
    0x09,
    0x20,
    0x09,
    0x10,
    0x09,
    0x08,
    0x09,
    0x04,
    0x09,
    0x02,
    0x09,
    0x01,
    0x0A,
    0x80,
    0x0A,
    0x40,
    0x0A,
    0x20,
    0x0A,
    0x10,
    0x0A,
    0x08,
    0x0A,
    0x04,
    0x0A,
    0x02,
    0x0A,
    0x01,
    0x0B,
    0x80,
    0x0B,
    0x40,
    0x0B,
    0x20,
    0x0B,
    0x10,
    0x0B,
    0x08,
    0x0B,
    0x04,
    0xFA,
    0xFF,
    0xF9,
    0xFF,
    0xF8,
    0xFF,
    0xF7,
    0xFF,
    0xF6,
    0xFF,
    0xF5,
    0xFF,
    0x0B,
    0x02,
    0x0B,
    0x01,
    0x0C,
    0x80,
    0x0C,
    0x40,
    0x0C,
    0x20,
    0x0C,
    0x10,
    0x0C,
    0x08,
    0xF4,
    0xFF,
    0xF3,
    0xFF,
    0x0C,
    0x04,
    0x0C,
    0x02,
    0x0C,
    0x01,
    0x0D,
    0x80,
    0x0D,
    0x40,
    0x0D,
    0x20,
    0x0D,
    0x10,
    0x0D,
    0x08,
    0x0D,
    0x04,
    0x0D,
    0x02,
    0x0D,
    0x01,
    0x0E,
    0x80,
    0x0E,
    0x40,
    0x0E,
    0x20,
    0x0E,
    0x10,
    0x0E,
    0x08,
    0x0E,
    0x04,
    0x0E,
    0x02,
    0x0E,
    0x01,
    0x0F,
    0x80,
    0x0F,
    0x40,
    0x0F,
    0x20,
    0x0F,
    0x10,
    0x0F,
    0x08,
    0x0F,
    0x04,
    0x0F,
    0x02,
    0x0F,
    0x01,
    0x10,
    0x80,
    0x10,
    0x40,
    0x10,
    0x20,
    0x10,
    0x10,
    0x10,
    0x08,
    0x10,
    0x04,
    0x10,
    0x02,
    0x10,
    0x01,
    0x11,
    0x80,
    0x11,
    0x40,
    0x11,
    0x20,
    0x11,
    0x10,
    0x11,
    0x08,
    0x11,
    0x04,
    0x11,
    0x02,
    0x11,
    0x01,
    0x12,
    0x80,
    0x12,
    0x40,
    0x12,
    0x20,
    0x12,
    0x10,
    0x12,
    0x08,
    0x12,
    0x04,
    0x12,
    0x02,
    0x12,
    0x01,
    0x13,
    0x80,
    0x13,
    0x40,
    0x13,
    0x20,
    0x13,
    0x10,
    0x13,
    0x08,
    0x13,
    0x04,
    0x13,
    0x02,
    0x13,
    0x01,
    0x14,
    0x80,
    0x14,
    0x40,
    0x14,
    0x20,
    0x14,
    0x10,
    0x14,
    0x08,
    0x14,
    0x04,
    0x14,
    0x02,
    0x14,
    0x01,
    0x15,
    0x80,
    0xF2,
    0xFF,
    /* padding */
    0x00,
    0x00,
};
COMPILER_STRIP_GATE(0x803790C0, &dSv_event_tmp_flag_c::tempBitLabels);

/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
