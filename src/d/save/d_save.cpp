//
// Generated By: dol2asm
// Translation Unit: d/save/d_save
//

#include "d/save/d_save.h"
#include "dol2asm.h"
#include "dolphin/types.h"
#include "msl_c/string.h"

//
// Types:
//

struct daObjCarry_c {
    /* 80031CF8 */ void clrSaveFlag();
    /* 80031D04 */ void setSaveFlag();
};

struct dSv_event_tmp_flag_c {
    static u8 const tempBitLabels[370 + 2 /* padding */];
};

struct dSv_event_flag_c {
    static u8 saveBitLabels[1644 + 4 /* padding */];
};

struct dStage_roomControl_c {
    /* 8002D9B0 */ static int getZoneNo(int);
};

struct JMSMesgEntry_c {};

struct dMeter2Info_c {
    /* 8021C250 */ void getString(u32, char*, JMSMesgEntry_c*);
    /* 8021DCC4 */ void setHotSpringTimer(u8);
    /* 8021E290 */ void setSaveStageName(char const*);
};

struct dComIfG_play_c {
    /* 8002B3B0 */ void getNowVibration();
};

struct Z2AudioMgr {
    /* 802CD888 */ void setOutputMode(u32);

    static u8 mAudioMgrPtr[4 + 4 /* padding */];
};

struct JUTGamePad {
    static u8 sRumbleSupported[4];
};

//
// Forward References:
//

extern "C" static void dSv_item_rename__FUc();
extern "C" void init__21dSv_player_status_a_cFv();
extern "C" void setSelectItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getSelectItemIndex__21dSv_player_status_a_cCFi();
extern "C" void setMixItemIndex__21dSv_player_status_a_cFiUc();
extern "C" void getMixItemIndex__21dSv_player_status_a_cCFi();
extern "C" void getRupeeMax__21dSv_player_status_a_cCFv();
extern "C" void isMagicFlag__21dSv_player_status_a_cCFUc();
extern "C" void init__21dSv_player_status_b_cFv();
extern "C" void onDarkClearLV__21dSv_player_status_b_cFi();
extern "C" void isDarkClearLV__21dSv_player_status_b_cCFi();
extern "C" void onTransformLV__21dSv_player_status_b_cFi();
extern "C" void isTransformLV__21dSv_player_status_b_cCFi();
extern "C" void init__17dSv_horse_place_cFv();
extern "C" void set__17dSv_horse_place_cFPCcRC4cXyzsSc();
extern "C" void init__25dSv_player_return_place_cFv();
extern "C" void set__25dSv_player_return_place_cFPCcScUc();
extern "C" void init__33dSv_player_field_last_stay_info_cFv();
extern "C" void set__33dSv_player_field_last_stay_info_cFPCcRC4cXyzsScUc();
extern "C" void onRegionBit__33dSv_player_field_last_stay_info_cFi();
extern "C" void isRegionBit__33dSv_player_field_last_stay_info_cCFi();
extern "C" void init__27dSv_player_last_mark_info_cFv();
extern "C" void setWarpItemData__27dSv_player_last_mark_info_cFPCcRC4cXyzsScUcUc();
extern "C" void init__17dSv_player_item_cFv();
extern "C" void setItem__17dSv_player_item_cFiUc();
extern "C" void getItem__17dSv_player_item_cCFib();
extern "C" void setLineUpItem__17dSv_player_item_cFv();
extern "C" void getLineUpItem__17dSv_player_item_cCFi();
extern "C" void setBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEmptyBottleItemIn__17dSv_player_item_cFUc();
extern "C" void setEmptyBottle__17dSv_player_item_cFv();
extern "C" void setEmptyBottle__17dSv_player_item_cFUc();
extern "C" void setEquipBottleItemIn__17dSv_player_item_cFUcUc();
extern "C" void setEquipBottleItemEmpty__17dSv_player_item_cFUc();
extern "C" void checkBottle__17dSv_player_item_cFUc();
extern "C" void checkInsectBottle__17dSv_player_item_cFv();
extern "C" void checkEmptyBottle__17dSv_player_item_cFv();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setBombBagItemIn__17dSv_player_item_cFUcUcUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcb();
extern "C" void setEmptyBombBagItemIn__17dSv_player_item_cFUcUcb();
extern "C" void setEmptyBombBag__17dSv_player_item_cFv();
extern "C" void setEmptyBombBag__17dSv_player_item_cFUcUc();
extern "C" void checkBombBag__17dSv_player_item_cFUc();
extern "C" void setWarashibeItem__17dSv_player_item_cFUc();
extern "C" void setRodTypeLevelUp__17dSv_player_item_cFv();
extern "C" void setBaitItem__17dSv_player_item_cFUc();
extern "C" void init__21dSv_player_get_item_cFv();
extern "C" void onFirstBit__21dSv_player_get_item_cFUc();
extern "C" void offFirstBit__21dSv_player_get_item_cFUc();
extern "C" void isFirstBit__21dSv_player_get_item_cCFUc();
extern "C" void init__24dSv_player_item_record_cFv();
extern "C" void setBombNum__24dSv_player_item_record_cFUcUc();
extern "C" void getBombNum__24dSv_player_item_record_cCFUc();
extern "C" void setBottleNum__24dSv_player_item_record_cFUcUc();
extern "C" void addBottleNum__24dSv_player_item_record_cFUcs();
extern "C" void getBottleNum__24dSv_player_item_record_cCFUc();
extern "C" void init__21dSv_player_item_max_cFv();
extern "C" void setBombNum__21dSv_player_item_max_cFUcUc();
extern "C" void getBombNum__21dSv_player_item_max_cCFUc();
extern "C" void init__20dSv_player_collect_cFv();
extern "C" void setCollect__20dSv_player_collect_cFiUc();
extern "C" void isCollect__20dSv_player_collect_cCFiUc();
extern "C" void onCollectCrystal__20dSv_player_collect_cFUc();
extern "C" void isCollectCrystal__20dSv_player_collect_cCFUc();
extern "C" void onCollectMirror__20dSv_player_collect_cFUc();
extern "C" void isCollectMirror__20dSv_player_collect_cCFUc();
extern "C" void init__17dSv_player_wolf_cFv();
extern "C" void init__16dSv_light_drop_cFv();
extern "C" void setLightDropNum__16dSv_light_drop_cFUcUc();
extern "C" void getLightDropNum__16dSv_light_drop_cCFUc();
extern "C" void onLightDropGetFlag__16dSv_light_drop_cFUc();
extern "C" void isLightDropGetFlag__16dSv_light_drop_cCFUc();
extern "C" void init__17dSv_letter_info_cFv();
extern "C" void onLetterGetFlag__17dSv_letter_info_cFi();
extern "C" void isLetterGetFlag__17dSv_letter_info_cCFi();
extern "C" void onLetterReadFlag__17dSv_letter_info_cFi();
extern "C" void isLetterReadFlag__17dSv_letter_info_cCFi();
extern "C" void init__18dSv_fishing_info_cFv();
extern "C" void addFishCount__18dSv_fishing_info_cFUc();
extern "C" void init__17dSv_player_info_cFv();
extern "C" void init__19dSv_player_config_cFv();
extern "C" void checkVibration__19dSv_player_config_cCFv();
extern "C" void getSound__19dSv_player_config_cFv();
extern "C" void setSound__19dSv_player_config_cFUc();
extern "C" void getVibration__19dSv_player_config_cFv();
extern "C" void setVibration__19dSv_player_config_cFUc();
extern "C" void init__12dSv_player_cFv();
extern "C" void init__12dSv_memBit_cFv();
extern "C" void onTbox__12dSv_memBit_cFi();
extern "C" void offTbox__12dSv_memBit_cFi();
extern "C" void isTbox__12dSv_memBit_cCFi();
extern "C" void onSwitch__12dSv_memBit_cFi();
extern "C" void offSwitch__12dSv_memBit_cFi();
extern "C" void isSwitch__12dSv_memBit_cCFi();
extern "C" void revSwitch__12dSv_memBit_cFi();
extern "C" void onItem__12dSv_memBit_cFi();
extern "C" void isItem__12dSv_memBit_cCFi();
extern "C" void onDungeonItem__12dSv_memBit_cFi();
extern "C" void isDungeonItem__12dSv_memBit_cCFi();
extern "C" void init__11dSv_event_cFv();
extern "C" void onEventBit__11dSv_event_cFUs();
extern "C" void offEventBit__11dSv_event_cFUs();
extern "C" void isEventBit__11dSv_event_cCFUs();
extern "C" void setEventReg__11dSv_event_cFUsUc();
extern "C" void getEventReg__11dSv_event_cCFUs();
extern "C" void init__14dSv_MiniGame_cFv();
extern "C" void init__12dSv_memory_cFv();
extern "C" void init__13dSv_memory2_cFv();
extern "C" void onVisitedRoom__13dSv_memory2_cFi();
extern "C" void offVisitedRoom__13dSv_memory2_cFi();
extern "C" void isVisitedRoom__13dSv_memory2_cFi();
extern "C" void init__12dSv_danBit_cFSc();
extern "C" void onSwitch__12dSv_danBit_cFi();
extern "C" void offSwitch__12dSv_danBit_cFi();
extern "C" void isSwitch__12dSv_danBit_cCFi();
extern "C" void revSwitch__12dSv_danBit_cFi();
extern "C" void onItem__12dSv_danBit_cFi();
extern "C" void isItem__12dSv_danBit_cCFi();
extern "C" void init__13dSv_zoneBit_cFv();
extern "C" void clearRoomSwitch__13dSv_zoneBit_cFv();
extern "C" void clearRoomItem__13dSv_zoneBit_cFv();
extern "C" void onSwitch__13dSv_zoneBit_cFi();
extern "C" void offSwitch__13dSv_zoneBit_cFi();
extern "C" void isSwitch__13dSv_zoneBit_cCFi();
extern "C" void revSwitch__13dSv_zoneBit_cFi();
extern "C" void onOneSwitch__13dSv_zoneBit_cFi();
extern "C" void offOneSwitch__13dSv_zoneBit_cFi();
extern "C" void isOneSwitch__13dSv_zoneBit_cCFi();
extern "C" void revOneSwitch__13dSv_zoneBit_cFi();
extern "C" void onItem__13dSv_zoneBit_cFi();
extern "C" void isItem__13dSv_zoneBit_cCFi();
extern "C" void onOneItem__13dSv_zoneBit_cFi();
extern "C" void isOneItem__13dSv_zoneBit_cCFi();
extern "C" void init__15dSv_zoneActor_cFv();
extern "C" void on__15dSv_zoneActor_cFi();
extern "C" void off__15dSv_zoneActor_cFi();
extern "C" void is__15dSv_zoneActor_cCFi();
extern "C" void init__10dSv_zone_cFi();
extern "C" void setRoom__13dSv_restart_cFRC4cXyzsSc();
extern "C" void set__17dSv_turnRestart_cFRC4cXyzsScUl();
extern "C" void init__10dSv_info_cFv();
extern "C" void init__10dSv_save_cFv();
extern "C" void getSave2__10dSv_save_cFi();
extern "C" void getSave__10dSv_info_cFi();
extern "C" void putSave__10dSv_info_cFi();
extern "C" void initZone__10dSv_info_cFv();
extern "C" void createZone__10dSv_info_cFi();
extern "C" void onSwitch__10dSv_info_cFii();
extern "C" void offSwitch__10dSv_info_cFii();
extern "C" void isSwitch__10dSv_info_cCFii();
extern "C" void revSwitch__10dSv_info_cFii();
extern "C" void onItem__10dSv_info_cFii();
extern "C" void isItem__10dSv_info_cCFii();
extern "C" void onActor__10dSv_info_cFii();
extern "C" void offActor__10dSv_info_cFii();
extern "C" void isActor__10dSv_info_cCFii();
extern "C" void memory_to_card__10dSv_info_cFPci();
extern "C" void card_to_memory__10dSv_info_cFPci();
extern "C" void initdata_to_card__10dSv_info_cFPci();
extern "C" u8 const tempBitLabels__20dSv_event_tmp_flag_c[370 + 2 /* padding */];
extern "C" extern char const* const d_save_d_save__stringBase0;
extern "C" u8 saveBitLabels__16dSv_event_flag_c[1644 + 4 /* padding */];

//
// External References:
//

extern "C" void OSReport_Error();
extern "C" void setNowVibration__14dComIfG_play_cFUc();
extern "C" void getNowVibration__14dComIfG_play_cFv();
extern "C" void getZoneNo__20dStage_roomControl_cFi();
extern "C" void dComIfGs_setSelectItemIndex__FiUc();
extern "C" void dComIfGs_setMixItemIndex__FiUc();
extern "C" void dComIfGs_getMixItemIndex__Fi();
extern "C" void dComIfGp_setSelectItem__Fi(int);
extern "C" s32 dComIfGs_getBottleMax__Fv();
extern "C" void dComIfGs_setKeyNum__FiUc();
extern "C" void __ct__13dSv_memory2_cFv();
extern "C" void __ct__12dSv_memory_cFv();
extern "C" void clrSaveFlag__12daObjCarry_cFv();
extern "C" void setSaveFlag__12daObjCarry_cFv();
extern "C" void setInitEventBit__Fv();
extern "C" void getString__13dMeter2Info_cFUlPcP14JMSMesgEntry_c();
extern "C" void setHotSpringTimer__13dMeter2Info_cFUc();
extern "C" void setSaveStageName__13dMeter2Info_cFPCc();
extern "C" void setOutputMode__10Z2AudioMgrFUl();
extern "C" void OSGetSoundMode();
extern "C" void OSGetTime();
extern "C" void __construct_array();
extern "C" void _savegpr_22();
extern "C" void _savegpr_26();
extern "C" void _savegpr_27();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_22();
extern "C" void _restgpr_26();
extern "C" void _restgpr_27();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();
extern "C" void __div2i();
extern "C" void printf();
extern "C" extern u8 g_dComIfG_gameInfo[122384];
extern "C" extern u8 g_meter2_info[248];
extern "C" u8 mAudioMgrPtr__10Z2AudioMgr[4 + 4 /* padding */];
extern "C" u8 sRumbleSupported__10JUTGamePad[4];

//
// Declarations:
//

// needs gameinfo
#ifdef NONMATCHING
inline int dComIfGs_isItemFirstBit(u8 i_no) {
    return g_dComIfG_gameInfo.getSaveFile().getPlayerGetItem().isFirstBit(i_no);
}
#endif

static u8 dSv_item_rename(u8 item_id) {
    switch (item_id) {
    case OIL_BOTTLE_2:
        return OIL_BOTTLE;
    case RED_BOTTLE_2:
        return RED_BOTTLE;
    case OIL2:
        return OIL;
    default:
        return item_id;
    }
}

void dSv_player_status_a_c::init() {
    mMaxLife = 15;
    mLife = 12;
    mRupee = 0;
    mMaxOil = 0;
    mOil = 0;
    unk10 = 0;

    for (int i = 0; i < MAX_SELECT_ITEM; i++) {
        mSelectItem[i] = NO_ITEM;
        mMixItem[i] = NO_ITEM;
        dComIfGp_setSelectItem__Fi(i);
    }

    for (int i = 0; i < MAX_EQUIPMENT; i++) {
        mSelectEquip[i] = 0;
    }

    mSelectEquip[COLLECT_CLOTHING] = WEARS_CASUAL;
    mSelectEquip[COLLECT_SWORD] = NO_ITEM;
    mSelectEquip[COLLECT_SHIELD] = NO_ITEM;
    mSelectEquip[COLLECT_SMELL] = NO_ITEM;
    mSelectEquip[B_BUTTON_ITEM] = NO_ITEM;
    mWalletSize = WALLET;
    mMaxMagic = 0;
    mMagic = 0;
    mMagicFlag = 0;
    unk29 = 0;
    mTransformStatus = 0;

    for (int i = 0; i < 3; i++) {
        unk31[i] = 0;
    }
}

void dSv_player_status_a_c::setSelectItemIndex(signed int i_no, u8 item_index) {
    if (i_no < MAX_SELECT_ITEM) {
        mSelectItem[i_no] = item_index;
    }
}

u8 dSv_player_status_a_c::getSelectItemIndex(signed int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mSelectItem[i_no];
    }
    return 0;
}

void dSv_player_status_a_c::setMixItemIndex(signed int i_no, u8 item_index) {
    if (i_no < MAX_SELECT_ITEM) {
        mMixItem[i_no] = item_index;
    }
}

u8 dSv_player_status_a_c::getMixItemIndex(signed int i_no) const {
    if (i_no < MAX_SELECT_ITEM) {
        return mMixItem[i_no];
    }
    return 0;
}

u16 dSv_player_status_a_c::getRupeeMax(void) const {
    if (mWalletSize < 3) {  // if you make this a default, it wont match. Compiler, pls.
        switch (mWalletSize) {
        case WALLET:
            return 300;
        case BIG_WALLET:
            return 600;
        case GIANT_WALLET:
            return 1000;
        }
    }
    return 0;
}

/* 80032AF8-80032B50 02D438 0058+00 0/0 1/1 0/0 .text isMagicFlag__21dSv_player_status_a_cCFUc */
#ifdef NONMATCHING
BOOL dSv_player_status_a_c::isMagicFlag(u8 i_magic) const {
    if (i_magic == 0) {
        return dComIfGs_isEventBit__FUs(0x2304);
    }
    return (mMagicFlag & (u8)(1 << i_magic)) ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL dSv_player_status_a_c::isMagicFlag(u8 param_0) const {
    nofralloc
#include "asm/d/save/d_save/isMagicFlag__21dSv_player_status_a_cCFUc.s"
}
#pragma pop
#endif

void dSv_player_status_b_c::init() {
    mDateIpl = 0;
    mTransformLevelFlag = 0;
    mDarkClearLevelFlag = 0;
    unk10 = 0;
    mTime = 255.0f;
    mDate = 0;

    for (int i = 0; i < 3; i++) {
        unk18[i] = 0;
    }
}

void dSv_player_status_b_c::onDarkClearLV(int flagOnOff) {
    mDarkClearLevelFlag |= (u8)(1 << flagOnOff);
}

BOOL dSv_player_status_b_c::isDarkClearLV(int unk) const {
    return mDarkClearLevelFlag & (u8)(1 << unk) ? TRUE : FALSE;
}

void dSv_player_status_b_c::onTransformLV(int flagOnOff) {
    mTransformLevelFlag |= (u8)(1 << flagOnOff);
}

BOOL dSv_player_status_b_c::isTransformLV(int unk) const {
    return mTransformLevelFlag & (u8)(1 << unk) ? TRUE : FALSE;
}

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80379234 = "";
#pragma pop

/* 80451D5C-80451D60 00035C 0004+00 3/3 0/0 0/0 .sdata2          @3813 */
SECTION_SDATA2 static u8 lit_3813[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80032C0C-80032C64 02D54C 0058+00 1/1 0/0 0/0 .text            init__17dSv_horse_place_cFv */
#ifdef NONMATCHING
// zero-initialized literal
void dSv_horse_place_c::init(void) {
    f32 position_val;
    char* default_stage;

    default_stage = strcpy(mCurrentStage, (char*)lbl_80379234);
    position_val = lbl_80451D5C;
    mPosition.x = lbl_80451D5C;
    mPosition.y = position_val;
    mPosition.z = position_val;
    mXRotation = 0;
    mSpawnId = 0;
    mRoomId = 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_horse_place_c::init() {
    nofralloc
#include "asm/d/save/d_save/init__17dSv_horse_place_cFv.s"
}
#pragma pop
#endif

void dSv_horse_place_c::set(const char* i_name, const cXyz& i_position, s16 i_x_rot,
                            signed char i_room_id) {
    strcpy(mCurrentStage, i_name);
    mPosition = i_position;
    mXRotation = i_x_rot;
    mRoomId = i_room_id;
}

void dSv_player_return_place_c::init(void) {
    strcpy(mCurrentStage, (char*)"F_SP108");
    mRoomId = 1;
    mSpawnId = 0;
    unk10 = 21;
    unk11 = 0;
}

void dSv_player_return_place_c::set(const char* i_name, s8 i_room_id, u8 i_spawn_id) {
    strcpy(mCurrentStage, i_name);
    mRoomId = i_room_id;
    mSpawnId = i_spawn_id;
}

/* 80032D60-80032DE0 02D6A0 0080+00 1/1 0/0 0/0 .text init__33dSv_player_field_last_stay_info_cFv
 */
// zero-initialized literal
#ifdef NONMATCHING
void dSv_player_field_last_stay_info_c::init() {
    f32 position_val;

    strcpy(mName, (char*)lbl_80379234);
    position_val = lbl_80451D5C;

    mPos.x = lbl_80451D5C;
    mPos.y = position_val;
    mPos.z = position_val;
    mAngleY = 0;
    mLastSpawnId = 0;
    mRegionNo = 1;
    mFieldDataExistFlag = false;
    mRegion = 0;

    for (int i = 0; i < 2; i++) {
        unk26[i] = 0;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_field_last_stay_info_c::init() {
    nofralloc
#include "asm/d/save/d_save/init__33dSv_player_field_last_stay_info_cFv.s"
}
#pragma pop
#endif

void dSv_player_field_last_stay_info_c::set(const char* i_name, const cXyz& i_last_position,
                                            s16 i_last_angle, signed char i_last_spawn_id,
                                            u8 i_last_room_id) {
    strcpy(mName, i_name);

    mPos = i_last_position;
    mAngleY = i_last_angle;
    mLastSpawnId = i_last_spawn_id;
    mRegionNo = i_last_room_id;
}

void dSv_player_field_last_stay_info_c::onRegionBit(int i_region_bit) {
    if (i_region_bit < 0) {
        return;
    }
    if (8 <= i_region_bit) {
        return;
    }
    mRegion |= (u8)(1 << i_region_bit);
}

BOOL dSv_player_field_last_stay_info_c::isRegionBit(int param_1) const {
    if ((param_1 >= 0) && (param_1 < 8)) {
        return (mRegion & (u8)(1 << param_1)) ? TRUE : FALSE;
    }
    return false;
}

/* 80032EB0-80032F2C 02D7F0 007C+00 1/1 0/0 0/0 .text init__27dSv_player_last_mark_info_cFv */
// zero-initialized literal
#ifdef NONMATCHING
void dSv_player_last_mark_info_c::init(void) {
    f32 position;

    strcpy(mOoccooStage, (char*)lbl_80379234);
    position = lbl_80451D5C;
    mOoccooPosition.x = lbl_80451D5C;
    mOoccooPosition.y = position;
    mOoccooPosition.z = position;
    mOoccooXRotation = 0;
    mOoccooRoomId = 0;
    mOoccooSpawnId = 0;
    mWarpAcceptStage = -1;

    for (int i = 0; i < 3; i++) {
        unk25[i] = 0;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_last_mark_info_c::init() {
    nofralloc
#include "asm/d/save/d_save/init__27dSv_player_last_mark_info_cFv.s"
}
#pragma pop
#endif

void dSv_player_last_mark_info_c::setWarpItemData(const char* i_ooccoo_stage,
                                                  const cXyz& i_ooccoo_position, s16 i_ooccoo_angle,
                                                  s8 i_ooccoo_room_id, u8 unk1, u8 unk2) {
    strcpy(mOoccooStage, i_ooccoo_stage);
    mOoccooPosition = i_ooccoo_position;
    mOoccooXRotation = i_ooccoo_angle;
    mOoccooRoomId = i_ooccoo_room_id;
}

void dSv_player_item_c::init(void) {
    for (int i = 0; i < 24; i++) {
        mItems[i] = NO_ITEM;
        mItemSlots[i] = NO_ITEM;
    }
}

/* 80032FB8-80033030 02D8F8 0078+00 11/11 45/45 2/2 .text setItem__17dSv_player_item_cFiUc */
// need gameinfo inline
#ifdef NONMATCHING
void dSv_player_item_c::setItem(int item_slot, u8 item_id) {
    if (item_slot < MAX_ITEM_SLOTS) {
        mItems[item_slot] = item_id;
        setLineUpItem();
    }

    int select_item_index = DEFAULT_SELECT_ITEM_INDEX;

    do {
        if (item_slot == dComIfGs_getSelectItemIndex(select_item_index)) {
            dComIfGp_setSelectItem__Fi(select_item_index);
        }
        select_item_index++;
    } while (select_item_index < MAX_SELECT_ITEM - 1);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setItem(int param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setItem__17dSv_player_item_cFiUc.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037923D = "合成アイテム不定＝＝＝＞%d, %d\n";
#pragma pop

/* 80033030-800332F8 02D970 02C8+00 7/7 70/70 2/2 .text            getItem__17dSv_player_item_cCFib
 */
#ifdef NONMATCHING
u8 dSv_player_item_c::getItem(int item_idx, bool isComboItem) const {
    if (item_idx < MAX_ITEM_SLOTS) {
        if (isComboItem) {
            for (int i = 0; i < 2; i++) {
                if ((dComIfGs_getSelectItemIndex(i) == item_idx ||
                     item_idx == dComIfGs_getMixItemIndex__Fi(i)) &&
                    dComIfGs_getMixItemIndex__Fi(i) != NO_ITEM) {
                    u8 item_id_2 = mItems[dComIfGs_getSelectItemIndex(i)];
                    u8 item_id_1 = mItems[dComIfGs_getMixItemIndex(i)];

                    // Get Bomb arrow check: Bow + Normal Bombs
                    if ((item_id_2 == BOW && item_id_1 == NORMAL_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == NORMAL_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Water Bombs
                    if ((item_id_2 == BOW && item_id_1 == WATER_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == WATER_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Bomb arrow check: Bow + Bomblings
                    if ((item_id_2 == BOW && item_id_1 == POKE_BOMB) ||
                        (item_id_1 == BOW && item_id_2 == POKE_BOMB)) {
                        return BOMB_ARROW;
                    }

                    // Get Hawkeye check
                    if ((item_id_2 == BOW && item_id_1 == HAWK_EYE) ||
                        (item_id_1 == BOW && item_id_2 == HAWK_EYE)) {
                        return HAWK_ARROW;
                    }

                    // Get Rod w/ bee larva
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == BEE_CHILD) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == BEE_CHILD)) {
                        return BEE_ROD;
                    }

                    // Get Rod w/ coral earring
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == ZORAS_JEWEL) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == ZORAS_JEWEL)) {
                        return JEWEL_ROD;
                    }

                    // Get Rod w/ worm
                    if ((item_id_2 == FISHING_ROD_1 && item_id_1 == WORM) ||
                        (item_id_1 == FISHING_ROD_1 && item_id_2 == WORM)) {
                        return WORM_ROD;
                    }

                    if (i == 3) {
                        if (dComIfGs_getSelectItemIndex(i) == 0 &&
                            dComIfGs_getMixItemIndex__Fi(i) == 0) {
                            dComIfGs_setSelectItemIndex__FiUc(i, 0xFF);
                            dComIfGs_setMixItemIndex__FiUc(i, 0xFF);
                            return 0xFF;
                        }
                    }
                    // 合成アイテム不定＝＝＝＞%d, %d\n
                    // Uncertain combination item＝＝＝＞%d, %d\n
                    OSReport_Error(lbl_80379234 + 9, item_id_2, item_id_1);
                }
            }
        }
        return mItems[item_idx];
    } else {
        return NO_ITEM;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u8 dSv_player_item_c::getItem(int param_0, bool param_1) const {
    nofralloc
#include "asm/d/save/d_save/getItem__17dSv_player_item_cCFib.s"
}
#pragma pop
#endif

static u8 i_item_lst[23] = {0x0A, 0x08, 0x06, 0x02, 0x09, 0x04, 0x03, 0x00, 0x01, 0x17, 0x14, 0x05,
                            0x0F, 0x10, 0x11, 0x0B, 0x0C, 0x0D, 0x0E, 0x13, 0x12, 0x16, 0x15};

/* 800332F8-80033354 02DC38 005C+00 2/2 0/0 0/0 .text setLineUpItem__17dSv_player_item_cFv */
// this is close
#ifdef NONMATCHING
void dSv_player_item_c::setLineUpItem(void) {
    for (int i = 0; i < 24; i++) {
        mItemSlots[i] = NO_ITEM;
    }

    for (int i = 0; i < 23; i++) {
        for (int j = 0; j < 24; j++) {
            if (mItems[i_item_lst[j]] != NO_ITEM) {
                mItemSlots[i] = i_item_lst[j];
            }
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setLineUpItem() {
    nofralloc
#include "asm/d/save/d_save/setLineUpItem__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

u8 dSv_player_item_c::getLineUpItem(int slot_number) const {
    if (slot_number < MAX_ITEM_SLOTS) {
        return mItemSlots[slot_number];
    }
    return NO_ITEM;
}

/* 80033370-80033450 02DCB0 00E0+00 1/1 2/2 0/0 .text setBottleItemIn__17dSv_player_item_cFUcUc */
#ifdef NONMATCHING
void dSv_player_item_c::setBottleItemIn(u8 i_item_id_1, u8 i_item_id_2) {
    u8 current_item_index;
    u8 new_item_index;

    current_item_index = dSv_item_rename(i_item_id_1);
    new_item_index = dSv_item_rename(i_item_id_2);

    for (int i = 0; i < 4; i++) {
        // sanitize input to make sure it's only a bottle
        if (current_item_index == items[i + 11]) {
            setItem(i + 11, new_item_index);
            // if hotsprings water, turn on the timer
            if (new_item_index == 107) {
                setHotSpringTimer(i + 11);
            }
            for (int j = 0; j < 4; j++) {
                j = getSelectItemIndex(i);
                if (i + 11 == j) {
                    dComIfGp_setSelectItem__Fi(j);
                }
            }
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBottleItemIn(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop
#endif

/* 80033450-80033494 02DD90 0044+00 0/0 26/26 0/0 .text
 * setEmptyBottleItemIn__17dSv_player_item_cFUc                 */
// this is 1 instruction off
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBottleItemIn(u8 i_item_id) {
    setBottleItemIn(EMPTY_BOTTLE, dSv_item_rename(i_item_id));
    return;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBottleItemIn(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBottleItemIn__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

/* 80033494-80033514 02DDD4 0080+00 0/0 1/1 1/1 .text setEmptyBottle__17dSv_player_item_cFv */
// inline
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBottle(void) {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + 11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + 11), EMPTY_BOTTLE);
            return;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBottle() {
    nofralloc
#include "asm/d/save/d_save/setEmptyBottle__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

/* 80033514-80033598 02DE54 0084+00 0/0 3/3 0/0 .text setEmptyBottle__17dSv_player_item_cFUc */
// need gameinfo inline
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBottle(u8 item_id) {
    for (int i = 0; i < 4; i++) {
        if (dComIfGs_getItem((u8)(i + 11), true) == NO_ITEM) {
            dComIfGs_setItem((u8)(i + 11), item_id);
            return;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBottle(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBottle__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

/* 80033598-800336BC 02DED8 0124+00 1/1 3/3 0/0 .text
 * setEquipBottleItemIn__17dSv_player_item_cFUcUc               */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEquipBottleItemIn(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setEquipBottleItemIn__17dSv_player_item_cFUcUc.s"
}
#pragma pop

void dSv_player_item_c::setEquipBottleItemEmpty(u8 selected_index) {
    setEquipBottleItemIn(selected_index, EMPTY_BOTTLE);
}

u8 dSv_player_item_c::checkBottle(u8 i_item_id) {
    u8 item_id;
    u8 num_bottles = 0;

    item_id = dSv_item_rename(i_item_id);
    for (int i = 0; i < BOTTLE_MAX; i++) {
        if (item_id == mItems[i + SLOT_11]) {
            num_bottles++;
        }
    }
    return num_bottles;
}

/* ############################################################################################## */
/* 803A7288-803A78F8 0043A8 066C+04 2/2 45/45 148/148 .data saveBitLabels__16dSv_event_flag_c */
SECTION_DATA u8 dSv_event_flag_c::saveBitLabels[1644 + 4 /* padding */] = {
    0xFF,
    0xFF,
    0x00,
    0x80,
    0x00,
    0x40,
    0x00,
    0x20,
    0x00,
    0x10,
    0x00,
    0x08,
    0x00,
    0x04,
    0x00,
    0x02,
    0x00,
    0x01,
    0x01,
    0x80,
    0x01,
    0x40,
    0x01,
    0x20,
    0x01,
    0x10,
    0x01,
    0x08,
    0x01,
    0x04,
    0x01,
    0x02,
    0x01,
    0x01,
    0x02,
    0x80,
    0x02,
    0x40,
    0x02,
    0x20,
    0x02,
    0x10,
    0x02,
    0x08,
    0x02,
    0x04,
    0x02,
    0x02,
    0x02,
    0x01,
    0x03,
    0x80,
    0x03,
    0x40,
    0x03,
    0x20,
    0x03,
    0x10,
    0x03,
    0x08,
    0x03,
    0x04,
    0x03,
    0x02,
    0x03,
    0x01,
    0x04,
    0x80,
    0x04,
    0x40,
    0x04,
    0x20,
    0x04,
    0x10,
    0x04,
    0x08,
    0x04,
    0x04,
    0x04,
    0x02,
    0x04,
    0x01,
    0x05,
    0x80,
    0x05,
    0x40,
    0x05,
    0x20,
    0x05,
    0x10,
    0x05,
    0x08,
    0x05,
    0x04,
    0x05,
    0x02,
    0x05,
    0x01,
    0x06,
    0x80,
    0x06,
    0x40,
    0x06,
    0x20,
    0x06,
    0x10,
    0x06,
    0x08,
    0x06,
    0x04,
    0x06,
    0x02,
    0x06,
    0x01,
    0x07,
    0x80,
    0x07,
    0x40,
    0x07,
    0x20,
    0x07,
    0x10,
    0x07,
    0x08,
    0x07,
    0x04,
    0x07,
    0x02,
    0x07,
    0x01,
    0x08,
    0x80,
    0x08,
    0x40,
    0x08,
    0x20,
    0x08,
    0x10,
    0x08,
    0x08,
    0x08,
    0x04,
    0x08,
    0x02,
    0x08,
    0x01,
    0x09,
    0x80,
    0x09,
    0x40,
    0x09,
    0x20,
    0x09,
    0x10,
    0x09,
    0x08,
    0x09,
    0x04,
    0x09,
    0x02,
    0x09,
    0x01,
    0x0A,
    0x80,
    0x0A,
    0x40,
    0x0A,
    0x20,
    0x0A,
    0x10,
    0x0A,
    0x08,
    0x0A,
    0x04,
    0x0A,
    0x02,
    0x0A,
    0x01,
    0x0B,
    0x80,
    0x0B,
    0x40,
    0x0B,
    0x20,
    0x0B,
    0x10,
    0x0B,
    0x08,
    0x0B,
    0x04,
    0x0B,
    0x02,
    0x0B,
    0x01,
    0x0C,
    0x80,
    0x0C,
    0x40,
    0x0C,
    0x20,
    0x0C,
    0x10,
    0x0C,
    0x08,
    0x0C,
    0x04,
    0x0C,
    0x02,
    0x0C,
    0x01,
    0x0D,
    0x80,
    0x0D,
    0x40,
    0x0D,
    0x20,
    0x0D,
    0x10,
    0x0D,
    0x08,
    0x0D,
    0x04,
    0x0D,
    0x02,
    0x0D,
    0x01,
    0x0E,
    0x80,
    0x0E,
    0x40,
    0x0E,
    0x20,
    0x0E,
    0x10,
    0x0E,
    0x08,
    0x0E,
    0x04,
    0x0E,
    0x02,
    0x0E,
    0x01,
    0x0F,
    0x80,
    0x0F,
    0x40,
    0x0F,
    0x20,
    0x0F,
    0x10,
    0x0F,
    0x08,
    0x0F,
    0x04,
    0x0F,
    0x02,
    0x0F,
    0x01,
    0x10,
    0x80,
    0x10,
    0x40,
    0x10,
    0x20,
    0x10,
    0x10,
    0x10,
    0x08,
    0x10,
    0x04,
    0x10,
    0x02,
    0x10,
    0x01,
    0x11,
    0x80,
    0x11,
    0x40,
    0x11,
    0x20,
    0x11,
    0x10,
    0x11,
    0x08,
    0x11,
    0x04,
    0x11,
    0x02,
    0x11,
    0x01,
    0x12,
    0x80,
    0x12,
    0x40,
    0x12,
    0x20,
    0x12,
    0x10,
    0x12,
    0x08,
    0x12,
    0x04,
    0x12,
    0x02,
    0x12,
    0x01,
    0x13,
    0x80,
    0x13,
    0x40,
    0x13,
    0x20,
    0x13,
    0x10,
    0x13,
    0x08,
    0x13,
    0x04,
    0x13,
    0x02,
    0x13,
    0x01,
    0x14,
    0x80,
    0x14,
    0x40,
    0x14,
    0x20,
    0x14,
    0x10,
    0x14,
    0x08,
    0x14,
    0x04,
    0x14,
    0x02,
    0x14,
    0x01,
    0x15,
    0x80,
    0x15,
    0x40,
    0x15,
    0x20,
    0x15,
    0x10,
    0x15,
    0x08,
    0x15,
    0x04,
    0x15,
    0x02,
    0x15,
    0x01,
    0x16,
    0x80,
    0x16,
    0x40,
    0x16,
    0x20,
    0x16,
    0x10,
    0x16,
    0x08,
    0x16,
    0x04,
    0x16,
    0x02,
    0x16,
    0x01,
    0xFF,
    0x1F,
    0x17,
    0x80,
    0x17,
    0x40,
    0x17,
    0x20,
    0x17,
    0x10,
    0x17,
    0x08,
    0x17,
    0x04,
    0x17,
    0x02,
    0x17,
    0x01,
    0x18,
    0x80,
    0x18,
    0x40,
    0x18,
    0x20,
    0x18,
    0x10,
    0xFE,
    0xFF,
    0xFD,
    0xFF,
    0xFC,
    0xFF,
    0xFB,
    0xFF,
    0x18,
    0x08,
    0x18,
    0x04,
    0x18,
    0x02,
    0x18,
    0x01,
    0x19,
    0x80,
    0x19,
    0x40,
    0x19,
    0x20,
    0x19,
    0x10,
    0x19,
    0x08,
    0x19,
    0x04,
    0x19,
    0x02,
    0x19,
    0x01,
    0x1A,
    0x80,
    0x1A,
    0x40,
    0x1A,
    0x20,
    0x1A,
    0x10,
    0x1A,
    0x08,
    0x1A,
    0x04,
    0x1A,
    0x02,
    0x1A,
    0x01,
    0x1B,
    0x80,
    0x1B,
    0x40,
    0x1B,
    0x20,
    0x1B,
    0x10,
    0x1B,
    0x08,
    0x1B,
    0x04,
    0x1B,
    0x02,
    0x1B,
    0x01,
    0x1C,
    0x80,
    0x1C,
    0x40,
    0x1C,
    0x20,
    0x1C,
    0x10,
    0x1C,
    0x08,
    0x1C,
    0x04,
    0x1C,
    0x02,
    0x1C,
    0x01,
    0x1D,
    0x80,
    0x1D,
    0x40,
    0x1D,
    0x20,
    0x1D,
    0x10,
    0x1D,
    0x08,
    0x1D,
    0x04,
    0x1D,
    0x02,
    0x1D,
    0x01,
    0x1E,
    0x80,
    0x1E,
    0x40,
    0x1E,
    0x20,
    0x1E,
    0x10,
    0x1E,
    0x08,
    0x1E,
    0x04,
    0x1E,
    0x02,
    0x1E,
    0x01,
    0x1F,
    0x80,
    0x1F,
    0x40,
    0x1F,
    0x20,
    0x1F,
    0x10,
    0x1F,
    0x08,
    0x1F,
    0x04,
    0x1F,
    0x02,
    0x1F,
    0x01,
    0x20,
    0x80,
    0x20,
    0x40,
    0x20,
    0x20,
    0x20,
    0x10,
    0x20,
    0x08,
    0x20,
    0x04,
    0x20,
    0x02,
    0x20,
    0x01,
    0x21,
    0x80,
    0x21,
    0x40,
    0x21,
    0x20,
    0x21,
    0x10,
    0x21,
    0x08,
    0x21,
    0x04,
    0x21,
    0x02,
    0x21,
    0x01,
    0x22,
    0x80,
    0x22,
    0x40,
    0x22,
    0x20,
    0x22,
    0x10,
    0x22,
    0x08,
    0x22,
    0x04,
    0x22,
    0x02,
    0x22,
    0x01,
    0x23,
    0x80,
    0x23,
    0x40,
    0x23,
    0x20,
    0x23,
    0x10,
    0x23,
    0x08,
    0x23,
    0x04,
    0x23,
    0x02,
    0x23,
    0x01,
    0x24,
    0x80,
    0x24,
    0x40,
    0x24,
    0x20,
    0x24,
    0x10,
    0x24,
    0x08,
    0x24,
    0x04,
    0x24,
    0x02,
    0x24,
    0x01,
    0x25,
    0x80,
    0x25,
    0x40,
    0x25,
    0x20,
    0x25,
    0x10,
    0x25,
    0x08,
    0x25,
    0x04,
    0x25,
    0x02,
    0x25,
    0x01,
    0x26,
    0x80,
    0x26,
    0x40,
    0x26,
    0x20,
    0x26,
    0x10,
    0x26,
    0x08,
    0x26,
    0x04,
    0x26,
    0x02,
    0x26,
    0x01,
    0x27,
    0x80,
    0x27,
    0x40,
    0x27,
    0x20,
    0x27,
    0x10,
    0x27,
    0x08,
    0x27,
    0x04,
    0x27,
    0x02,
    0x27,
    0x01,
    0x28,
    0x80,
    0x28,
    0x40,
    0x28,
    0x20,
    0x28,
    0x10,
    0x28,
    0x08,
    0x28,
    0x04,
    0x28,
    0x02,
    0x28,
    0x01,
    0x29,
    0x80,
    0x29,
    0x40,
    0x29,
    0x20,
    0x29,
    0x10,
    0x29,
    0x08,
    0x29,
    0x04,
    0x29,
    0x02,
    0x29,
    0x01,
    0x2A,
    0x80,
    0x2A,
    0x40,
    0x2A,
    0x20,
    0x2A,
    0x10,
    0x2A,
    0x08,
    0x2A,
    0x04,
    0x2A,
    0x02,
    0x2A,
    0x01,
    0x2B,
    0x80,
    0x2B,
    0x40,
    0x2B,
    0x20,
    0x2B,
    0x10,
    0x2B,
    0x08,
    0x2B,
    0x04,
    0x2B,
    0x02,
    0x2B,
    0x01,
    0x2C,
    0x80,
    0x2C,
    0x40,
    0x2C,
    0x20,
    0x2C,
    0x10,
    0x2C,
    0x08,
    0x2C,
    0x04,
    0x2C,
    0x02,
    0x2C,
    0x01,
    0x2D,
    0x80,
    0x2D,
    0x40,
    0x2D,
    0x20,
    0x2D,
    0x10,
    0x2D,
    0x08,
    0x2D,
    0x04,
    0x2D,
    0x02,
    0x2D,
    0x01,
    0x2E,
    0x80,
    0x2E,
    0x40,
    0x2E,
    0x20,
    0x2E,
    0x10,
    0x2E,
    0x08,
    0x2E,
    0x04,
    0x2E,
    0x02,
    0x2E,
    0x01,
    0x2F,
    0x80,
    0x2F,
    0x40,
    0x2F,
    0x20,
    0x2F,
    0x10,
    0x2F,
    0x08,
    0x2F,
    0x04,
    0x2F,
    0x02,
    0x2F,
    0x01,
    0x30,
    0x80,
    0x30,
    0x40,
    0x30,
    0x20,
    0x30,
    0x10,
    0x30,
    0x08,
    0x30,
    0x04,
    0x30,
    0x02,
    0x30,
    0x01,
    0x31,
    0x80,
    0x31,
    0x40,
    0x31,
    0x20,
    0x31,
    0x10,
    0x31,
    0x08,
    0x31,
    0x04,
    0x31,
    0x02,
    0x31,
    0x01,
    0x32,
    0x80,
    0x32,
    0x40,
    0x32,
    0x20,
    0x32,
    0x10,
    0x32,
    0x08,
    0x32,
    0x04,
    0x32,
    0x02,
    0x32,
    0x01,
    0x33,
    0x80,
    0x33,
    0x40,
    0x33,
    0x20,
    0x33,
    0x10,
    0x33,
    0x08,
    0x33,
    0x04,
    0x33,
    0x02,
    0x33,
    0x01,
    0x34,
    0x80,
    0x34,
    0x40,
    0x34,
    0x20,
    0x34,
    0x10,
    0x34,
    0x08,
    0x34,
    0x04,
    0x34,
    0x02,
    0x34,
    0x01,
    0x35,
    0x80,
    0x35,
    0x40,
    0x35,
    0x20,
    0x35,
    0x10,
    0x35,
    0x08,
    0x35,
    0x04,
    0x35,
    0x02,
    0x35,
    0x01,
    0x36,
    0x80,
    0x36,
    0x40,
    0x36,
    0x20,
    0x36,
    0x10,
    0x36,
    0x08,
    0x36,
    0x04,
    0x36,
    0x02,
    0x36,
    0x01,
    0x37,
    0x80,
    0x37,
    0x40,
    0x37,
    0x20,
    0x37,
    0x10,
    0x37,
    0x08,
    0xFA,
    0xFF,
    0xF9,
    0xFF,
    0x37,
    0x04,
    0x37,
    0x02,
    0x37,
    0x01,
    0x38,
    0x80,
    0x38,
    0x40,
    0x38,
    0x20,
    0x38,
    0x10,
    0x38,
    0x08,
    0x38,
    0x04,
    0x38,
    0x02,
    0x38,
    0x01,
    0x39,
    0x80,
    0x39,
    0x40,
    0x39,
    0x20,
    0x39,
    0x10,
    0x39,
    0x08,
    0x39,
    0x04,
    0x39,
    0x02,
    0x39,
    0x01,
    0x3A,
    0x80,
    0x3A,
    0x40,
    0x3A,
    0x20,
    0x3A,
    0x10,
    0x3A,
    0x08,
    0x3A,
    0x04,
    0x3A,
    0x02,
    0x3A,
    0x01,
    0x3B,
    0x80,
    0x3B,
    0x40,
    0x3B,
    0x20,
    0x3B,
    0x10,
    0x3B,
    0x08,
    0x3B,
    0x04,
    0x3B,
    0x02,
    0x3B,
    0x01,
    0x3C,
    0x80,
    0x3C,
    0x40,
    0x3C,
    0x20,
    0x3C,
    0x10,
    0x3C,
    0x08,
    0x3C,
    0x04,
    0x3C,
    0x02,
    0x3C,
    0x01,
    0x3D,
    0x80,
    0x3D,
    0x40,
    0x3D,
    0x20,
    0x3D,
    0x10,
    0x3D,
    0x08,
    0x3D,
    0x04,
    0x3D,
    0x02,
    0x3D,
    0x01,
    0x3E,
    0x80,
    0x3E,
    0x40,
    0x3E,
    0x20,
    0x3E,
    0x10,
    0x3E,
    0x08,
    0x3E,
    0x04,
    0x3E,
    0x02,
    0xF8,
    0xFF,
    0xF7,
    0xFF,
    0x3E,
    0x01,
    0x3F,
    0x80,
    0x3F,
    0x40,
    0x3F,
    0x20,
    0x3F,
    0x10,
    0x3F,
    0x08,
    0x3F,
    0x04,
    0x3F,
    0x02,
    0x3F,
    0x01,
    0x40,
    0x80,
    0x40,
    0x40,
    0x40,
    0x20,
    0x40,
    0x10,
    0x40,
    0x08,
    0x40,
    0x04,
    0x40,
    0x02,
    0x40,
    0x01,
    0x41,
    0x80,
    0x41,
    0x40,
    0x41,
    0x20,
    0x41,
    0x10,
    0x41,
    0x08,
    0x41,
    0x04,
    0x41,
    0x02,
    0x41,
    0x01,
    0x42,
    0x80,
    0x42,
    0x40,
    0x42,
    0x20,
    0x42,
    0x10,
    0x42,
    0x08,
    0x42,
    0x04,
    0x42,
    0x02,
    0x42,
    0x01,
    0x43,
    0x80,
    0x43,
    0x40,
    0x43,
    0x20,
    0x43,
    0x10,
    0x43,
    0x08,
    0x43,
    0x04,
    0x43,
    0x02,
    0x43,
    0x01,
    0x44,
    0x80,
    0x44,
    0x40,
    0x44,
    0x20,
    0x44,
    0x10,
    0x44,
    0x08,
    0x44,
    0x04,
    0x44,
    0x02,
    0x44,
    0x01,
    0x45,
    0x80,
    0x45,
    0x40,
    0x45,
    0x20,
    0x45,
    0x10,
    0x45,
    0x08,
    0x45,
    0x04,
    0x45,
    0x02,
    0x45,
    0x01,
    0x46,
    0x80,
    0x46,
    0x40,
    0x46,
    0x20,
    0x46,
    0x10,
    0x46,
    0x08,
    0x46,
    0x04,
    0x46,
    0x02,
    0x46,
    0x01,
    0x47,
    0x80,
    0x47,
    0x40,
    0x47,
    0x20,
    0x47,
    0x10,
    0x47,
    0x08,
    0x47,
    0x04,
    0x47,
    0x02,
    0x47,
    0x01,
    0x48,
    0x80,
    0x48,
    0x40,
    0x48,
    0x20,
    0x48,
    0x10,
    0x48,
    0x08,
    0x48,
    0x04,
    0x48,
    0x02,
    0x48,
    0x01,
    0x49,
    0x80,
    0x49,
    0x40,
    0x49,
    0x20,
    0x49,
    0x10,
    0x49,
    0x08,
    0x49,
    0x04,
    0x49,
    0x02,
    0x49,
    0x01,
    0xFF,
    0xFF,
    0x4A,
    0x40,
    0x4A,
    0x20,
    0x4A,
    0x10,
    0x4A,
    0x08,
    0x4A,
    0x04,
    0x4A,
    0x02,
    0x4A,
    0x01,
    0x4B,
    0x80,
    0x4B,
    0x40,
    0x4B,
    0x20,
    0x4B,
    0x10,
    0x4B,
    0x08,
    0x4B,
    0x04,
    0x4B,
    0x02,
    0x4B,
    0x01,
    0x4C,
    0x80,
    0x4C,
    0x40,
    0x4C,
    0x20,
    0x4C,
    0x10,
    0x4C,
    0x08,
    0x4C,
    0x04,
    0x4C,
    0x02,
    0x4C,
    0x01,
    0x4D,
    0x80,
    0x4D,
    0x40,
    0x4D,
    0x20,
    0x4D,
    0x10,
    0x4D,
    0x08,
    0x4A,
    0x80,
    0x4D,
    0x04,
    0x4D,
    0x02,
    0x4D,
    0x01,
    0x4E,
    0x80,
    0x4E,
    0x40,
    0x4E,
    0x20,
    0x4E,
    0x10,
    0x4E,
    0x08,
    0x4E,
    0x04,
    0x4E,
    0x02,
    0x4E,
    0x01,
    0x4F,
    0x80,
    0x4F,
    0x40,
    0x4F,
    0x20,
    0x4F,
    0x10,
    0x4F,
    0x08,
    0x4F,
    0x04,
    0x4F,
    0x02,
    0x4F,
    0x01,
    0x50,
    0x80,
    0x50,
    0x40,
    0x50,
    0x20,
    0x50,
    0x10,
    0x50,
    0x08,
    0x50,
    0x04,
    0x50,
    0x02,
    0x50,
    0x01,
    0x51,
    0x80,
    0x51,
    0x40,
    0x51,
    0x20,
    0x51,
    0x10,
    0x51,
    0x08,
    0x51,
    0x04,
    0x51,
    0x02,
    0x51,
    0x01,
    0x52,
    0x80,
    0x52,
    0x40,
    0x52,
    0x20,
    0x52,
    0x10,
    0x52,
    0x08,
    0x52,
    0x04,
    0x52,
    0x02,
    0x52,
    0x01,
    0x53,
    0x80,
    0x53,
    0x40,
    0x53,
    0x20,
    0x53,
    0x10,
    0x53,
    0x08,
    0x53,
    0x04,
    0x53,
    0x02,
    0x53,
    0x01,
    0x54,
    0x80,
    0x54,
    0x40,
    0x54,
    0x20,
    0x54,
    0x10,
    0x54,
    0x08,
    0x54,
    0x04,
    0x54,
    0x02,
    0x54,
    0x01,
    0x55,
    0x80,
    0x55,
    0x40,
    0x55,
    0x20,
    0x55,
    0x10,
    0x55,
    0x08,
    0x55,
    0x04,
    0x55,
    0x02,
    0x55,
    0x01,
    0x56,
    0x80,
    0x56,
    0x40,
    0x56,
    0x20,
    0x56,
    0x10,
    0x56,
    0x08,
    0x56,
    0x04,
    0x56,
    0x02,
    0x56,
    0x01,
    0x57,
    0x80,
    0x57,
    0x40,
    0x57,
    0x20,
    0xF6,
    0x3F,
    0xF5,
    0x7F,
    0xF4,
    0x7F,
    0xF3,
    0x7F,
    0xF2,
    0x7F,
    0x57,
    0x10,
    0x57,
    0x08,
    0x57,
    0x04,
    0x57,
    0x02,
    0x57,
    0x01,
    0x58,
    0x80,
    0x58,
    0x40,
    0x58,
    0x20,
    0x58,
    0x10,
    0x58,
    0x08,
    0x58,
    0x04,
    0x58,
    0x02,
    0x58,
    0x01,
    0x59,
    0x80,
    0x59,
    0x40,
    0x59,
    0x20,
    0xF1,
    0x1F,
    0x59,
    0x10,
    0x59,
    0x08,
    0x59,
    0x04,
    0x59,
    0x02,
    0x59,
    0x01,
    0x5A,
    0x80,
    0x5A,
    0x40,
    0x5A,
    0x20,
    0x5A,
    0x10,
    0x5A,
    0x08,
    0x5A,
    0x04,
    0x5A,
    0x02,
    0x5A,
    0x01,
    0x5B,
    0x80,
    0x5B,
    0x40,
    0x5B,
    0x20,
    0x5B,
    0x10,
    0x5B,
    0x08,
    0x5B,
    0x04,
    0x5B,
    0x02,
    0x5B,
    0x01,
    0x5C,
    0x80,
    0x5C,
    0x40,
    0x5C,
    0x20,
    0x5C,
    0x10,
    0x5C,
    0x08,
    0x5C,
    0x04,
    0x5C,
    0x02,
    0xF0,
    0xFF,
    0xEF,
    0xFF,
    0xEE,
    0xFF,
    0xED,
    0xFF,
    0xEC,
    0xFF,
    0xEB,
    0xFF,
    0x5C,
    0x01,
    0x5D,
    0x80,
    0x5D,
    0x40,
    0x5D,
    0x20,
    0x5D,
    0x10,
    0x5D,
    0x08,
    0x5D,
    0x04,
    0x5D,
    0x02,
    0x5D,
    0x01,
    0x5E,
    0x80,
    0x5E,
    0x40,
    0x5E,
    0x20,
    0x5E,
    0x10,
    0x5E,
    0x08,
    0x5E,
    0x04,
    0x5E,
    0x02,
    0x5E,
    0x01,
    0x5F,
    0x80,
    0x5F,
    0x40,
    0x5F,
    0x20,
    0x5F,
    0x10,
    0x5F,
    0x08,
    0x5F,
    0x04,
    0x5F,
    0x02,
    0x5F,
    0x01,
    0x60,
    0x80,
    0x60,
    0x40,
    0x60,
    0x20,
    0x60,
    0x10,
    0x60,
    0x08,
    0x60,
    0x04,
    0x60,
    0x02,
    0x60,
    0x01,
    0x61,
    0x80,
    0x61,
    0x40,
    0x61,
    0x20,
    0x61,
    0x10,
    0x61,
    0x08,
    0x61,
    0x04,
    0x61,
    0x02,
    0x61,
    0x01,
    0x62,
    0x80,
    0x62,
    0x40,
    0x62,
    0x20,
    0x62,
    0x10,
    0x62,
    0x08,
    0x62,
    0x04,
    0x62,
    0x02,
    0x62,
    0x01,
    0x63,
    0x80,
    0x63,
    0x40,
    0x63,
    0x20,
    0x63,
    0x10,
    0x63,
    0x08,
    0x63,
    0x04,
    0x63,
    0x02,
    /* padding */
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80033754-800337EC 02E094 0098+00 0/0 1/1 0/0 .text checkInsectBottle__17dSv_player_item_cFv */
#ifdef NONMATCHING
BOOL dSv_player_item_c::checkInsectBottle() {
    int i = 0;
    int j = 0;
    for (; i < 0x18; i++) {
        if (dComIfGs_isItemFirstBit(192 + i) &&
            !dComIfGs_isEventBit(lbl_803A7288.unk0[0x191 + j])) {
            return 1;
        }
        j += 1;
    }
    return 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_player_item_c::checkInsectBottle() {
    nofralloc
#include "asm/d/save/d_save/checkInsectBottle__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

u8 dSv_player_item_c::checkEmptyBottle(void) {
    u8 num = 0;

    for (int i = 0; i < BOTTLE_MAX; i++) {
        // Loop through the bottle slots (11 - 14) and increment counter for every empty bottle
        if (mItems[i + SLOT_11] == EMPTY_BOTTLE) {
            num++;
        }
    }
    return num;
}

/* 80033828-80033910 02E168 00E8+00 1/1 0/0 0/0 .text setBombBagItemIn__17dSv_player_item_cFUcUcb
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBombBagItemIn(u8 param_0, u8 param_1, bool param_2) {
    nofralloc
#include "asm/d/save/d_save/setBombBagItemIn__17dSv_player_item_cFUcUcb.s"
}
#pragma pop

/* 80033910-80033A20 02E250 0110+00 1/1 0/0 0/0 .text
 * setBombBagItemIn__17dSv_player_item_cFUcUcUcb                */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBombBagItemIn(u8 param_0, u8 param_1, u8 param_2, bool param_3) {
    nofralloc
#include "asm/d/save/d_save/setBombBagItemIn__17dSv_player_item_cFUcUcUcb.s"
}
#pragma pop

void dSv_player_item_c::setEmptyBombBagItemIn(u8 param_1, bool param_2) {
    setBombBagItemIn(BOMB_BAG_LV1, param_1, param_2);
}

void dSv_player_item_c::setEmptyBombBagItemIn(u8 param_1, u8 param_2, bool param_3) {
    setBombBagItemIn(BOMB_BAG_LV1, param_1, param_2, param_3);
}

/* 80033A88-80033B08 02E3C8 0080+00 0/0 2/2 0/0 .text setEmptyBombBag__17dSv_player_item_cFv */
// this is a few instructions off
#ifdef NONMATCHING
void dSv_player_item_c::setEmptyBombBag(void) {
    int current_item_index;
    u8 uVar1;

    for (int i = 0; i < 3; i++) {
        current_item_index = (u8)(i + 15);
        uVar1 = getItem(current_item_index, true);

        if (uVar1 == 0xff) {
            setItem(current_item_index, 80);
            return;
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBombBag() {
    nofralloc
#include "asm/d/save/d_save/setEmptyBombBag__17dSv_player_item_cFv.s"
}
#pragma pop
#endif

/* 80033B08-80033BEC 02E448 00E4+00 0/0 3/3 0/0 .text setEmptyBombBag__17dSv_player_item_cFUcUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setEmptyBombBag(u8 param_0, u8 param_1) {
    nofralloc
#include "asm/d/save/d_save/setEmptyBombBag__17dSv_player_item_cFUcUc.s"
}
#pragma pop

u8 dSv_player_item_c::checkBombBag(u8 param_1) {
    u8 counter = 0;

    for (int i = 0; i < BOMB_BAG_MAX; i++) {
        // Loop through the bomb bag slots (15 - 17) and increment counter for every match
        if (param_1 == mItems[i + SLOT_15]) {
            counter++;
        }
    }
    return counter;
}

/* 80033C2C-80033CBC 02E56C 0090+00 0/0 2/2 1/1 .text setWarashibeItem__17dSv_player_item_cFUc */
// need gameinfo inline
#ifdef NONMATCHING
void dSv_player_item_c::setWarashibeItem(u8 i_item_id) {
    u32 select_item_index;

    dComIfGs_setItem(SLOT_21, i_item_id);
    // inline should be used, but it wrongly swaps instruction order ??
    // dComIfGp_setItem(SLOT_21, i_item_id);
    g_dComIfG_gameInfo.setPlayUnkWarashibe1(SLOT_21);
    g_dComIfG_gameInfo.setPlayUnkWarashibe2(i_item_id);

    for (int i = 0; i < 4; i++) {
        select_item_index = dComIfGs_getSelectItemIndex((u8)i);
        if (select_item_index == SLOT_21) {
            dComIfGp_setSelectItem__Fi((u8)i);
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setWarashibeItem(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/setWarashibeItem__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

void dSv_player_item_c::setRodTypeLevelUp(void) {
    int current_fishing_rod_item_id = mItems[SLOT_20];

    switch (current_fishing_rod_item_id) {
    case BEE_ROD: {
        mItems[SLOT_20] = JEWEL_BEE_ROD;
        break;
    }
    case WORM_ROD: {
        mItems[SLOT_20] = JEWEL_WORM_ROD;
        break;
    }
    case FISHING_ROD_1: {
        mItems[SLOT_20] = JEWEL_ROD;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem__Fi(i);
    }
}

/* 80033D40-80033E40 02E680 0100+00 0/0 2/2 0/0 .text            setBaitItem__17dSv_player_item_cFUc
 */
// need gameinfo inline
#ifdef NONMATCHING
void dSv_player_item_c::setBaitItem(u8 param_1) {
    switch (param_1) {
    case BEE_CHILD: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_BEE_ROD :
                                               mItems[SLOT_20] = BEE_ROD;
        break;
    }
    case WORM: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_WORM_ROD :
                                               mItems[SLOT_20] = WORM_ROD;
        break;
    }
    case NO_ITEM: {
        dComIfGs_isItemFirstBit(ZORAS_JEWEL) ? mItems[SLOT_20] = JEWEL_ROD :
                                               mItems[SLOT_20] = FISHING_ROD_1;
        break;
    }
    }

    for (int i = 0; i < 4; i++) {
        dComIfGp_setSelectItem__Fi(i);
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_item_c::setBaitItem(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/setBaitItem__17dSv_player_item_cFUc.s"
}
#pragma pop
#endif

void dSv_player_get_item_c::init(void) {
    for (int i = 0; i < 8; i++) {
        mPauseMenuBitFields[i] = 0;
    }
}

/* 80033E60-80033E94 02E7A0 0034+00 0/0 3/3 1/1 .text onFirstBit__21dSv_player_get_item_cFUc */
// this is a few instructions off
#ifdef NONMATCHING
void dSv_player_get_item_c::onFirstBit(u8 i_itemno) {
    int tmp = (int)i_itemno;
    int tmp2 = (i_itemno >> 3) & 0xE0;
    // int uVar1 = ;
    mPauseMenuBitFields[tmp2] |= 1 << (tmp & 0x1F);
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_get_item_c::onFirstBit(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/onFirstBit__21dSv_player_get_item_cFUc.s"
}
#pragma pop
#endif

/* 80033E94-80033EC8 02E7D4 0034+00 0/0 7/7 1/1 .text offFirstBit__21dSv_player_get_item_cFUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_get_item_c::offFirstBit(u8 param_0) {
    nofralloc
#include "asm/d/save/d_save/offFirstBit__21dSv_player_get_item_cFUc.s"
}
#pragma pop

/* 80033EC8-80033F00 02E808 0038+00 4/4 87/87 2/2 .text isFirstBit__21dSv_player_get_item_cCFUc */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_player_get_item_c::isFirstBit(u8 param_0) const {
    nofralloc
#include "asm/d/save/d_save/isFirstBit__21dSv_player_get_item_cCFUc.s"
}
#pragma pop

void dSv_player_item_record_c::init(void) {
    mArrowNum = 0;

    for (int i = 0; i < 3; i++) {
        mBombNum[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mBottleNum[i] = 0;
    }

    mPachinkoNum = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_player_item_record_c::setBombNum(u8 i_bagIdx, u8 bag_id) {
    mBombNum[i_bagIdx] = bag_id;
}

u8 dSv_player_item_record_c::getBombNum(u8 i_bagIdx) const {
    return mBombNum[i_bagIdx];
}

void dSv_player_item_record_c::setBottleNum(u8 i_bottleIdx, u8 bottle_num) {
    mBottleNum[i_bottleIdx] = bottle_num;
}

/* 80033F9C-80034030 02E8DC 0094+00 0/0 1/1 0/0 .text addBottleNum__24dSv_player_item_record_cFUcs
 */
// need gameinfo inline
#ifdef NONMATCHING
u8 dSv_player_item_record_c::addBottleNum(u8 i_bottleIdx, s16 param_2) {
    int iVar3 = mBottleNum[i_bottleIdx] + param_2;

    dComIfGs_getItem((u8)(i_bottleIdx + 0xB), true);

    if (iVar3 < 0) {
        mBottleNum[i_bottleIdx] = 0;
    } else if (iVar3 > dComIfGs_getBottleMax__Fv()) {
        mBottleNum[i_bottleIdx] = dComIfGs_getBottleMax__Fv();
    } else {
        mBottleNum[i_bottleIdx] = iVar3;
    }
    return mBottleNum[i_bottleIdx];
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u8 dSv_player_item_record_c::addBottleNum(u8 param_0, s16 param_1) {
    nofralloc
#include "asm/d/save/d_save/addBottleNum__24dSv_player_item_record_cFUcs.s"
}
#pragma pop
#endif

u8 dSv_player_item_record_c::getBottleNum(u8 i_bottleIdx) const {
    return mBottleNum[i_bottleIdx];
}

void dSv_player_item_max_c::init(void) {
    for (int i = 0; i < 7; i++) {
        mItemMax[i] = 30;
    }
    setBombNum(NORMAL_BOMB, 30);
    setBombNum(WATER_BOMB, 15);
    setBombNum(POKE_BOMB, 10);
    mItemMax[7] = 0;
}

void dSv_player_item_max_c::setBombNum(u8 bomb_id, u8 bomb_max) {
    switch (bomb_id) {
    case NORMAL_BOMB:
        mItemMax[NORMAL_BOMB_MAX] = bomb_max;
        return;
    case WATER_BOMB:
        mItemMax[WATER_BOMB_MAX] = bomb_max;
        return;
    case POKE_BOMB:
        mItemMax[POKE_BOMB_MAX] = bomb_max;
        return;
    }
}

/* 800340F8-800341AC 02EA38 00B4+00 3/3 14/14 2/2 .text getBombNum__21dSv_player_item_max_cCFUc */
// need gameinfo inline
#ifdef NONMATCHING
u8 dSv_player_item_max_c::getBombNum(u8 param_1) const {
    u8 iVar3;

    iVar3 = 0x1;
    if (dComIfGs_isItemFirstBit(BOMB_BAG_LV2)) {
        iVar3 = 0x2;
    }

    switch (param_1) {
    case NORMAL_BOMB:
        return (u8)(mItemMax[NORMAL_BOMB_MAX] * iVar3);
    case WATER_BOMB:
        return (u8)(mItemMax[WATER_BOMB_MAX] * iVar3);
    case POKE_BOMB:
        return (u8)(mItemMax[POKE_BOMB_MAX] * iVar3);
    default:
        return 0;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u8 dSv_player_item_max_c::getBombNum(u8 param_0) const {
    nofralloc
#include "asm/d/save/d_save/getBombNum__21dSv_player_item_max_cCFUc.s"
}
#pragma pop
#endif

void dSv_player_collect_c::init(void) {
    for (int i = 0; i < 8; i++) {
        mItem[i] = 0;
    }

    unk8 = 0;
    mCrystal = 0;
    mMirror = 0;
    unk11 = 0xFF;
    mPohNum = 0;
}

void dSv_player_collect_c::setCollect(int i_item_type, u8 i_item) {
    mItem[i_item_type] |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollect(int i_item_type, u8 i_item) const {
    return mItem[i_item_type] & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectCrystal(u8 i_item) {
    mCrystal |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectCrystal(u8 i_item) const {
    return mCrystal & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_collect_c::onCollectMirror(u8 i_item) {
    mMirror |= (u8)(1 << i_item);
}

BOOL dSv_player_collect_c::isCollectMirror(u8 i_item) const {
    return mMirror & (u8)(1 << i_item) ? TRUE : FALSE;
}

void dSv_player_wolf_c::init(void) {
    for (int i = 0; i < 3; i++) {
        unk0[i] = 0;
    }

    unk3 = 0;
}

void dSv_light_drop_c::init(void) {
    for (int i = 0; i < 4; i++) {
        mLightDropNum[i] = 0;
    }

    mLightDropGetFlag = 0;

    for (int i = 0; i < 3; i++) {
        unk5[i] = 0;
    }
}

void dSv_light_drop_c::setLightDropNum(u8 i_nowLevel, u8 param_2) {
    if ((i_nowLevel < LIGHT_DROP_STAGE) || (i_nowLevel > 6)) {
        mLightDropNum[i_nowLevel] = param_2;
    }
}

u8 dSv_light_drop_c::getLightDropNum(u8 i_nowLevel) const {
    if ((i_nowLevel >= LIGHT_DROP_STAGE) && (i_nowLevel <= 6)) {
        return 0;
    }
    return mLightDropNum[i_nowLevel];
}

void dSv_light_drop_c::onLightDropGetFlag(u8 i_nowLevel) {
    if ((i_nowLevel < LIGHT_DROP_STAGE) || (i_nowLevel > 6)) {
        mLightDropGetFlag |= (u8)(1 << i_nowLevel);
    }
}

BOOL dSv_light_drop_c::isLightDropGetFlag(u8 i_nowLevel) const {
    if ((i_nowLevel >= LIGHT_DROP_STAGE) && (i_nowLevel <= 6)) {
        return 0;
    }
    return mLightDropGetFlag & (u8)(1 << i_nowLevel) ? TRUE : FALSE;
}

void dSv_letter_info_c::init(void) {
    for (int i = 0; i < 2; i++) {
        mLetterGetBitfields[i] = 0;
        mLetterReadBitfields[i] = 0;
    }

    for (int i = 0; i < LETTER_INFO_BIT; i++) {
        unk16[i] = 0;
    }
}

void dSv_letter_info_c::onLetterGetFlag(int i_no) {
    mLetterGetBitfields[i_no >> 0x5] |= 0x1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterGetFlag(int i_no) const {
    return mLetterGetBitfields[i_no >> 0x5] & (1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_letter_info_c::onLetterReadFlag(int i_no) {
    mLetterReadBitfields[i_no >> 0x5] |= 0x1 << (i_no & 0x1F);
}

BOOL dSv_letter_info_c::isLetterReadFlag(int i_no) const {
    return mLetterReadBitfields[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_fishing_info_c::init(void) {
    for (int i = 0; i < 16; i++) {
        mFishCount[i] = 0;
        mMaxSize[i] = 0;
    }
}

void dSv_fishing_info_c::addFishCount(u8 fish_index) {
    if (mFishCount[fish_index] < 999) {
        mFishCount[fish_index] += 1;
    }
}

/* 80034518-800345AC 02EE58 0094+00 1/1 0/0 0/0 .text            init__17dSv_player_info_cFv */
// a few instructions off
#ifdef NONMATCHING
void dSv_player_info_c::init(void) {
    unsigned long a = 0x382;
    unsigned long b = 0x383;

    JMSMesgEntry_c* c = 0;
    JMSMesgEntry_c* d = 0;

    d_meter2_info::dMeter2Info_c ok;

    ok.getString(a, (char*)mPlayerName, c);
    ok.getString(b, (char*)mHorseName, d);

    unk4 = 0;
    unk0 = 0;
    mTotalTime = 0;
    unk16 = 0;
    mDeathCount = 0;
    mClearCount = 0;

    for (int i = 0; i < 5; i++) {
        unk55[i] = 0;
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_info_c::init() {
    nofralloc
#include "asm/d/save/d_save/init__17dSv_player_info_cFv.s"
}
#pragma pop
#endif

/* 800345AC-80034644 02EEEC 0098+00 1/1 0/0 0/0 .text            init__19dSv_player_config_cFv */
// needs mAudioMgrPtr setup
#ifdef NONMATCHING
void dSv_player_config_c::init(void) {
    u32 os_mSoundMode;

    unk0 = 1;
    os_mSoundMode = OSGetSoundMode();
    if (os_mSoundMode == SOUND_MODE_MONO) {
        mSoundMode = SOUND_MODE_MONO;
        lbl_80451368->setOutputMode(SOUND_MODE_MONO);
    } else {
        mSoundMode = SOUND_MODE_STEREO;
        lbl_80451368->setOutputMode(SOUND_MODE_STEREO);
    }

    mAttentionType = 0;
    mVibration = 1;
    unk4 = 0;
    unk5 = 0;
    mShortCut = 0;
    mCalibrateDist = 0x15e;
    mCalValue = 0;
    mCameraControl = 0;
    mPointer = 1;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_player_config_c::init() {
    nofralloc
#include "asm/d/save/d_save/init__19dSv_player_config_cFv.s"
}
#pragma pop
#endif

/* 80034644-80034684 02EF84 0040+00 0/0 4/4 0/0 .text checkVibration__19dSv_player_config_cCFv */
// need gameinfo inline
#ifdef NONMATCHING
u32 dSv_player_config_c::checkVibration(void) const {
    return _sRumbleSupported & 0x80000000 ? dComIfGp_getNowVibration() : 0;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm u32 dSv_player_config_c::checkVibration() const {
    nofralloc
#include "asm/d/save/d_save/checkVibration__19dSv_player_config_cCFv.s"
}
#pragma pop
#endif

u8 dSv_player_config_c::getSound(void) {
    return mSoundMode;
}

void dSv_player_config_c::setSound(u8 i_mSoundMode) {
    mSoundMode = i_mSoundMode;
}

u8 dSv_player_config_c::getVibration(void) {
    return mVibration;
}

void dSv_player_config_c::setVibration(u8 i_mVibrationStatus) {
    mVibration = i_mVibrationStatus;
}

void dSv_player_c::init(void) {
    player_status_a.init();
    player_status_b.init();
    horse_place.init();
    player_return.init();
    player_last_field.init();
    player_last_mark.init();
    player_item.init();
    player_get_item.init();
    player_item_record.init();
    player_item_max.init();
    player_collect.init();
    player_wolf.init();
    light_drop.init();
    letter_info.init();
    fishing_info.init();
    mPlayerInfo.init();
    player_config.init();
}

void dSv_memBit_c::init(void) {
    for (int i = 0; i < 2; i++) {
        mTbox[i] = 0;
    }

    for (int i = 0; i < 4; i++) {
        mSwitch[i] = 0;
    }

    mItem[0] = 0;
    mKeyNum = 0;
    mDungeonItem = 0;
}

void dSv_memBit_c::onTbox(int i_no) {
    mTbox[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memBit_c::offTbox(int i_no) {
    mTbox[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isTbox(int i_no) const {
    return 1 << (i_no & 0x1f) & mTbox[i_no >> 0x5] ? TRUE : FALSE;
}

void dSv_memBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}
void dSv_memBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memBit_c::isSwitch(int i_no) const {
    return (mSwitch[i_no >> 0x5] & 0x1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

/* 8003488C-800348C4 02F1CC 0038+00 1/1 0/0 0/0 .text            revSwitch__12dSv_memBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_memBit_c::revSwitch(int i_no) {
    unsigned int tmp = 1 << (i_no & 0x1F);
    (mTbox + (i_no >> 0x5))[0x2] ^= tmp;
    return (mTbox + (i_no >> 0x5))[0x2] & tmp ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_memBit_c::revSwitch(int param_0) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__12dSv_memBit_cFi.s"
}
#pragma pop
#endif

void dSv_memBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_memBit_c::isItem(int i_no) const {
    return (mItem[i_no >> 0x5] & 1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

void dSv_memBit_c::onDungeonItem(int i_no) {
    mDungeonItem |= (u8)(1 << i_no);
}

bool dSv_memBit_c::isDungeonItem(int i_no) const {
    return mDungeonItem & (u8)(1 << i_no) ? true : false;
}

void dSv_event_c::init(void) {
    for (int i = 0; i < MAX_EVENTS; i++) {
        mEvent[i] = 0;
    }
    setInitEventBit__Fv();
}

void dSv_event_c::onEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] |= (u8)i_no;
}

void dSv_event_c::offEventBit(u16 i_no) {
    mEvent[(i_no >> 8)] &= ~(u8)i_no;
}

BOOL dSv_event_c::isEventBit(u16 i_no) const {
    return mEvent[(i_no >> 8)] & (i_no & 0xFF) ? TRUE : FALSE;
}

void dSv_event_c::setEventReg(u16 param_1, u8 param_2) {
    u8 uVar1 = (param_1 >> 8);
    mEvent[uVar1] &= ~(u8)param_1;
    mEvent[uVar1] |= param_2;
}

u8 dSv_event_c::getEventReg(u16 param_1) const {
    return (u8)param_1 & mEvent[param_1 >> 8];
}

void dSv_MiniGame_c::init(void) {
    unk0 = 0;
    for (int i = 0; i < 3; i++) {
        unk1[i] = 0;
    }
    unk4 = 120000;
    mBalloonScore = 0;
    mRaceGameTime = 0;
    unk16 = 0;
    unk20 = 0;
}

void dSv_memory_c::init(void) {
    mMemBit.init();
}

void dSv_memory2_c::init(void) {
    for (int i = 0; i < 2; i++) {
        mVisitedRoom[i] = 0;
    }
}

void dSv_memory2_c::onVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_memory2_c::offVisitedRoom(int i_no) {
    mVisitedRoom[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_memory2_c::isVisitedRoom(int param_1) {
    return (1 << (param_1 & 0x1F) & mVisitedRoom[param_1 >> 5]) ? TRUE : FALSE;
}

bool dSv_danBit_c::init(s8 i_stage) {
    if (i_stage != mStageNo) {
        mSwitch[0] = 0;
        mSwitch[1] = 0;
        mItem[0] = 0;
        mItem[1] = 0;
        mItem[2] = 0;
        mItem[3] = 0;
        mStageNo = i_stage;
        unk1 = 0;

        for (int i = 0; i < 16; i++) {
            unk28[i] = 0xFFFF;
        }

        clrSaveFlag__12daObjCarry_cFv();
        return true;

    } else {
        setSaveFlag__12daObjCarry_cFv();
        return false;
    }
}

void dSv_danBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 5] |= 1 << (i_no & 0x1F);
}

void dSv_danBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 5] &= ~(1 << (i_no & 0x1F));
}

BOOL dSv_danBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 0x5] & (0x1 << (i_no & 0x1F)) ? TRUE : FALSE;
}

BOOL dSv_danBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0x1F);
    mSwitch[i_no >> 5] ^= uVar1;
    return mSwitch[i_no >> 5] & uVar1 ? TRUE : FALSE;
}

void dSv_danBit_c::onItem(int i_no) {
    mItem[i_no >> 5] |= 1 << (i_no & 0x1F);
}

BOOL dSv_danBit_c::isItem(int i_no) const {
    return mItem[i_no >> 5] & 1 << (i_no & 0x1F) ? TRUE : FALSE;
}

void dSv_zoneBit_c::init(void) {
    for (int i = 0; i < 2; i++) {
        mSwitch[i] = 0;
    }

    for (int i = 0; i < 2; i++) {
        mItem[i] = 0;
    }

    mRoomSwitch = 0;
    mRoomItem = 0;
}

void dSv_zoneBit_c::clearRoomSwitch(void) {
    mRoomSwitch = 0;
}

void dSv_zoneBit_c::clearRoomItem(void) {
    mRoomItem = 0;
}

void dSv_zoneBit_c::onSwitch(int i_no) {
    mSwitch[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

void dSv_zoneBit_c::offSwitch(int i_no) {
    mSwitch[i_no >> 4] &= ~(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isSwitch(int i_no) const {
    return mSwitch[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

/* 80034D78-80034DAC 02F6B8 0034+00 1/1 0/0 0/0 .text            revSwitch__13dSv_zoneBit_cFi */
// instruction in wrong place
#ifdef NONMATCHING
BOOL dSv_zoneBit_c::revSwitch(int i_no) {
    int uVar1 = 1 << (i_no & 0xF);
    switch_bitfield[i_no >> 4] ^= uVar1;
    return switch_bitfield[i_no >> 4] & uVar1 ? TRUE : FALSE;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm int dSv_zoneBit_c::revSwitch(int param_0) {
    nofralloc
#include "asm/d/save/d_save/revSwitch__13dSv_zoneBit_cFi.s"
}
#pragma pop
#endif

void dSv_zoneBit_c::onOneSwitch(int i_no) {
    mRoomSwitch |= (u16)(1 << i_no);
}

void dSv_zoneBit_c::offOneSwitch(int i_no) {
    mRoomSwitch &= ~(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneSwitch(int i_no) const {
    return mRoomSwitch & 1 << i_no ? TRUE : FALSE;
}

BOOL dSv_zoneBit_c::revOneSwitch(int i_no) {
    int iVar1 = 1 << i_no;
    mRoomSwitch ^= iVar1;
    return mRoomSwitch & iVar1 ? TRUE : FALSE;
}

void dSv_zoneBit_c::onItem(int i_no) {
    mItem[i_no >> 4] |= (u16)(1 << (i_no & 0xF));
}

BOOL dSv_zoneBit_c::isItem(int i_no) const {
    return mItem[i_no >> 4] & 1 << (i_no & 0xF) ? TRUE : FALSE;
}

void dSv_zoneBit_c::onOneItem(int i_no) {
    mRoomItem |= (u16)(1 << i_no);
}

BOOL dSv_zoneBit_c::isOneItem(int i_no) const {
    return mRoomItem & 1 << i_no ? TRUE : FALSE;
}

void dSv_zoneActor_c::init(void) {
    for (int i = 0; i < 4; i++) {
        actor_bitfield[i] = 0;
    }
}

void dSv_zoneActor_c::on(int i_id) {
    actor_bitfield[i_id >> 5] |= 1 << (i_id & 0x1F);
}

void dSv_zoneActor_c::off(int i_id) {
    actor_bitfield[i_id >> 5] &= ~(1 << (i_id & 0x1F));
}

BOOL dSv_zoneActor_c::is(int i_id) const {
    return actor_bitfield[i_id >> 5] & 1 << (i_id & 0x1F) ? TRUE : FALSE;
}

void dSv_zone_c::init(int i_roomNo) {
    mRoomNo = i_roomNo;
    mBit.init();
    mActor.init();
}

void dSv_restart_c::setRoom(const cXyz& i_position, s16 i_angleY, s8 i_roomNo) {
    mRoomNo = i_roomNo;
    mRoomPos = i_position;
    mRoomAngleY = i_angleY;
}

void dSv_turnRestart_c::set(const cXyz& i_position, s16 i_angleY, s8 param_3, u32 i_param) {
    mPosition = i_position;
    mAngleY = i_angleY;
    unk18 = param_3;
    mParam = i_param;
}

void dSv_info_c::init(void) {
    mSavedata.init();
    mMemory.init();
    mDan.init(-1);
    initZone();
    mTmp.init();
}

void dSv_save_c::init(void) {
    mPlayer.init();
    for (int i = 0; i < STAGE_MAX; i++) {
        mSave[i].init();
    }

    for (int i = 0; i < STAGE2_MAX; i++) {
        mSave2[i].init();
    }

    mEvent.init();
    mMiniGame.init();
}

dSv_memory2_c* dSv_save_c::getSave2(int i_stage2No) {
    return &mSave2[i_stage2No];
}

/* 800350BC-800350F0 02F9FC 0034+00 0/0 1/1 0/0 .text            getSave__10dSv_info_cFi */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::getSave(int param_0) {
    nofralloc
#include "asm/d/save/d_save/getSave__10dSv_info_cFi.s"
}
#pragma pop

/* 800350F0-8003514C 02FA30 005C+00 0/0 2/2 0/0 .text            putSave__10dSv_info_cFi */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::putSave(int param_0) {
    nofralloc
#include "asm/d/save/d_save/putSave__10dSv_info_cFi.s"
}
#pragma pop

void dSv_info_c::initZone(void) {
    for (int i = 0; i < 0x20; i++) {
        mZone[i].init(-1);
    }
}

u32 dSv_info_c::createZone(int param_1) {
    dSv_zone_c* zone = mZone;
    for (int i = 0; i < 0x20; zone++, i++) {
        if (zone->getRoomNo() < 0) {
            zone->init(param_1);
            return i;
        }
    }
    return -1;
}

void dSv_info_c::onSwitch(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mMemory.getMemBit().onSwitch(i_no);
    } else if (i_no < 0xc0) {
        mDan.onSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            mZone[zoneId].getZoneBit().onSwitch(i_no - 0xC0);
        } else {
            mZone[zoneId].getZoneBit().onOneSwitch(i_no - 0xE0);
        }
    }
}

void dSv_info_c::offSwitch(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mMemory.getMemBit().offSwitch(i_no);
    } else if (i_no < 0xc0) {
        mDan.offSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            mZone[zoneId].getZoneBit().offSwitch(i_no - 0xC0);
        } else {
            mZone[zoneId].getZoneBit().offOneSwitch(i_no - 0xE0);
        }
    }
}

BOOL dSv_info_c::isSwitch(int i_no, int i_roomNo) const {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mMemory.getMemBitConst().isSwitch(i_no);
    } else if (i_no < 0xc0) {
        value = mDan.isSwitch(i_no - 0x80);
    } else {
        int zoneId = dStage_roomControl_c::getZoneNo(i_roomNo);
        if ((zoneId < 0) || (zoneId >= 0x20)) {
            value = FALSE;
        } else {
            if (i_no < 0xE0) {
                value = mZone[zoneId].getZoneBitConst().isSwitch(i_no - 0xC0);
            } else {
                value = mZone[zoneId].getZoneBitConst().isOneSwitch(i_no - 0xE0);
            }
        }
    }
    return value;
}

BOOL dSv_info_c::revSwitch(int i_no, int i_roomNo) {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mMemory.getMemBit().revSwitch(i_no);
    } else if (i_no < 0xC0) {
        value = mDan.revSwitch(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xE0) {
            value = mZone[zoneNo].getZoneBit().revSwitch(i_no - 0xC0);
        } else {
            value = mZone[zoneNo].getZoneBit().revOneSwitch(i_no - 0xE0);
        }
    }

    return value;
}

void dSv_info_c::onItem(int i_no, int i_roomNo) {
    if ((i_no == -1) || (i_no == 0xFF)) {
        return;
    }

    if (i_no < 0x80) {
        mDan.onItem(i_no);
    } else if (i_no < 0xA0) {
        mMemory.getMemBit().onItem(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xC0) {
            mZone[zoneNo].getZoneBit().onItem(i_no - 0xA0);
        } else {
            mZone[zoneNo].getZoneBit().onOneItem(i_no - 0xC0);
        }
    }
}

BOOL dSv_info_c::isItem(int i_no, int i_roomNo) const {
    int value;
    if ((i_no == -1) || (i_no == 0xFF)) {
        return FALSE;
    }

    if (i_no < 0x80) {
        value = mDan.isItem(i_no);
    } else if (i_no < 0xA0) {
        value = mMemory.getMemBitConst().isItem(i_no - 0x80);
    } else {
        int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
        if (i_no < 0xC0) {
            value = mZone[zoneNo].getZoneBitConst().isItem(i_no - 0xA0);
        } else {
            value = mZone[zoneNo].getZoneBitConst().isOneItem(i_no - 0xC0);
        }
    }

    return value;
}

void dSv_info_c::onActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getZoneActor().on(i_id);
}

void dSv_info_c::offActor(int i_id, int i_roomNo) {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return;
    }

    int zoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    mZone[zoneNo].getZoneActor().off(i_id);
}

BOOL dSv_info_c::isActor(int i_id, int i_roomNo) const {
    if (i_id == -1 || i_id == dSv_zoneActor_c::ACTOR_MAX || i_roomNo == -1) {
        return FALSE;
    }

    int ActorZoneNo = dStage_roomControl_c::getZoneNo(i_roomNo);
    return mZone[ActorZoneNo].getZoneActorConst().is(i_id);
}

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037925D = "Write size:%d\n";
SECTION_DEAD static char const* const stringBase_8037926C = "SAVE size:%d\n";
#pragma pop

/* 80035798-80035A04 0300D8 026C+00 0/0 1/1 0/0 .text            memory_to_card__10dSv_info_cFPci */
#ifdef NONMATCHING
extern u8 lbl_803F6094[0x10100];
void dSv_info_c::memory_to_card(char* param_1, int param_2) {
    BOOL bVar1 = FALSE;
    int uVar12 = 0;
    BOOL bVar6 = dComIfGs_isEventBit__FUs(0x1B08);
    if (!tmp) {
        BOOL bVar7 = dComIfGs_isEventBit__FUs(0x1B20);
        BOOL tmp = bVar7;
        bVar7 = dComIfGs_isEventBit__FUs(0x1B10);
        BOOL tmp2 = bVar7;
        dComIfGs_offEventBit(0x1B20);
        dComIfGs_offEventBit(0x1B10);
    }

    BOOL iVar4 = dComIfGs_isItemFirstBit(KANTERA);

    if (iVar4) {
        dComIfGs_setItem(SLOT_1, KANTERA);
        u16 current_lantern_oil = dComIfGs_getOil();
        u8 oil_gauge_backup = dMeter2Info_getOilGaugeBackUp();
        dComIfGs_setOil(oil_gauge_backup & 0xFFFF);
        bVar1 = TRUE;
    }

    int uVar3 = g_dComIfG_gameInfo + 0xF2C;
    int iVar2 = g_dComIfG_gameInfo + 0xF28;

    u32* ptr = lbl_803F6094 + 0x9f6c;
    OSTime time = OSGetTime();

    OSTime newTime = time >> 0x20;
    int newTime2 = newTime - uVar3;

    int newTime3 = newTime2 + g_dComIfG_gameInfo +
                   0xF30

                   int newTime4 = g_dComIfG_gameInfo + 0xF78

                                  s64 sVar13 = __div2i((int)((ulonglong)uVar8 >> 0x20), (int)uVar8,
                                                       0x0, _DAT_800000f8 >> 0x2);

    BOOL bVar7 =
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::memory_to_card(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/memory_to_card__10dSv_info_cFPci.s"
}
#pragma pop
#endif

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8037927A = "LOAD size:%d\n";
#pragma pop

/* 80035A04-80035BD0 030344 01CC+00 0/0 2/2 0/0 .text            card_to_memory__10dSv_info_cFPci */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::card_to_memory(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/card_to_memory__10dSv_info_cFPci.s"
}
#pragma pop

/* ############################################################################################## */
/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_80379288 = "INIT size:%d\n";
/* @stringBase0 padding */
SECTION_DEAD static char const* const pad_80379296 = "\0";
#pragma pop

/* 80035BD0-80035C88 030510 00B8+00 0/0 3/3 0/0 .text            initdata_to_card__10dSv_info_cFPci
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dSv_info_c::initdata_to_card(char* param_0, int param_1) {
    nofralloc
#include "asm/d/save/d_save/initdata_to_card__10dSv_info_cFPci.s"
}
#pragma pop

/* ############################################################################################## */
/* 803790C0-80379234 005720 0172+02 0/0 17/17 7/7 .rodata tempBitLabels__20dSv_event_tmp_flag_c */
SECTION_RODATA u8 const dSv_event_tmp_flag_c::tempBitLabels[370 + 2 /* padding */] = {
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0x0F,
    0xFE,
    0xFF,
    0x00,
    0x40,
    0xFD,
    0xFF,
    0xFC,
    0xFF,
    0x00,
    0x20,
    0x00,
    0x80,
    0x00,
    0x10,
    0x00,
    0x08,
    0x00,
    0x04,
    0x00,
    0x02,
    0x00,
    0x01,
    0x01,
    0x80,
    0x01,
    0x40,
    0x01,
    0x20,
    0x01,
    0x10,
    0x01,
    0x08,
    0x01,
    0x04,
    0x01,
    0x02,
    0x01,
    0x01,
    0x02,
    0x80,
    0x02,
    0x40,
    0x02,
    0x20,
    0x02,
    0x10,
    0x02,
    0x08,
    0x02,
    0x04,
    0x02,
    0x02,
    0x02,
    0x01,
    0x03,
    0x80,
    0x03,
    0x40,
    0x03,
    0x20,
    0x03,
    0x10,
    0xFB,
    0xFF,
    0x03,
    0x08,
    0x03,
    0x04,
    0x03,
    0x02,
    0x03,
    0x01,
    0x04,
    0x80,
    0x04,
    0x40,
    0x04,
    0x20,
    0x04,
    0x10,
    0x04,
    0x08,
    0x04,
    0x04,
    0x04,
    0x02,
    0x04,
    0x01,
    0x05,
    0x80,
    0x05,
    0x40,
    0x05,
    0x20,
    0x05,
    0x10,
    0x05,
    0x08,
    0x05,
    0x04,
    0x05,
    0x02,
    0x05,
    0x01,
    0x06,
    0x80,
    0x06,
    0x40,
    0x06,
    0x20,
    0x06,
    0x10,
    0x06,
    0x08,
    0x06,
    0x04,
    0x06,
    0x02,
    0x06,
    0x01,
    0x07,
    0x80,
    0x07,
    0x40,
    0x07,
    0x20,
    0x07,
    0x10,
    0x07,
    0x08,
    0x07,
    0x04,
    0x07,
    0x02,
    0x07,
    0x01,
    0x08,
    0x80,
    0x08,
    0x40,
    0x08,
    0x20,
    0x08,
    0x10,
    0x08,
    0x08,
    0x08,
    0x04,
    0x08,
    0x02,
    0x08,
    0x01,
    0x09,
    0x80,
    0x09,
    0x40,
    0x09,
    0x20,
    0x09,
    0x10,
    0x09,
    0x08,
    0x09,
    0x04,
    0x09,
    0x02,
    0x09,
    0x01,
    0x0A,
    0x80,
    0x0A,
    0x40,
    0x0A,
    0x20,
    0x0A,
    0x10,
    0x0A,
    0x08,
    0x0A,
    0x04,
    0x0A,
    0x02,
    0x0A,
    0x01,
    0x0B,
    0x80,
    0x0B,
    0x40,
    0x0B,
    0x20,
    0x0B,
    0x10,
    0x0B,
    0x08,
    0x0B,
    0x04,
    0xFA,
    0xFF,
    0xF9,
    0xFF,
    0xF8,
    0xFF,
    0xF7,
    0xFF,
    0xF6,
    0xFF,
    0xF5,
    0xFF,
    0x0B,
    0x02,
    0x0B,
    0x01,
    0x0C,
    0x80,
    0x0C,
    0x40,
    0x0C,
    0x20,
    0x0C,
    0x10,
    0x0C,
    0x08,
    0xF4,
    0xFF,
    0xF3,
    0xFF,
    0x0C,
    0x04,
    0x0C,
    0x02,
    0x0C,
    0x01,
    0x0D,
    0x80,
    0x0D,
    0x40,
    0x0D,
    0x20,
    0x0D,
    0x10,
    0x0D,
    0x08,
    0x0D,
    0x04,
    0x0D,
    0x02,
    0x0D,
    0x01,
    0x0E,
    0x80,
    0x0E,
    0x40,
    0x0E,
    0x20,
    0x0E,
    0x10,
    0x0E,
    0x08,
    0x0E,
    0x04,
    0x0E,
    0x02,
    0x0E,
    0x01,
    0x0F,
    0x80,
    0x0F,
    0x40,
    0x0F,
    0x20,
    0x0F,
    0x10,
    0x0F,
    0x08,
    0x0F,
    0x04,
    0x0F,
    0x02,
    0x0F,
    0x01,
    0x10,
    0x80,
    0x10,
    0x40,
    0x10,
    0x20,
    0x10,
    0x10,
    0x10,
    0x08,
    0x10,
    0x04,
    0x10,
    0x02,
    0x10,
    0x01,
    0x11,
    0x80,
    0x11,
    0x40,
    0x11,
    0x20,
    0x11,
    0x10,
    0x11,
    0x08,
    0x11,
    0x04,
    0x11,
    0x02,
    0x11,
    0x01,
    0x12,
    0x80,
    0x12,
    0x40,
    0x12,
    0x20,
    0x12,
    0x10,
    0x12,
    0x08,
    0x12,
    0x04,
    0x12,
    0x02,
    0x12,
    0x01,
    0x13,
    0x80,
    0x13,
    0x40,
    0x13,
    0x20,
    0x13,
    0x10,
    0x13,
    0x08,
    0x13,
    0x04,
    0x13,
    0x02,
    0x13,
    0x01,
    0x14,
    0x80,
    0x14,
    0x40,
    0x14,
    0x20,
    0x14,
    0x10,
    0x14,
    0x08,
    0x14,
    0x04,
    0x14,
    0x02,
    0x14,
    0x01,
    0x15,
    0x80,
    0xF2,
    0xFF,
    /* padding */
    0x00,
    0x00,
};
COMPILER_STRIP_GATE(0x803790C0, &dSv_event_tmp_flag_c::tempBitLabels);

/* 80379234-80379234 005894 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
