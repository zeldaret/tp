//
// Generated By: dol2asm
// Translation Unit: d/bg/d_bg_s_acch
//

// Temporary fix until the TU matches
#define __dt__12dBgS_AcchCirFv_DEFINED

#include "d/bg/d_bg_s_acch.h"
#include "d/a/d_a_player.h"
#include "d/bg/d_bg_s.h"
#include "dol2asm.h"
#include "f_op/f_op_actor_mng.h"
#include "global.h"

//
// Forward References:
//

extern "C" void __ct__12dBgS_AcchCirFv();
extern "C" void ClrWallHit__12dBgS_AcchCirFv();
extern "C" void SetWallR__12dBgS_AcchCirFf();
extern "C" void CalcWallRR__12dBgS_AcchCirFv();
extern "C" void SetWall__12dBgS_AcchCirFff();
extern "C" void SetWallHDirect__12dBgS_AcchCirFf();
extern "C" void __dt__9dBgS_AcchFv();
extern "C" void __ct__9dBgS_AcchFv();
extern "C" void Init__9dBgS_AcchFv();
extern "C" void Set__9dBgS_AcchFP4cXyzP4cXyzP10fopAc_ac_ciP12dBgS_AcchCirP4cXyzP5csXyzP5csXyz();
extern "C" void Set__9dBgS_AcchFP10fopAc_ac_ciP12dBgS_AcchCir();
extern "C" void GroundCheckInit__9dBgS_AcchFR4dBgS();
extern "C" void GroundCheck__9dBgS_AcchFR4dBgS();
extern "C" void GroundRoofProc__9dBgS_AcchFR4dBgS();
extern "C" void LineCheck__9dBgS_AcchFR4dBgS();
extern "C" void CrrPos__9dBgS_AcchFR4dBgS();
extern "C" void GetWallAllR__9dBgS_AcchFv();
extern "C" void SetWallCir__9dBgS_AcchFv();
extern "C" void CalcWallBmdCyl__9dBgS_AcchFv();
extern "C" void SetGroundUpY__9dBgS_AcchFf();
extern "C" void GetWallAllLowH__9dBgS_AcchFv();
extern "C" void GetWallAllLowH_R__9dBgS_AcchFv();
extern "C" void GetSpeedY__9dBgS_AcchFv();
extern "C" void GetWallAddY__9dBgS_AcchFR3Vec();
extern "C" void SetNowActorInfo__9dBgS_AcchFiPvUi();
extern "C" void SetWallPolyIndex__9dBgS_AcchFii();
extern "C" void CalcMovePosWork__9dBgS_AcchFv();
extern "C" void CalcWallRR__9dBgS_AcchFv();
extern "C" void SetMoveBGOnly__9dBgS_AcchFv();
extern "C" void ClrMoveBGOnly__9dBgS_AcchFv();
extern "C" void SetGndThinCellingOff__9dBgS_AcchFv();
extern "C" void ClrGndThinCellingOff__9dBgS_AcchFv();
extern "C" void ChkGndThinCellingOff__9dBgS_AcchFv();
extern "C" void OnWallSort__9dBgS_AcchFv();
extern "C" void ChkWallSort__9dBgS_AcchFv();
extern "C" void ChkLineDown__9dBgS_AcchFv();
extern "C" void __dt__12dBgS_AcchCirFv();
extern "C" static void func_80077484();
extern "C" static void func_8007748C();
extern "C" bool checkPlayerFly__9daPy_py_cCFv();

//
// External References:
//

extern "C" void LineCross__4cBgSFP11cBgS_LinChk();
extern "C" void GroundCross__4cBgSFP11cBgS_GndChk();
extern "C" void GetTriPla__4cBgSCFRC13cBgS_PolyInfoP8cM3dGPla();
extern "C" void WallCorrect__4dBgSFP9dBgS_Acch();
extern "C" void WallCorrectSort__4dBgSFP9dBgS_Acch();
extern "C" void RoofChk__4dBgSFP12dBgS_RoofChk();
extern "C" void SplGrpChk__4dBgSFP14dBgS_SplGrpChk();
extern "C" void MoveBgCrrPos__4dBgSFRC13cBgS_PolyInfobP4cXyzP5csXyzP5csXyzbb();
extern "C" void RideCallBack__4dBgSFRC13cBgS_PolyInfoP10fopAc_ac_c();
extern "C" void __ct__8dBgS_ChkFv();
extern "C" void __dt__8dBgS_ChkFv();
extern "C" void GetPolyPassChkInfo__8dBgS_ChkFv();
extern "C" void GetGrpPassChkInfo__8dBgS_ChkFv();
extern "C" void __ct__11dBgS_GndChkFv();
extern "C" void __dt__11dBgS_GndChkFv();
extern "C" void Set__14dBgS_SplGrpChkFR4cXyzf();
extern "C" void __dt__14dBgS_SplGrpChkFv();
extern "C" void SetPassChkInfo__16dBgS_PolyPassChkFR16dBgS_PolyPassChk();
extern "C" void SetUnderwaterRoof__16dBgS_PolyPassChkFv();
extern "C" void __ct__12dBgS_RoofChkFv();
extern "C" void __dt__12dBgS_RoofChkFv();
extern "C" void __ct__11dBgS_WtrChkFv();
extern "C" void __ct__8cBgS_ChkFv();
extern "C" void __dt__8cBgS_ChkFv();
extern "C" void SetExtChk__8cBgS_ChkFR8cBgS_Chk();
extern "C" void SetPos__11cBgS_GndChkFPC4cXyz();
extern "C" void __ct__11cBgS_LinChkFv();
extern "C" void __dt__11cBgS_LinChkFv();
extern "C" void Set2__11cBgS_LinChkFPC4cXyzPC4cXyzUi();
extern "C" void __ct__13cBgS_PolyInfoFv();
extern "C" void __dt__13cBgS_PolyInfoFv();
extern "C" void ClearPi__13cBgS_PolyInfoFv();
extern "C" void SetActorInfo__13cBgS_PolyInfoFiPvUi();
extern "C" void SetPolyIndex__13cBgS_PolyInfoFi();
extern "C" void cBgW_CheckBGround__Ff();
extern "C" void __ct__8cM3dGCirFv();
extern "C" void __dt__8cM3dGCirFv();
extern "C" void Set__8cM3dGCirFffff();
extern "C" void Set__8cM3dGCylFRC4cXyzff();
extern "C" void SetStartEnd__8cM3dGLinFRC4cXyzRC4cXyz();
extern "C" void getCrossYLessD__8cM3dGPlaCFRC3VecPf();
extern "C" void __dl__FPv();
extern "C" void __register_global_object();
extern "C" void _savegpr_25();
extern "C" void _savegpr_29();
extern "C" void _restgpr_25();
extern "C" void _restgpr_29();
extern "C" extern void* __vt__8cM3dGPla[3];
extern "C" extern void* __vt__11dBgS_WtrChk[12];
extern "C" extern void* __vt__8cM3dGCyl[3];
extern "C" extern void* __vt__8cM3dGLin[3];
extern "C" extern u8 g_dComIfG_gameInfo[122384];
extern "C" extern s8 data_80450F68;

//
// Declarations:
//

/* ############################################################################################## */
/* 803AB640-803AB664 008760 0024+00 2/2 0/0 0/0 .data            __vt__9dBgS_Acch */
SECTION_DATA extern void* __vt__9dBgS_Acch[9] = {
    (void*)NULL /* RTTI */,
    (void*)NULL,
    (void*)__dt__9dBgS_AcchFv,
    (void*)NULL,
    (void*)NULL,
    (void*)func_8007748C,
    (void*)NULL,
    (void*)NULL,
    (void*)func_80077484,
};

/* 803AB664-803AB670 008784 000C+00 2/2 3/3 0/0 .data            __vt__12dBgS_AcchCir */
SECTION_DATA extern void* __vt__12dBgS_AcchCir[3] = {
    (void*)NULL /* RTTI */,
    (void*)NULL,
    (void*)__dt__12dBgS_AcchCirFv,
};

/* 804526C0-804526C4 000CC0 0004+00 11/11 0/0 0/0 .sdata2          @4025 */
SECTION_SDATA2 static u8 lit_4025[4] = {
    0x00,
    0x00,
    0x00,
    0x00,
};

/* 80075EAC-80075F14 0707EC 0068+00 0/0 4/4 336/336 .text            __ct__12dBgS_AcchCirFv */
dBgS_AcchCir::dBgS_AcchCir() {
    m_flags = 0;
    f32 tmp_0 = FLOAT_LABEL(lit_4025);
    m_wall_rr = tmp_0;
    field_0x2c = tmp_0;
    m_wall_h = tmp_0;
    m_wall_r = tmp_0;
    m_wall_angle_y = 0;
    m_wall_h_direct = tmp_0;
}

/* 80075F14-80075F40 070854 002C+00 1/1 0/0 0/0 .text            ClrWallHit__12dBgS_AcchCirFv */
void dBgS_AcchCir::ClrWallHit() {
    m_flags &= ~WALL_HIT;
    ClearPi();
}

/* 80075F40-80075F48 070880 0008+00 1/1 2/2 109/109 .text            SetWallR__12dBgS_AcchCirFf */
void dBgS_AcchCir::SetWallR(f32 r) {
    m_wall_r = r;
}

/* 80075F48-80075F58 070888 0010+00 1/1 0/0 0/0 .text            CalcWallRR__12dBgS_AcchCirFv */
void dBgS_AcchCir::CalcWallRR() {
    m_wall_rr = m_wall_r * m_wall_r;
}

/* 80075F58-80075F80 070898 0028+00 0/0 3/3 272/272 .text            SetWall__12dBgS_AcchCirFff */
void dBgS_AcchCir::SetWall(f32 wall_h, f32 wall_r) {
    SetWallH(wall_h);
    SetWallR(wall_r);
}

/* 80075F80-80075F94 0708C0 0014+00 1/1 0/0 1/1 .text            SetWallHDirect__12dBgS_AcchCirFf */
void dBgS_AcchCir::SetWallHDirect(f32 h_direct) {
    m_flags |= WALL_H_DIRECT;
    m_wall_h_direct = h_direct;
}

/* 80075F94-800760A0 0708D4 010C+00 3/2 6/6 468/468 .text            __dt__9dBgS_AcchFv */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
// asm dBgS_Acch::~dBgS_Acch() {
extern "C" asm void __dt__9dBgS_AcchFv() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/__dt__9dBgS_AcchFv.s"
}
#pragma pop

/* ############################################################################################## */
/* 804526C4-804526C8 000CC4 0004+00 5/5 0/0 0/0 .sdata2          @4089 */
SECTION_SDATA2 static f32 lit_4089 = -1000000000.0f;

/* 804526C8-804526CC 000CC8 0004+00 1/1 0/0 0/0 .sdata2          @4090 */
SECTION_SDATA2 static f32 lit_4090 = 60.0f;

/* 804526CC-804526D0 000CCC 0004+00 3/3 0/0 0/0 .sdata2          @4091 */
SECTION_SDATA2 static f32 lit_4091 = 1000000000.0f;

/* 804526D0-804526D4 000CD0 0004+00 1/1 0/0 0/0 .sdata2          @4092 */
SECTION_SDATA2 static f32 lit_4092 = 1000.0f;

/* 800760A0-800761CC 0709E0 012C+00 0/0 4/4 338/338 .text            __ct__9dBgS_AcchFv */
// matches with literals
#ifdef NONMATCHING
dBgS_Acch::dBgS_Acch() {
    SetPolyPassChk(GetPolyPassChkInfo());
    SetGrpPassChk(GetGrpPassChkInfo());

    m_flags = 0;
    SetRoofNone();

    pm_pos = NULL;
    pm_old_pos = NULL;
    pm_speed = NULL;
    m_ground_h = -1000000000.0f;
    field_0x90 = 0.0f;
    field_0x9c = 60.0f;
    field_0x94 = 0.0f;
    field_0xb4 = 0;
    field_0xb8 = 0.0f;
    field_0xbc = 0.0f;

    m_tbl_size = 0;
    field_0x8c = NULL;

    m_roof_height = 1000000000.0f;
    m_roof_crr_height = 0.0f;
    field_0xcc = 0.0f;

    m_wtr_mode = 1;
    m_wtr_chk_offset = 1000.0f;

    pm_angle = NULL;
    pm_shape_angle = NULL;
    m_my_ac = NULL;
    field_0xd4 = 0;
    field_0xd8 = -1000000000.0f;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm dBgS_Acch::dBgS_Acch() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/__ct__9dBgS_AcchFv.s"
}
#pragma pop
#endif

/* 800761CC-80076248 070B0C 007C+00 1/1 0/0 0/0 .text            Init__9dBgS_AcchFv */
void dBgS_Acch::Init() {
    ClrWallHit();
    for (int i = 0; i < m_tbl_size; i++) {
        static_cast<dBgS_AcchCir*>(field_0x8c + i)->ClrWallHit();
        static_cast<dBgS_AcchCir*>(field_0x8c + i)->ClrWallHDirect();
    }
}

/* 80076248-80076288 070B88 0040+00 0/0 2/2 314/314 .text
 * Set__9dBgS_AcchFP4cXyzP4cXyzP10fopAc_ac_ciP12dBgS_AcchCirP4cXyzP5csXyzP5csXyz */
void dBgS_Acch::Set(cXyz* p_pos, cXyz* p_old_pos, fopAc_ac_c* p_actor, int table_size,
                    dBgS_AcchCir* param_4, cXyz* p_speed, csXyz* p_angle, csXyz* p_shape_angle) {
    pm_pos = p_pos;
    pm_old_pos = p_old_pos;
    m_my_ac = p_actor;
    setActorPid(fopAcM_GetID(p_actor));
    pm_speed = p_speed;
    m_tbl_size = table_size;
    field_0x8c = param_4;
    pm_angle = p_angle;
    pm_shape_angle = p_shape_angle;
}

/* 80076288-800762D8 070BC8 0050+00 0/0 1/1 7/7 .text
 * Set__9dBgS_AcchFP10fopAc_ac_ciP12dBgS_AcchCir                */
void dBgS_Acch::Set(fopAc_ac_c* p_actor, int table_size, dBgS_AcchCir* param_2) {
    m_tbl_size = table_size;
    field_0x8c = param_2;
    m_my_ac = p_actor;

    setActorPid(fopAcM_GetID(p_actor));
    pm_pos = &fopAcM_GetPosition_p(p_actor);
    pm_old_pos = &fopAcM_GetOldPosition_p(p_actor);
    pm_speed = &fopAcM_GetSpeed_p(p_actor);
    pm_angle = &fopAcM_GetAngle_p(p_actor);
    pm_shape_angle = &fopAcM_GetShapeAngle_p(p_actor);
}

/* 800762D8-80076350 070C18 0078+00 1/1 0/0 0/0 .text            GroundCheckInit__9dBgS_AcchFR4dBgS
 */
void dBgS_Acch::GroundCheckInit(dBgS& param_0) {
    if (!(m_flags & 2)) {
        m_ground_h = lit_4089;
        m_gnd.SetExtChk(static_cast<cBgS_Chk&>(*this));
        field_0xb4 = ChkGroundHit();
        i_ClrGroundHit();
        ClrGroundLanding();
        ClrGroundAway();
    }
}

/* 80076350-8007654C 070C90 01FC+00 2/2 0/0 0/0 .text            GroundCheck__9dBgS_AcchFR4dBgS */
// issues with tmpRoofChk
#ifdef NONMATCHING
/* 80424B2C-80424B80 05184C 0050+04 1/1 0/0 0/0 .bss             tmpRoofChk$4165 */
static dBgS_RoofChk tmpRoofChk;

void dBgS_Acch::GroundCheck(dBgS& param_0) {
    if (!(m_flags & GRND_NONE)) {
        cXyz grnd_pos;
        grnd_pos.x = pm_pos->x;
        grnd_pos.y = pm_pos->y;
        grnd_pos.z = pm_pos->z;
        grnd_pos.y += field_0x94 + (field_0x9c - field_0x90);

        if (!ChkGndThinCellingOff()) {
            if (data_80450F68 == 0) {
                dBgS_RoofChk tmpRoofChk;
                data_80450F68 = 1;
            }
            tmpRoofChk.setActorPid(m_gnd.GetActorPid());
            tmpRoofChk.i_SetPos(*pm_pos);
            f32 tmp = param_0.RoofChk(&tmpRoofChk);
            if (grnd_pos.y > tmp) {
                grnd_pos.y = tmp;
            }
        }
        field_0x94 = 0.0f;
        m_gnd.SetPos(&grnd_pos);
        m_ground_h = param_0.GroundCross(&m_gnd);

        if (lit_4089 != m_ground_h) {
            field_0xbc = m_ground_h + field_0x90;
            if (field_0xbc > field_0xb8) {
                pm_pos->y = field_0xbc;
                if (ChkClrSpeedY() && pm_speed != NULL) {
                    pm_speed->y = 0.0f;
                }
                param_0.GetTriPla(m_gnd, &field_0xa0);
                SetGroundFind();
                SetGroundHit();
                if (field_0xc0 == 0) {
                    field_0xc0 = 1;
                    param_0.RideCallBack(m_gnd, m_my_ac);
                }
                if (field_0xb4 == 0) {
                    SetGroundLanding();
                }
            }
            if (field_0xb4 && !ChkGroundHit()) {
                SetGroundAway();
            }
        }
    }
}
#else
/* ############################################################################################## */
/* 80424B20-80424B2C 051840 000C+00 1/1 0/0 0/0 .bss             @4166 */
static u8 lit_4166[12];

/* 80424B2C-80424B80 05184C 0050+04 1/1 0/0 0/0 .bss             tmpRoofChk$4165 */
static u8 tmpRoofChk[80 + 4 /* padding */];

#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dBgS_Acch::GroundCheck(dBgS& param_0) {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/GroundCheck__9dBgS_AcchFR4dBgS.s"
}
#pragma pop
#endif

/* 8007654C-80076624 070E8C 00D8+00 1/1 0/0 0/0 .text            GroundRoofProc__9dBgS_AcchFR4dBgS
 */
void dBgS_Acch::GroundRoofProc(dBgS& param_0) {
    if (lit_4089 != m_ground_h) {
        if (field_0xbc < field_0xcc && field_0xcc < pm_pos->y) {
            pm_pos->y = field_0xcc;
        }

        if (!(m_flags & ROOF_NONE) && m_ground_h >= m_roof_height) {
            m_roof.SetExtChk(static_cast<cBgS_Chk&>(*this));
            ClrRoofHit();
            cXyz roof_pos;
            roof_pos.x = pm_pos->x;
            roof_pos.y = pm_pos->y;
            roof_pos.z = pm_pos->z;
            m_roof.i_SetPos(roof_pos);
            m_roof_height = param_0.RoofChk(&m_roof);
        }
    }
}

/* ############################################################################################## */
/* 804526D4-804526D8 000CD4 0004+00 1/1 0/0 0/0 .sdata2          @4424 */
SECTION_SDATA2 static f32 lit_4424 = 1.0f;

/* 80076624-80076AAC 070F64 0488+00 1/1 0/0 0/0 .text            LineCheck__9dBgS_AcchFR4dBgS */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dBgS_Acch::LineCheck(dBgS& param_0) {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/LineCheck__9dBgS_AcchFR4dBgS.s"
}
#pragma pop

/* ############################################################################################## */
/* 804526D8-804526DC 000CD8 0004+00 1/1 0/0 0/0 .sdata2          @4554 */
SECTION_SDATA2 static f32 lit_4554 = 50.0f;

/* 804526DC-804526E0 000CDC 0004+00 1/1 0/0 0/0 .sdata2          @4555 */
SECTION_SDATA2 static f32 lit_4555 = 1000000.0f;

/* 80076AAC-80076F84 0713EC 04D8+00 0/0 15/15 414/414 .text            CrrPos__9dBgS_AcchFR4dBgS */
// close
#ifdef NONMATCHING
void dBgS_Acch::CrrPos(dBgS& param_0) {
    bool bvar9;
    if (!(m_flags & 1)) {
        param_0.MoveBgCrrPos(m_gnd, ChkGroundHit(), pm_pos, pm_angle, pm_shape_angle, false, false);

        if (!ChkGroundHit()) {
            bvar9 = false;

            if (ChkWallHit()) {
                for (int i = 0; i < m_tbl_size; i++) {
                    if (static_cast<dBgS_AcchCir*>(field_0x8c + i)->ChkWallHit()) {
                        param_0.MoveBgCrrPos(*static_cast<dBgS_AcchCir*>(field_0x8c + i), true,
                                             pm_pos, pm_angle, pm_shape_angle, true, false);
                        bvar9 = true;
                        break;
                    }
                }
            }
            if (!bvar9 && ChkRoofHit()) {
                param_0.MoveBgCrrPos(m_roof, true, pm_pos, pm_angle, pm_shape_angle, false, true);
            }
        }

        GroundCheckInit(param_0);
        Init();

        f32 tmp = GetWallAllLowH_R();
        f32 dvar10 = GetOldPos()->abs2XZ(*GetPos());
        f32 dvar11 = GetOldPos()->y - GetPos()->y;
        f32 tmp2 = GetWallAllLowH();

        field_0xb8 = GetPos()->y;
        field_0xc0 = 0;
        f32 fvar12 = tmp2 + GetOldPos()->y;
        f32 fvar1 = field_0x9c + GetPos()->y;
        bool bvar2 = false;

        OffLineCheckHit();
        if (!ChkLineCheckNone() && !cM3d_IsZero(tmp) &&
            (dvar10 > (tmp * tmp) || fvar12 > fvar1 || dvar11 > field_0x9c || ChkLineCheck())) {
            bvar2 = true;
            LineCheck(param_0);
        }

        if (!(m_flags & WALL_NONE)) {
            if (ChkWallSort()) {
                param_0.WallCorrectSort(this);
            } else {
                param_0.WallCorrect(this);
            }
        }

        if (ChkWallHit() && bvar2) {
            LineCheck(param_0);
        }
        field_0xcc = 1000000000.0f;

        if (!(m_flags & ROOF_NONE)) {
            m_roof.SetExtChk(static_cast<cBgS_Chk&>(*this));
            ClrRoofHit();
            cXyz roof_pos;
            roof_pos.x = pm_pos->x;
            roof_pos.y = pm_pos->y;
            roof_pos.z = pm_pos->z;

            m_roof.i_SetPos(roof_pos);
            m_roof_height = param_0.RoofChk(&m_roof);

            // register issues
            if (1000000000.0f != m_roof_height && GetPos()->y > 1000000000.0f + m_roof_crr_height) {
                field_0xcc = m_roof_height - m_roof_crr_height;
                SetRoofHit();
            }
        }

        if (!(m_flags & GRND_NONE)) {
            ClrGroundFind();
            GroundCheck(param_0);
            GroundRoofProc(param_0);
        } else {
            if (field_0xcc < GetPos()->y) {
                GetPos()->y = field_0xcc;
            }
        }

        if (!(m_flags & 0x400)) {
            ClrWaterHit();
            ClrWaterIn();
            f32 tmp4 = -1000000000.0f;
            m_wtr.SetHeight(-1000000000.0f);

            f32 tmp3 = m_ground_h;
            if (tmp4 == tmp3) {
                tmp3 = GetPos()->y - 50.0f;  // register issues
            } else {
                tmp3 = 50.0f;  // needs to be fmr
            }

            if (m_wtr_mode == 1) {
                tmp4 = tmp3 + m_wtr_chk_offset;
            } else {
                dBgS_RoofChk roof_chk;
                roof_chk.SetUnderwaterRoof();
                roof_chk.i_SetPos(*pm_pos);
                tmp4 = param_0.RoofChk(&roof_chk);
                if (1000000000.0f == tmp4) {
                    tmp4 = GetPos()->y + 1000000.0f;
                }
            }
            cXyz xyz;
            xyz.x = pm_pos->x;
            xyz.y = pm_pos->y;
            xyz.z = pm_pos->z;
            xyz.y = tmp3;

            m_wtr.Set(xyz, tmp4);
            m_wtr.SetPassChkInfo(static_cast<dBgS_PolyPassChk&>(*this));
            if (param_0.WaterChk(&m_wtr)) {
                SetWaterHit();
                if (m_wtr.GetHeight() > GetPos()->y) {
                    SetWaterIn();
                }
            }
        }
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dBgS_Acch::CrrPos(dBgS& param_0) {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/CrrPos__9dBgS_AcchFR4dBgS.s"
}
#pragma pop
#endif

/* 80076F84-80076FC0 0718C4 003C+00 1/1 0/0 0/0 .text            GetWallAllR__9dBgS_AcchFv */
f32 dBgS_Acch::GetWallAllR() {
    f32 ret = FLOAT_LABEL(lit_4025);

    for (int i = 0; i < m_tbl_size; i++) {
        f32 wall_r = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallR();
        if (ret < wall_r) {
            ret = wall_r;
        }
    }
    return ret;
}

/* 80076FC0-8007703C 071900 007C+00 1/1 0/0 0/0 .text            SetWallCir__9dBgS_AcchFv */
void dBgS_Acch::SetWallCir() {
    for (int i = 0; i < m_tbl_size; i++) {
        static_cast<dBgS_AcchCir*>(field_0x8c + i)->SetCir(*pm_pos);
    }
}

/* 8007703C-80077114 07197C 00D8+00 1/1 0/0 0/0 .text            CalcWallBmdCyl__9dBgS_AcchFv */
// matches with literals
#ifdef NONMATCHING
void dBgS_Acch::CalcWallBmdCyl() {
    if (m_tbl_size <= 0) {
        m_wall_cyl.Set(*pm_pos, 0.0f, 0.0f);
    } else {
        f32 dvar8 = GetWallAllR();
        f32 dvar9 = field_0x8c->GetWallH();
        f32 dvar10 = field_0x8c->GetWallH();
        if (m_tbl_size >= 1) {
            for (int i = 0; i < m_tbl_size; i++) {
                f32 tmp = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
                if (dvar9 > tmp) {
                    dvar9 = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
                }

                f32 tmp2 = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
                if (dvar10 < tmp2) {
                    dvar10 = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
                }
            }
        }
        cXyz xyz;
        xyz.x = pm_pos->x;
        xyz.y = pm_pos->y;
        xyz.z = pm_pos->z;
        xyz.y += dvar9;

        m_wall_cyl.Set(xyz, dvar8, dvar10 - dvar9);
    }
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void dBgS_Acch::CalcWallBmdCyl() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/CalcWallBmdCyl__9dBgS_AcchFv.s"
}
#pragma pop
#endif

/* 80077114-80077128 071A54 0014+00 0/0 0/0 24/24 .text            SetGroundUpY__9dBgS_AcchFf */
void dBgS_Acch::SetGroundUpY(f32 param_0) {
    field_0x94 = param_0 - field_0x90;
    field_0x90 = param_0;
}

/* 80077128-80077178 071A68 0050+00 1/1 0/0 0/0 .text            GetWallAllLowH__9dBgS_AcchFv */
f32 dBgS_Acch::GetWallAllLowH() {
    if (m_tbl_size <= 0) {
        return FLOAT_LABEL(lit_4025);
    }

    f32 tmp = field_0x8c->GetWallH();
    for (int i = 1; i < m_tbl_size; i++) {
        f32 tmp2 = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
        if (tmp > tmp2) {
            tmp = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
        }
    }
    return tmp;
}

/* 80077178-800771E4 071AB8 006C+00 1/1 0/0 0/0 .text            GetWallAllLowH_R__9dBgS_AcchFv */
f32 dBgS_Acch::GetWallAllLowH_R() {
    if (m_tbl_size <= 0) {
        return FLOAT_LABEL(lit_4025);
    }

    int index = 0;
    f32 tmp = field_0x8c->GetWallH();
    for (int i = 1; i < m_tbl_size; i++) {
        f32 tmp2 = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
        if (tmp > tmp2) {
            tmp = static_cast<dBgS_AcchCir*>(field_0x8c + i)->GetWallH();
            index = i;
        }
    }
    return static_cast<dBgS_AcchCir*>(field_0x8c + index)->GetWallR();
}

/* 800771E4-80077200 071B24 001C+00 1/1 4/4 0/0 .text            GetSpeedY__9dBgS_AcchFv */
f32 dBgS_Acch::GetSpeedY() {
    if (pm_speed != NULL) {
        return pm_speed->y;
    }
    return FLOAT_LABEL(lit_4025);
}

/* ############################################################################################## */
/* 804526E0-804526E8 000CE0 0004+04 1/1 0/0 0/0 .sdata2          @4762 */
SECTION_SDATA2 static f32 lit_4762[1 + 1 /* padding */] = {
    0.5f,
    /* padding */
    0.0f,
};

/* 80077200-80077278 071B40 0078+00 0/0 4/4 0/0 .text            GetWallAddY__9dBgS_AcchFR3Vec */
// matches with literals
#ifdef NONMATCHING
f32 dBgS_Acch::GetWallAddY(Vec& param_0) {
    if (!ChkGroundFind() || field_0xa0.mNormal.y < 0.5f) {
        return 0.0f;
    }

    f32 tmp;
    if (field_0xa0.getCrossYLessD(param_0, &tmp)) {
        if (tmp > 0.0f) {
            tmp = 0.0f;
        }
        return -tmp;
    }
    return 0.0f;
}
#else
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm f32 dBgS_Acch::GetWallAddY(Vec& param_0) {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/GetWallAddY__9dBgS_AcchFR3Vec.s"
}
#pragma pop
#endif

/* 80077278-80077288 071BB8 0010+00 0/0 2/2 0/0 .text            SetNowActorInfo__9dBgS_AcchFiPvUi
 */
void dBgS_Acch::SetNowActorInfo(int bg_index, void* param_1, unsigned int param_2) {
    m_bg_index = bg_index;
    field_0x7c = param_1;
    field_0x80 = param_2;
}

/* 80077288-800772E8 071BC8 0060+00 0/0 4/4 0/0 .text            SetWallPolyIndex__9dBgS_AcchFii */
void dBgS_Acch::SetWallPolyIndex(int index, int poly_index) {
    static_cast<dBgS_AcchCir*>(field_0x8c + index)
        ->SetActorInfo(m_bg_index, field_0x7c, field_0x80);
    static_cast<dBgS_AcchCir*>(field_0x8c + index)->SetPolyIndex(poly_index);
}

/* 800772E8-8007732C 071C28 0044+00 0/0 6/6 0/0 .text            CalcMovePosWork__9dBgS_AcchFv */
void dBgS_Acch::CalcMovePosWork() {
    SetWallCir();
    SetLin();
    CalcWallBmdCyl();
}

/* 8007732C-80077388 071C6C 005C+00 0/0 2/2 0/0 .text            CalcWallRR__9dBgS_AcchFv */
void dBgS_Acch::CalcWallRR() {
    for (int i = 0; i < m_tbl_size; i++) {
        static_cast<dBgS_AcchCir*>(field_0x8c + i)->CalcWallRR();
    }
}

/* 80077388-800773A4 071CC8 001C+00 0/0 1/1 0/0 .text            SetMoveBGOnly__9dBgS_AcchFv */
void dBgS_Acch::SetMoveBGOnly() {
    m_flags |= MOVE_BG_ONLY;
    m_wtr.OnMoveBGOnly();
}

/* 800773A4-800773C0 071CE4 001C+00 0/0 4/4 17/17 .text            ClrMoveBGOnly__9dBgS_AcchFv */
void dBgS_Acch::ClrMoveBGOnly() {
    m_flags &= ~MOVE_BG_ONLY;
    m_wtr.OffMoveBGOnly();
}

/* 800773C0-800773D0 071D00 0010+00 0/0 1/1 2/2 .text            SetGndThinCellingOff__9dBgS_AcchFv
 */
void dBgS_Acch::SetGndThinCellingOff() {
    m_flags |= GND_THIN_CELLING_OFF;
}

/* 800773D0-800773E0 071D10 0010+00 0/0 1/1 0/0 .text            ClrGndThinCellingOff__9dBgS_AcchFv
 */
void dBgS_Acch::ClrGndThinCellingOff() {
    m_flags &= ~GND_THIN_CELLING_OFF;
}

/* 800773E0-800773EC 071D20 000C+00 1/1 0/0 0/0 .text            ChkGndThinCellingOff__9dBgS_AcchFv
 */
bool dBgS_Acch::ChkGndThinCellingOff() {
    return m_flags & GND_THIN_CELLING_OFF;
}

/* 800773EC-800773FC 071D2C 0010+00 0/0 1/1 1/1 .text            OnWallSort__9dBgS_AcchFv */
void dBgS_Acch::OnWallSort() {
    m_flags |= WALL_SORT;
}

/* 800773FC-80077408 071D3C 000C+00 1/1 0/0 0/0 .text            ChkWallSort__9dBgS_AcchFv */
bool dBgS_Acch::ChkWallSort() {
    return m_flags & WALL_SORT;
}

/* 80077408-80077414 071D48 000C+00 1/1 0/0 0/0 .text            ChkLineDown__9dBgS_AcchFv */
bool dBgS_Acch::ChkLineDown() {
    return m_flags & LINE_DOWN;
}

/* 80077414-80077484 071D54 0070+00 1/0 2/2 0/0 .text            __dt__12dBgS_AcchCirFv */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
// asm dBgS_AcchCir::~dBgS_AcchCir() {
extern "C" asm void __dt__12dBgS_AcchCirFv() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/__dt__12dBgS_AcchCirFv.s"
}
#pragma pop

/* 80077484-8007748C 071DC4 0008+00 1/0 0/0 0/0 .text            @36@__dt__9dBgS_AcchFv */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void func_80077484() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/func_80077484.s"
}
#pragma pop

/* 8007748C-80077494 071DCC 0008+00 1/0 0/0 0/0 .text            @20@__dt__9dBgS_AcchFv */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
static asm void func_8007748C() {
    nofralloc
#include "asm/d/bg/d_bg_s_acch/func_8007748C.s"
}
#pragma pop

/* 80077494-8007749C 071DD4 0008+00 0/0 1/0 0/0 .text            checkPlayerFly__9daPy_py_cCFv */
u32 daPy_py_c::checkPlayerFly() const {
    return 0;
}
