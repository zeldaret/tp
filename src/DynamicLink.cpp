//
// Generated By: dol2asm
// Translation Unit: DynamicLink
//

#include "DynamicLink.h"
#include "JSystem/JKernel/JKRDvdRipper.h"
#include "JSystem/JUtility/JUTConsole.h"
#include "MSL_C.PPCEABI.bare.H/MSL_Common/Src/printf.h"
#include "dol2asm.h"
#include "dolphin/os/OS.h"
#include "dolphin/types.h"
#include "m_Do/m_Do_ext.h"

//
// Forward References:
//

extern "C" void __dt__24DynamicModuleControlBaseFv();
extern "C" void __ct__24DynamicModuleControlBaseFv();
extern "C" void link__24DynamicModuleControlBaseFv();
extern "C" void unlink__24DynamicModuleControlBaseFv();
extern "C" void load_async__24DynamicModuleControlBaseFv();
extern "C" void force_unlink__24DynamicModuleControlBaseFv();
extern "C" void dump__24DynamicModuleControlBaseFv();
extern "C" void __ct__20DynamicModuleControlFPCc();
extern "C" void mountCallback__20DynamicModuleControlFPv();
extern "C" void initialize__20DynamicModuleControlFv();
extern "C" void callback__20DynamicModuleControlFPv();
extern "C" static void calcSum2__FPCUsUl();
extern "C" void do_load__20DynamicModuleControlFv();
extern "C" void do_load_async__20DynamicModuleControlFv();
extern "C" void do_unload__20DynamicModuleControlFv();
extern "C" void dump2__20DynamicModuleControlFv();
extern "C" void do_link__20DynamicModuleControlFv();
extern "C" void do_unlink__20DynamicModuleControlFv();
extern "C" void getModuleSize__20DynamicModuleControlCFv();
extern "C" void getModuleTypeString__20DynamicModuleControlCFv();
extern "C" void ModuleProlog();
extern "C" void ModuleEpilog();
extern "C" void ModuleUnresolved();
extern "C" void ModuleConstructorsX(void (**ctors)());
extern "C" void ModuleDestructorsX(void (**dtors)());
extern "C" bool do_link__24DynamicModuleControlBaseFv();
extern "C" bool do_load__24DynamicModuleControlBaseFv();
extern "C" bool do_unload__24DynamicModuleControlBaseFv();
extern "C" bool do_unlink__24DynamicModuleControlBaseFv();
extern "C" bool do_load_async__24DynamicModuleControlBaseFv();
extern "C" void dump2__24DynamicModuleControlBaseFv();
extern "C" void getModuleTypeString__24DynamicModuleControlBaseCFv();
extern "C" bool getModuleSize__24DynamicModuleControlBaseCFv();
extern "C" void getModuleName__20DynamicModuleControlCFv();
extern "C" extern char const* const DynamicLink__stringBase0;
extern "C" u8 mFirst__24DynamicModuleControlBase[4];
extern "C" u8 mLast__24DynamicModuleControlBase[4];
extern "C" u8 sAllocBytes__20DynamicModuleControl[4];
extern "C" u8 sArchive__20DynamicModuleControl[4];
extern "C" u8 sFileCache__20DynamicModuleControl[4 + 4 /* padding */];

//
// External References:
//

extern "C" void mDoExt_getArchiveHeap__Fv();
extern "C" void create__20mDoDvdThd_callback_cFPFPv_PvPv();
extern "C" bool getModuleName__24DynamicModuleControlBaseCFv();
extern "C" void __dt__20DynamicModuleControlFv();
extern "C" void alloc__7JKRHeapFUliP7JKRHeap();
extern "C" void free__7JKRHeapFPvP7JKRHeap();
extern "C" void resize__7JKRHeapFPvUlP7JKRHeap();
extern "C" void getSize__7JKRHeapFPvP7JKRHeap();
extern "C" void __dl__FPv();
extern "C" void detachResource__13JKRFileLoaderFPvP13JKRFileLoader();
extern "C" void mount__12JKRFileCacheFPCcP7JKRHeapPCc();
extern "C" void
mount__10JKRArchiveFPCcQ210JKRArchive10EMountModeP7JKRHeapQ210JKRArchive15EMountDirection();
extern "C" void getGlbResource__10JKRArchiveFUlPCcP10JKRArchive();
extern "C" void
loadToMainRAM__12JKRDvdRipperFPCcPUc15JKRExpandSwitchUlP7JKRHeapQ212JKRDvdRipper15EAllocDirectionUlPiPUl();
extern "C" void _savegpr_26();
extern "C" void _savegpr_28();
extern "C" void _savegpr_29();
extern "C" void _restgpr_26();
extern "C" void _restgpr_28();
extern "C" void _restgpr_29();

//
// Declarations:
//

extern "C" void* __vt__20DynamicModuleControl[13];
extern "C" void* __vt__24DynamicModuleControlBase[13];

/* 80451138-8045113C 000638 0004+00 3/3 0/0 0/0 .sbss            mFirst__24DynamicModuleControlBase
 */
DynamicModuleControlBase* DynamicModuleControlBase::mFirst;

/* 8045113C-80451140 00063C 0004+00 2/2 0/0 0/0 .sbss            mLast__24DynamicModuleControlBase
 */
DynamicModuleControlBase* DynamicModuleControlBase::mLast;

/* 802621CC-80262284 25CB0C 00B8+00 1/0 2/2 0/0 .text            __dt__24DynamicModuleControlBaseFv
 */
DynamicModuleControlBase::~DynamicModuleControlBase() {
    force_unlink();
    if (mPrev != NULL) {
        mPrev->mNext = mNext;
    }
    if (mNext != NULL) {
        mNext->mPrev = mPrev;
    }
    if (mFirst == this) {
        mFirst = mNext;
    }
    if (mLast == this) {
        mLast = mPrev;
    }
    mNext = NULL;
    mPrev = NULL;
}

/* 80262284-802622D0 25CBC4 004C+00 1/1 0/0 0/0 .text            __ct__24DynamicModuleControlBaseFv
 */
DynamicModuleControlBase::DynamicModuleControlBase() {
    mLinkCount = 0;
    mDoLinkCount = 0;
    mNext = NULL;
    if (mFirst == NULL) {
        mFirst = this;
    }
    mPrev = mLast;
    if (mPrev != NULL) {
        mPrev->mNext = this;
    }
    mLast = this;
}

/* 802622D0-80262364 25CC10 0094+00 0/0 2/2 0/0 .text            link__24DynamicModuleControlBaseFv
 */
bool DynamicModuleControlBase::link() {
    if (mLinkCount == 0) {
        do_load();
        if (do_link() == false) {
            return false;
        }
        if (mDoLinkCount < 0xFFFF) {
            mDoLinkCount++;
        }
    }
    if (mLinkCount < 0xFFFF) {
        mLinkCount++;
    }
    return true;
}

/* 80262364-802623EC 25CCA4 0088+00 0/0 1/1 0/0 .text unlink__24DynamicModuleControlBaseFv */
bool DynamicModuleControlBase::unlink() {
    if (mLinkCount != 0) {
        mLinkCount--;
        if (mLinkCount == 0) {
            do_unlink();
            do_unload();
        }
    } else {
        OSReport_Warning("%08x DynamicModuleControlBase::unlink() mLinkCount id already zero.\n",
                         this);
    }
    return true;
}

/* 802623EC-8026242C 25CD2C 0040+00 0/0 1/1 0/0 .text load_async__24DynamicModuleControlBaseFv */
bool DynamicModuleControlBase::load_async() {
    if (mLinkCount == 0) {
        return do_load_async();
    }
    return true;
}

/* 8026242C-80262470 25CD6C 0044+00 1/1 0/0 0/0 .text force_unlink__24DynamicModuleControlBaseFv
 */
bool DynamicModuleControlBase::force_unlink() {
    if (mLinkCount != 0) {
        mLinkCount = 0;
        do_unlink();
    }
    return true;
}

#ifdef NONMATCHING
void DynamicModuleControlBase::dump() {
    DynamicModuleControlBase* current = getFirstClass();
    int totalSize = 0;
    JUTReportConsole_f("\nDynamicModuleControlBase::dump()\n");
    JUTReportConsole_f("Do  Lnk Size      Name\n");
    // lbl_80262608
    while (current != NULL) {
        // lbl_802624B8
        u16 doLinkCount = current->mDoLinkCount;
        u16 linkCount = current->mLinkCount;
        if (doLinkCount != 0 || linkCount != 0) {
            // lbl_802624D0
            u32 size = current->getModuleSize();
            const char* name = current->getModuleName();
            if (size < 0xFFFFFFFF) {
                name = (name != NULL) ? name : "(Null)";
                // lbl_80262524
                const char* type = current->getModuleTypeString();
                JUTReportConsole_f("%3d%3d%5.1f %05x %-4s %-24s ", doLinkCount, linkCount,
                                   size * (1.0f / 1024.0f), size, type, name);
                totalSize = totalSize + size;
            } else {
                // lbl_80262588
                name = (name != NULL) ? name : "(Null)";
                // lbl_802625A4
                const char* type = current->getModuleTypeString();
                JUTReportConsole_f("%3d%3d ???? ????? %-4s %-24s ", doLinkCount, linkCount, type,
                                   name);
            }
            // lbl_802625DC
            current->dump2();
            JUTReportConsole_f("\n");
        }
        // lbl_80262604
        current = getNextClass();
    }
    // lbl_80262608
    JUTReportConsole_f("TotalSize %6.2f %06x\n\n", (1.0f / 1024.0f) * totalSize, totalSize);
}
#else
/* ############################################################################################## */
/* 80455008-80455010 003608 0004+04 1/1 0/0 0/0 .sdata2          @3772 */
SECTION_SDATA2 static f32 lit_3772[1 + 1 /* padding */] = {
    0.0009765625f,  // 1/1024
    /* padding */
    0.0f,
};

#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039A4E5 = "\nDynamicModuleControlBase::dump()\n";
SECTION_DEAD static char const* const stringBase_8039A508 = "Do  Lnk Size      Name\n";
SECTION_DEAD static char const* const stringBase_8039A520 = "(Null)";
SECTION_DEAD static char const* const stringBase_8039A527 = "%3d%3d%5.1f %05x %-4s %-24s ";
SECTION_DEAD static char const* const stringBase_8039A544 = "%3d%3d ???? ????? %-4s %-24s ";
SECTION_DEAD static char const* const stringBase_8039A562 = "\n";
SECTION_DEAD static char const* const stringBase_8039A564 = "TotalSize %6.2f %06x\n\n";
#pragma pop

/* 80455010-80455018 003610 0008+00 1/1 0/0 0/0 .sdata2          @3774 */
SECTION_SDATA2 static f64 lit_3774 = 4503599627370496.0 /* cast u32 to float */;

/* 80262470-80262660 25CDB0 01F0+00 2/0 2/2 0/0 .text            dump__24DynamicModuleControlBaseFv
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm void DynamicModuleControlBase::dump() {
    nofralloc
#include "asm/DynamicLink/dump__24DynamicModuleControlBaseFv.s"
}
#pragma pop
#endif

/* 80262660-802626D0 25CFA0 0070+00 0/0 2/2 0/0 .text            __ct__20DynamicModuleControlFPCc */
DynamicModuleControl::DynamicModuleControl(char const* name) {
    mModule = NULL;
    mBss = NULL;
    unk_24 = 0;
    mName = name;
    mResourceType = 0;
    unk_33 = 0;
    mChecksum = 0;
    mSize = 0;
    mAsyncLoadCallback = NULL;
}

/* ############################################################################################## */
/* 80451140-80451144 000640 0004+00 3/3 0/0 0/0 .sbss            sAllocBytes__20DynamicModuleControl
 */
u32 DynamicModuleControl::sAllocBytes;

/* 80451144-80451148 000644 0004+00 3/3 0/0 0/0 .sbss            sArchive__20DynamicModuleControl */
JKRArchive* DynamicModuleControl::sArchive;

/* 80451148-80451150 000648 0004+04 3/3 0/0 0/0 .sbss            sFileCache__20DynamicModuleControl
 */
JKRFileCache* DynamicModuleControl::sFileCache;

#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039A57B = "Base";
#pragma pop

/* 802626D0-8026275C 25D010 008C+00 1/1 0/0 0/0 .text mountCallback__20DynamicModuleControlFPv */
JKRArchive* DynamicModuleControl::mountCallback(void* param_0) {
    JKRExpHeap* heap = mDoExt_getArchiveHeap();
    sFileCache = JKRFileCache::mount("/rel/Final/Release", heap, NULL);
    sArchive = JKRArchive::mount("RELS.arc", JKRArchive::MOUNT_COMP, heap,
                                 JKRArchive::MOUNT_DIRECTION_HEAD);
    if (sArchive == NULL) {
        // "Mount failure, but if the archive isn't created, it was too slow %s\n"
        OSReport_Warning("マウント失敗ですが単にアーカイブを作ってないだけなら遅いだけです %s\n",
                         "RELS.arc");
    }
    return sArchive;
}

/* 8026275C-80262794 25D09C 0038+00 0/0 1/1 0/0 .text initialize__20DynamicModuleControlFv */
bool DynamicModuleControl::initialize() {
    sFileCache = NULL;
    sAllocBytes = 0;
    sArchive = NULL;
    mountCallback(NULL);
    return true;
}

/* 80262794-802627C0 25D0D4 002C+00 1/1 0/0 0/0 .text            callback__20DynamicModuleControlFPv
 */
void* DynamicModuleControl::callback(void* moduleControlPtr) {
    DynamicModuleControl* moduleControl = (DynamicModuleControl*)moduleControlPtr;
    moduleControl->do_load();
}

/* 802627C0-802627E8 25D100 0028+00 1/1 0/0 0/0 .text            calcSum2__FPCUsUl */
static u32 calcSum2(u16 const* data, u32 size) {
    u32 sum = 0;
    while (size > 0) {
        sum = sum + *data;
        size = size - 2;
        data++;
    }
    return sum;
}

#ifdef NONMATCHING
bool DynamicModuleControl::do_load() {
    if (mModule != NULL) {
        return true;
    }
    JKRExpHeap* heap = mDoExt_getArchiveHeap();
    s32 i = 0;
    while (true) {
        if (mModule != NULL) {
            JKRHeap::free(mModule, NULL);
            mModule = NULL;
        }
        char buffer[64];
        snprintf(buffer, 64, "%s.rel", mName);
        if (mModule == NULL && sArchive != NULL) {
            if (mModule == NULL) {
                mModule = (OSModuleInfo*)JKRArchive::getGlbResource('MMEM', buffer, sArchive);
                if (mModule != NULL) {
                    mResourceType = 1;
                }
            }
            if (mModule == NULL) {
                mModule = (OSModuleInfo*)JKRArchive::getGlbResource('AMEM', buffer, sArchive);
                if (mModule != NULL) {
                    mResourceType = 2;
                }
            }
            if (mModule == NULL) {
                mModule = (OSModuleInfo*)JKRArchive::getGlbResource('DMEM', buffer, sArchive);
                if (mModule != NULL) {
                    mResourceType = 3;
                }
            }
        }
        if (mModule != NULL) {
            mSize = sArchive->getExpandedResSize(mModule);
            JKRFileLoader::detachResource(mModule, NULL);
        } else if (mModule == NULL) {
            snprintf(buffer, 64, "/rel/Final/Release/%s.rel", mName);
            mModule = (OSModuleInfo*)JKRDvdRipper::loadToMainRAM(
                buffer, NULL, EXPAND_SWITCH_UNKNOWN1, 0, heap,
                JKRDvdRipper::ALLOC_DIRECTION_FORWARD, 0, NULL, NULL);
            if (mModule != NULL) {
                mSize = 0;
                mResourceType = 7;
            }
        }
        if (mModule == NULL && sFileCache != NULL) {
            mModule = (OSModuleInfo*)sFileCache->getResource('rels', buffer);
            if (mModule != NULL) {
                mSize = 0;
                mResourceType = 11;
                JKRFileLoader::detachResource(mModule, NULL);
            }
        }
        if (mModule == NULL) {
            // "DynamicModuleControl::do_load() Resource load failure [%s]\n"
            OSReport_Error(
                "\x44\x79\x6E\x61\x6D\x69\x63\x4D\x6F\x64\x75\x6C\x65\x43\x6F\x6E\x74\x72\x6F\x6C"
                "\x3A\x3A\x64\x6F\x5F\x6C\x6F\x61\x64\x28\x29\x20\x83\x8A\x83\x5C\x81\x5B\x83\x58"
                "\x93\xC7\x82\xDD\x8D\x9E\x82\xDD\x8E\xB8\x94\x73\x20\x5B\x25\x73\x5D\x0A",
                mName);
            return false;
        }
        if (mSize > 0) {
            u32 sum = calcSum2((u16*)mModule, mSize);
            if (unk_33 == 0) {
                mChecksum = sum;
                unk_33++;
            } else {
                u32 newsum = sum & 0xFFFF;
                if (newsum != mChecksum) {
                    OSReport_Error(
                        // "DynamicModuleControl::do_load() Checksum Error %04x %04x[%s]\n"
                        "DynamicModuleControl::do_load() チェックサムエラー %04x %04x[%s]\n",
                        newsum, mChecksum, mName);
                    unk_33 = 0;
                    i++;
                    if (i >= 3) {
                        return false;
                    }
                }
            }
            if (unk_33 < 0xFF) {
                unk_33++;
                return true;
            }
        }
        if (unk_33 < 0xFF) {
            unk_33++;
            return true;
        }
    }
}
#else
/* ############################################################################################## */
/* 8039A4A0-8039A4A0 026B00 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039A5E1 = "%s.rel";
SECTION_DEAD static char const* const stringBase_8039A5E8 = "/rel/Final/Release/%s.rel";
// MWCC ignores mapping of some japanese characters using the
// byte 0x5C (ASCII '\'). This is why this string is hex-encoded.
SECTION_DEAD static char const* const stringBase_8039A602 =
    "\x44\x79\x6E\x61\x6D\x69\x63\x4D\x6F\x64\x75\x6C\x65\x43\x6F\x6E\x74\x72\x6F\x6C\x3A\x3A\x64"
    "\x6F\x5F\x6C\x6F\x61\x64\x28\x29\x20\x83\x8A\x83\x5C\x81\x5B\x83\x58\x93\xC7\x82\xDD\x8D\x9E"
    "\x82\xDD"
    "\x8E\xB8\x94\x73\x20\x5B\x25\x73\x5D\x0A";
SECTION_DEAD static char const* const stringBase_8039A63D =
    "DynamicModuleControl::do_load() チェックサムエラー %04x %"
    "04x[%s]\n";
#pragma pop

/* 802627E8-80262AFC 25D128 0314+00 1/0 0/0 0/0 .text            do_load__20DynamicModuleControlFv
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm bool DynamicModuleControl::do_load() {
    nofralloc
#include "asm/DynamicLink/do_load__20DynamicModuleControlFv.s"
}
#pragma pop
#endif

/* 80262AFC-80262BC4 25D43C 00C8+00 1/0 0/0 0/0 .text do_load_async__20DynamicModuleControlFv */
bool DynamicModuleControl::do_load_async() {
    if (mAsyncLoadCallback == NULL) {
        if (mModule != NULL) {
            return true;
        }
        mAsyncLoadCallback = mDoDvdThd_callback_c::create(DynamicModuleControl::callback, this);
        if (mAsyncLoadCallback == NULL) {
            OSReport_Error(
                // "DynamicModuleControl::do_load_async() async load callback entry failure [%s]\n"
                "DynamicModuleControl::do_load_async() 非同期読み込みコールバック登録失敗 [%s]\n",
                mName);
        }
    }
    if (mAsyncLoadCallback != NULL && mAsyncLoadCallback->sync()) {
        mAsyncLoadCallback->destroy();
        mAsyncLoadCallback = NULL;
        return true;
    } else {
        return false;
    }
}

/* 80262BC4-80262C0C 25D504 0048+00 1/0 0/0 0/0 .text            do_unload__20DynamicModuleControlFv
 */
bool DynamicModuleControl::do_unload() {
    if (mModule != NULL) {
        JKRFree(mModule);
        mModule = NULL;
    }
    return true;
}

/* 80262C0C-80262C5C 25D54C 0050+00 1/0 0/0 0/0 .text            dump2__20DynamicModuleControlFv */
void DynamicModuleControl::dump2() {
    if (mModule != NULL) {
        OSSectionInfo* section = (OSSectionInfo*)mModule->info.sectionInfoOffset;
        OSSectionInfo* section2 = section + 1;
        u32 offset = section2->mOffset & ~(1);
        OSReport("%08x-%08x %08x %08x", mModule, offset, offset + section2->mSize);
    }
}

#ifdef NONMATCHING
BOOL DynamicModuleControl::do_link() {
    OSGetTime();
    if (mModule == NULL) {
        do_load();
    }

    if (mModule != NULL) {
        ASSERT(mModule->info.sectionInfoOffset < 0x80000000);
        ASSERT((u32)mModule + mModule->fixSize < 0x82000000);
        OSGetTime();
        OSGetTime();
        if (mModule->mModuleVersion >= 3) {
            u32 unk = mModule->fixSize;
            u32 unk3 = (unk + 0x1f) & ~0x1f;
            u32 unk2 = (u32)mModule + unk3;
            s32 size = JKRHeap::getSize(mModule, NULL);
            if (size < 0) {
                void* bss = JKRHeap::alloc(mModule->mBssSize, 0x20, NULL);
                if (bss == NULL) {
                    // "BSS Memory allocation failed\n"
                    OSReport_Error("BSSメモリ確保失敗\n");
                    goto end;
                } else {
                    mBss = bss;
                    BOOL linkResult = OSLink(mModule);
                    if (linkResult == FALSE) {
                        // "link failed\n"
                        OSReport_Error("リンク失敗\n");
                        goto end;
                    }
                }
            } else {
                if (mModule->mBssSize + unk < size) {
                    BOOL linkResult = OSLinkFixed(mModule, unk2);
                    if (linkResult == FALSE) {
                        // "link failed\n"
                        OSReport_Error("リンク失敗\n");
                        goto end;
                    } else {
                        s32 result = JKRHeap::resize(mModule, mModule->mBssSize + unk, NULL);
                        if (result < 0) {
                            // "Module size (resize) failed\n"
                            OSReport_Error("モジュールリサイズ(縮小)失敗\n");
                        }
                    }
                } else {  // lbl_80262DB0
                    s32 result = JKRHeap::resize(mModule, mModule->mBssSize + unk, NULL);
                    if (result > 0) {
                        BOOL linkResult = OSLinkFixed(mModule, unk2);
                        if (linkResult == FALSE) {
                            // "link failed\n"
                            OSReport_Error("リンク失敗\n");
                            goto end;
                        }
                    } else {  // lbl_80262DF0
                        void* bss = JKRHeap::alloc(mModule->mBssSize, 0x20, NULL);
                        if (bss == NULL) {
                            // "BSS Memory allocation failure [%x]\n"
                            OSReport_Error("BSSメモリ確保失敗 [%x]\n", mModule->mBssSize);
                            goto end;
                        } else {  // lbl_80262E2C
                            mBss = bss;
                            BOOL linkResult = OSLinkFixed(mModule, (u32)bss);
                            if (linkResult == FALSE) {
                                // "link failed\n"
                                OSReport_Error("リンク失敗\n");
                                goto end;
                            }
                            // lbl_80262E58
                            s32 result = JKRHeap::resize(mModule, unk3, NULL);
                            if (result < 0) {
                                // "Module size (resize) failed\n"
                                OSReport_Error("モジュールリサイズ(縮小)失敗\n");
                            }
                        }
                    }
                }
            }
        }
        // lbl_80262E84
        OSGetTime();
        sAllocBytes = sAllocBytes + getModuleSize();
        OSGetTime();
        unk_24 = mModule->prolog();
        OSGetTime();
        return TRUE;
    }

end:  // lbl_80262ECC
    unk_33 = 0;
    if (mBss != NULL) {
        JKRHeap::free(mBss, NULL);
        mBss = NULL;
    }
    if (mModule != NULL) {
        JKRHeap::free(mModule, NULL);
        mModule = NULL;
    }
    return FALSE;
}
#else
#pragma push
#pragma force_active on
SECTION_DEAD static char const* const stringBase_8039A6E2 = "BSSメモリ確保失敗\n";
SECTION_DEAD static char const* const stringBase_8039A6F5 = "リンク失敗\n";
SECTION_DEAD static char const* const stringBase_8039A701 = "モジュールリサイズ(縮小)失敗\n";
SECTION_DEAD static char const* const stringBase_8039A71F = "BSSメモリ確保失敗 [%x]\n";
#pragma pop

/* 80262C5C-80262F28 25D59C 02CC+00 1/0 0/0 0/0 .text            do_link__20DynamicModuleControlFv
 */
#pragma push
#pragma optimization_level 0
#pragma optimizewithasm off
asm BOOL DynamicModuleControl::do_link() {
    nofralloc
#include "asm/DynamicLink/do_link__20DynamicModuleControlFv.s"
}
#pragma pop
#endif

/* 80262F28-80263000 25D868 00D8+00 1/0 0/0 0/0 .text            do_unlink__20DynamicModuleControlFv
 */
bool DynamicModuleControl::do_unlink() {
    OSTime time1 = OSGetTime();
    mModule->epilog();
    OSTime time2 = OSGetTime();
    BOOL unklink = OSUnlink(mModule);
    OSTime time3 = OSGetTime();
    if (unklink == FALSE) {
        // "Unlink failed mModule=%08x mBss=%08x\n"
        OSReport_Error("アンリンク失敗 mModule=%08x mBss=%08x\n", mModule, mBss);
        return false;
    }
    sAllocBytes = sAllocBytes - getModuleSize();
    if (mBss != NULL) {
        JKRFree(mBss);
        mBss = NULL;
    }
    do_unload();
    return true;
}

/* 80263000-80263070 25D940 0070+00 1/0 0/0 0/0 .text getModuleSize__20DynamicModuleControlCFv */
int DynamicModuleControl::getModuleSize() const {
    if (mModule != NULL) {
        u32 size = JKRGetMemBlockSize(NULL, mModule);
        if (mBss != NULL) {
            JKRGetMemBlockSize(NULL, mBss);
        }
        return size + mModule->mBssSize;
    } else {
        return 0;
    }
}

/* 80263070-80263088 25D9B0 0018+00 1/0 0/0 0/0 .text
 * getModuleTypeString__20DynamicModuleControlCFv               */
const char* DynamicModuleControl::getModuleTypeString() const {
    static const char* strings[4] = {"????", "MEM", "ARAM", "DVD"};
    return strings[mResourceType & 3];
}

/* 803C34C0-803C34F4 0205E0 0034+00 1/1 2/2 0/0 .data            __vt__20DynamicModuleControl */
SECTION_DATA extern void* __vt__20DynamicModuleControl[13] = {
    (void*)NULL /* RTTI */,
    (void*)NULL,
    (void*)__dt__20DynamicModuleControlFv,
    (void*)getModuleName__20DynamicModuleControlCFv,
    (void*)getModuleSize__20DynamicModuleControlCFv,
    (void*)getModuleTypeString__20DynamicModuleControlCFv,
    (void*)dump__24DynamicModuleControlBaseFv,
    (void*)dump2__20DynamicModuleControlFv,
    (void*)do_load__20DynamicModuleControlFv,
    (void*)do_load_async__20DynamicModuleControlFv,
    (void*)do_unload__20DynamicModuleControlFv,
    (void*)do_link__20DynamicModuleControlFv,
    (void*)do_unlink__20DynamicModuleControlFv,
};

/* 80263088-8026308C 25D9C8 0004+00 0/0 0/0 756/756 .text            ModuleProlog */
extern "C" void ModuleProlog() {
    /* empty function */
}

/* 8026308C-80263090 25D9CC 0004+00 0/0 0/0 756/756 .text            ModuleEpilog */
extern "C" void ModuleEpilog() {
    /* empty function */
}

/* 80263090-8026314C 25D9D0 00BC+00 0/0 0/0 757/757 .text            ModuleUnresolved */
extern "C" void ModuleUnresolved() {
    // "\nError: Unlinked function was called.\n"
    OSReport_Error("\nError: リンクされていない関数が呼び出されました.\n");
    OSReport_Error("Address:      Back Chain    LR Save\n");
    u32 i = 0;
    u32* stackPtr = (u32*)OSGetStackPointer();
    while ((stackPtr != NULL) && ((u32)stackPtr != 0xFFFFFFFF) && (i++ < 0x10)) {
        OSReport_Error("0x%08x:   0x%08x    0x%08x\n", stackPtr, *stackPtr, *(stackPtr + 1));
        stackPtr = (u32*)*stackPtr;
    }
    OSReport_Error("\n");
}

/* 8026314C-80263190 25DA8C 0044+00 0/0 0/0 757/757 .text            ModuleConstructorsX */
extern "C" void ModuleConstructorsX(void (**ctors)()) {
    while (*ctors != 0) {
        (**ctors)();
        ctors++;
    }
}

/* 80263190-802631D4 25DAD0 0044+00 0/0 0/0 757/757 .text            ModuleDestructorsX */
extern "C" void ModuleDestructorsX(void (**dtors)()) {
    while (*dtors != 0) {
        (**dtors)();
        dtors++;
    }
}

/* 802631D4-802631DC 25DB14 0008+00 1/0 0/0 0/0 .text do_link__24DynamicModuleControlBaseFv */
BOOL DynamicModuleControlBase::do_link() {
    return TRUE;
}

/* 802631DC-802631E4 25DB1C 0008+00 1/0 0/0 0/0 .text do_load__24DynamicModuleControlBaseFv */
bool DynamicModuleControlBase::do_load() {
    return true;
}

/* 802631E4-802631EC 25DB24 0008+00 1/0 0/0 0/0 .text do_unload__24DynamicModuleControlBaseFv */
bool DynamicModuleControlBase::do_unload() {
    return true;
}

/* 802631EC-802631F4 25DB2C 0008+00 1/0 0/0 0/0 .text do_unlink__24DynamicModuleControlBaseFv */
bool DynamicModuleControlBase::do_unlink() {
    return true;
}

/* 802631F4-802631FC 25DB34 0008+00 1/0 0/0 0/0 .text do_load_async__24DynamicModuleControlBaseFv
 */
bool DynamicModuleControlBase::do_load_async() {
    return true;
}

/* 802631FC-80263200 25DB3C 0004+00 1/0 0/0 0/0 .text            dump2__24DynamicModuleControlBaseFv
 */
void DynamicModuleControlBase::dump2() {
    /* empty function */
}

/* 80263200-80263210 25DB40 0010+00 1/0 0/0 0/0 .text
 * getModuleTypeString__24DynamicModuleControlBaseCFv           */
const char* DynamicModuleControlBase::getModuleTypeString() const {
    return "Base";
}

/* 80263210-80263218 25DB50 0008+00 1/0 0/0 0/0 .text getModuleSize__24DynamicModuleControlBaseCFv
 */
int DynamicModuleControlBase::getModuleSize() const {
    return 0;
}

/* 80263218-80263220 25DB58 0008+00 1/0 0/0 0/0 .text getModuleName__20DynamicModuleControlCFv */
const char* DynamicModuleControl::getModuleName() const {
    return mName;
}

/* 8039A4A0-8039A4A0 026B00 0000+00 0/0 0/0 0/0 .rodata          @stringBase0 */
