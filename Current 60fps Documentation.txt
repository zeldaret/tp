================================================================================
TWILIGHT PRINCESS DECOMP - 60FPS MODIFICATIONS
================================================================================
Author: Boofener
Last Updated: 2025-01-28

This document tracks all modifications made to enable 60fps physics in the
Twilight Princess decomp project, using a dynamic deltatime system that can
support variable framerates (60fps, 120fps, 144fps, etc).

================================================================================
CORE DELTATIME SYSTEM
================================================================================

global.h
------------------------------------------------------------------------
Lines: 86-90

Added deltatime system declarations:
- extern float g_deltaTime;
  Global variable holding the current frame's deltatime value.
  At 60fps: ~0.5 (half movement per frame, twice as many frames)
  At 30fps: ~1.0 (vanilla behavior)
  At 120fps: ~0.25 (quarter movement per frame, four times as many frames)

- extern float g_targetFrameTime;
  Constant set to 1.0f / 30.0f (0.0333 seconds)
  Represents the target frame time for vanilla 30fps behavior

- #define FRAMERATE_SCALE g_deltaTime
  Macro used throughout the codebase to scale physics calculations
  Previously was hardcoded to 0.5f for testing, now uses dynamic deltatime

- void updateDeltaTime();
  Function declaration for deltatime update (implemented in m_Do_main.cpp)

How it works:
The deltatime system measures the actual time between frames and calculates
a scaling factor relative to 30fps. This allows all physics to scale
automatically regardless of framerate.

Formula: deltaTime = (actualFrameTime / targetFrameTime)
Example at 60fps: (16.67ms / 33.33ms) = 0.5
Example at 120fps: (8.33ms / 33.33ms) = 0.25


m_Do_main.cpp
------------------------------------------------------------------------
Lines: 43-74 (Implementation)
Line: 820 (Call site in main game loop)

Deltatime system implementation:

Variables:
- float g_deltaTime = 0.5f;
  Default value of 0.5 (60fps) used on first frame before timing starts

- float g_targetFrameTime = 1.0f / 30.0f;
  Target frame duration for vanilla 30fps (33.33ms)

- static OSTime s_lastFrameTime = 0;
  Stores the previous frame's timestamp for delta calculation

- static bool s_initialized = false;
  Tracks whether timing system has been initialized

updateDeltaTime() function flow:
1. Get current time using OSGetTime()
2. On first call: Initialize timing and return (uses default 0.5)
3. Calculate ticks elapsed since last frame
4. Convert ticks to milliseconds using OSTicksToMilliseconds()
5. Convert milliseconds to seconds
6. Calculate deltaTime = deltaSeconds / targetFrameTime
7. Clamp deltaTime between 0.1 (max 300fps) and 2.0 (min 15fps)
   - Prevents physics breakage during lag spikes or uncapped framerates
8. Store current time for next frame's calculation

Called once per frame in main game loop at line 820, right at the start of
the frame before any game logic updates.


================================================================================
LINK PHYSICS MODIFICATIONS - COMPLETE OVERVIEW
================================================================================

d_a_alink.cpp
------------------------------------------------------------------------
All Link physics modifications use FRAMERATE_SCALE for proper 60fps behavior.

KEY DISCOVERY: ROOT SCALING APPROACH
-------------------------------------
After extensive testing, we discovered that scaling gravity and velocity at
their ROOT SOURCE is the cleanest and most maintainable approach. Instead of
scaling at every application point, we scale once at the source.

This approach eliminates the need for special-case code scattered throughout
the physics system and ensures consistent behavior across all movement types.


CRITICAL CONCEPTS
-----------------
- mNormalSpeed: Link's intended movement speed (units per frame at 30fps)
- speedF: Actual horizontal movement applied each frame (mNormalSpeed * FRAMERATE_SCALE)
- speed.x/y/z: Velocity vector (units per frame)
- gravity: Downward acceleration (units per frame²)
- At 60fps: All values are scaled so 2× frames = same total distance/velocity


================================================================================
ROOT SCALING IMPLEMENTATIONS
================================================================================

1. GRAVITY SCALING AT SOURCE
-----------------------------
Location: Line 12547 in setSpecialGravity()

    // Boofener: Scale gravity at source for 60fps - now gravity applications don't need scaling
    gravity = i_gravity * FRAMERATE_SCALE;
    maxFallSpeed = i_speed;

How it works:
- ALL gravity values pass through setSpecialGravity() when they're set
- We scale gravity ONCE here, at the source
- Now all gravity applications throughout the code use vanilla logic: speed.y += gravity;
- No need to scale at every += gravity site

Why this is correct:
At 30fps: gravity = -3.4, applied 30 times/sec
At 60fps: gravity = -1.7 (scaled), applied 60 times/sec
Result: Same total downward acceleration per second

Example gravity values (from daAlinkHIO_autoJump_c0):
- mGravity = -3.4 (at offset 0x74 in HIO data)
- At 60fps, this becomes: -3.4 * 0.5 = -1.7
- Applied twice as often = same jump arc

Locations where gravity is applied (all use vanilla code now):
- Line 12841: speed.y += gravity; (heavy boots/swim dive)
- Line 12847: speed.y += gravity; (floating in water)
- Line 12872: speed.y += gravity * 2.25f; (heavy state, 2.25× multiplier)
- Line 12879: speed.y += gravity; (normal falling)
- Line 12888: speed.y += gravity; (board riding)
- Line 12923: speed.y = gravity; (sumou mode)
- Many more throughout the file - ALL use vanilla code


2. VERTICAL VELOCITY SCALING AT APPLICATION
--------------------------------------------
Location: Lines 12903-12915 in posMove()

    // Boofener: Scale Y velocity at application point for 60fps
    current.pos.x += speed.x;
    current.pos.y += speed.y * FRAMERATE_SCALE;
    current.pos.z += speed.z;

How it works:
- speed.y is set in vanilla units throughout the code (e.g., jump init, gravity application)
- When we UPDATE POSITION, we scale speed.y by FRAMERATE_SCALE
- This means speed.y can remain in vanilla units everywhere else
- Only scaled at the ONE place where position is updated

Why this is correct:
- Initial jump velocity: speed.y = 20.0 (set in vanilla units)
- At 30fps: pos.y += 20.0 (moves 20 units)
- At 60fps: pos.y += 20.0 * 0.5 = 10.0 (moves 10 units, but twice as often)
- Result: Same jump height

This is applied in TWO locations in posMove():
1. Lines 12904-12906: When magnet boots are on
2. Lines 12911-12913: Normal movement

Both use the same pattern: scale speed.y at application, not at source.


WHY TWO DIFFERENT APPROACHES?
------------------------------
Gravity: Scaled at SOURCE (setSpecialGravity)
- Reason: Gravity is SET once and APPLIED many times
- Scaling at source means we don't need to scale at 20+ application sites
- Cleaner code, less chance for bugs

Vertical Velocity: Scaled at APPLICATION (posMove)
- Reason: speed.y is SET in many places (jumps, animations, special moves)
- Scaling at application means speed.y stays in vanilla units everywhere
- Easier to debug, easier to add new movement types
- Only 2 scaling sites instead of 50+ speed.y assignment sites


================================================================================
HORIZONTAL MOVEMENT SCALING
================================================================================

Line 12752: Movement Speed Calculation
---------------------------------------
    // Boofener: Scale all horizontal movement by deltatime
    speedF = mNormalSpeed * (1.0f - fabsf(mSpeedModifier)) * FRAMERATE_SCALE;

This is the core horizontal movement calculation. Every frame, Link's
mNormalSpeed is scaled by FRAMERATE_SCALE to get the actual movement distance.

Example:
- Running speed (mNormalSpeed): 23.0 units/frame at 30fps
- At 60fps: speedF = 23.0 * 0.5 = 11.5 units/frame
- Result: 11.5 units * 60 frames = 690 units/sec (same as 23 * 30)

Important: mNormalSpeed stays in VANILLA UNITS (30fps values)
- When set from HIO data, it's NOT scaled
- Only scaled when converted to speedF
- This keeps all the game logic in familiar 30fps units


================================================================================
SPECIAL CASES & COMPENSATIONS
================================================================================

1. ROLL SPEED FIX (CRITICAL)
----------------------------
Lines 15926-15932:

    // Boofener: speedF at this point has already been scaled down by FRAMERATE_SCALE,
    // so unscale it before calculating roll speed to get proper vanilla mNormalSpeed value
    f32 unscaledSpeedF = speedF / FRAMERATE_SCALE;
    mNormalSpeed =
        unscaledSpeedF * daAlinkHIO_frontRoll_c0::m.mSpeedRate + daAlinkHIO_frontRoll_c0::m.mInitSpeed;

Problem:
When Link enters a roll, the game calculates the new mNormalSpeed based on
the current speedF value. However, speedF has already been scaled down by
FRAMERATE_SCALE in the movement update. Without compensation, this causes:
- At 30fps: speedF = 23.0, roll calculates correctly (~32.9)
- At 60fps: speedF = 11.5, roll calculates wrong (~16.45 instead of 32.9)

Solution:
Divide speedF by FRAMERATE_SCALE before using it in the roll speed formula.
This "unscales" it back to the equivalent 30fps value, allowing the formula
to calculate the correct roll speed.

Math:
- speedF entering roll at 60fps: 11.5 (already scaled)
- unscaledSpeedF: 11.5 / 0.5 = 23.0 (back to 30fps equivalent)
- Roll speed: 23.0 * rate + init = ~32.9 (correct!)
- This 32.9 then gets scaled by FRAMERATE_SCALE in movement update

Why this matters:
Without this fix, Link would roll too slowly at 60fps, and in some cases
would bonk into walls where vanilla doesn't (e.g., backflip from Link's
ladder + forward roll).


2. ROLL DECELERATION
--------------------
Lines 15977, 16006, 16015:

    cLib_chaseF(&mNormalSpeed, 0.0f, 2.5f * FRAMERATE_SCALE);

Roll deceleration is scaled so it happens at the same real-world rate:
- At 30fps: 2.5 units/frame deceleration
- At 60fps: 1.25 units/frame (half speed, twice as many frames)


3. SMALL JUMP VELOCITY CALCULATION
-----------------------------------
Lines 17066-17076:

    mNormalSpeed = daAlinkHIO_smallJump_c0::m.mSpeedH / FRAMERATE_SCALE;

    if (checkHeavyStateOn(1, 1) && !checkNoResetFlg0(FLG0_UNDERWATER)) {
        f32 temp = daAlinkHIO_smallJump_c0::m.mTargetHeightOffset +
                    (field_0x3478 - current.pos.y);
        speed.y = JMAFastSqrt(2.0f * (temp * -gravity * 2.25f)); // gravity is already scaled
    } else {
        speed.y = JMAFastSqrt(2.0f * ((-gravity) * (daAlinkHIO_smallJump_c0::m.mTargetHeightOffset +
                                                     (field_0x3478 - current.pos.y)))); // gravity is already scaled
    }

Special handling:
- Horizontal speed: Divided by FRAMERATE_SCALE (compensates for speedF scaling)
- Vertical speed: Uses gravity in calculation (gravity is already pre-scaled)
- Square root formula calculates exact velocity needed to reach target height
- No additional scaling needed since gravity is already scaled


4. AUTO JUMP (FORWARD JUMP)
----------------------------
Lines 16564-16574:

    mNormalSpeed = speedF * daAlinkHIO_autoJump_c0::m.mJumpSpeedRate;
    speed.y = mNormalSpeed * cM_ssin(angle);
    mNormalSpeed *= cM_scos(angle);

    // Boofener: Vertical velocity scaled at posMove(), horizontal speed scaled later in speedF calculation

No special scaling needed:
- speed.y is set in vanilla units
- Gets scaled when applied in posMove()
- Horizontal component (mNormalSpeed) gets scaled in speedF calculation


================================================================================
SWORD CHARGE AUDIO FIX (IN PROGRESS)
================================================================================

Line 17606-17614: Sword Charge Timer
-------------------------------------
    // Boofener: Sword charge timer decrements at 30fps rate for consistent audio
    if (mSwordUpTimer != 0) {
        static int sFrameCounter = 0;
        sFrameCounter++;
        if (sFrameCounter >= (int)(1.0f / FRAMERATE_SCALE)) {
            mSwordUpTimer--;
            sFrameCounter = 0;
        }
    }

Problem:
The sword charge audio plays too fast at 60fps because mSwordUpTimer was
decrementing every frame instead of every 30fps-equivalent frame.

Solution:
Use a frame counter to only decrement the timer every N frames, where N is
determined by the framerate (at 60fps, N=2, so decrements every other frame).

Status: PARTIALLY FIXED
- The timer now decrements at the correct rate
- The beam traveling sound may still not be playing (needs investigation)


================================================================================
IMPORTANT NOTES & DISCOVERIES
================================================================================

WHAT WE LEARNED ABOUT PHYSICS SCALING
--------------------------------------
1. WRONG APPROACH (what we tried first):
   - Scaling gravity at every application point: speed.y += gravity * FRAMERATE_SCALE
   - Problem: Too many places to modify, easy to miss spots, harder to maintain

2. CORRECT APPROACH (what we do now):
   - Scale gravity at source: gravity = i_gravity * FRAMERATE_SCALE (in setSpecialGravity)
   - Scale velocity at application: current.pos.y += speed.y * FRAMERATE_SCALE (in posMove)
   - Result: Clean code, vanilla logic everywhere except 3 key locations

3. WHY THE OLD APPROACH WAS WRONG:
   - We were multiplying gravity by FRAMERATE_SCALE at every += site
   - This meant gravity was in "scaled units" throughout the code
   - But then calculations using gravity (like jump velocity = sqrt(2 * g * h)) were wrong
   - Had to add compensation multipliers everywhere
   - Created a mess of special cases

4. THE "AHA" MOMENT:
   - Gravity should be scaled at SOURCE (where it's SET)
   - Velocity should be scaled at APPLICATION (where position is UPDATED)
   - This keeps all intermediate calculations in vanilla units
   - Only 3 places need scaling instead of 50+


PROC_SIDESTEP ENUM DISCOVERY
-----------------------------
During development, we discovered that PROC_SIDESTEP is enum value 10 (0x00A),
NOT 7 as we initially assumed by counting the procs table.

Location: d_a_alink.h line 933
    /* 0x00A */ PROC_SIDESTEP,
    /* 0x00B */ PROC_SIDESTEP_LAND,

The procs table at d_a_alink.cpp line 206 is indexed by these enum values,
not by array position. This caused early attempts at sidestep-specific scaling
to fail because we were checking (procID == 7) instead of (procID == 10).

This discovery led to the realization that sidestep doesn't NEED special
scaling - the root scaling approach handles it automatically!


SIDESTEP BEHAVIOR AT 60FPS
---------------------------
Current status: WORKING PERFECTLY with no special-case code

How it works:
1. Sidestep init sets speed.y and mNormalSpeed in vanilla units (no scaling)
2. Horizontal: mNormalSpeed → speedF (scaled in line 12752)
3. Vertical: speed.y → position (scaled in posMove at line 12912)
4. Gravity: Pre-scaled in setSpecialGravity (line 12547)
5. Result: Correct distance, correct airtime, correct arc

No special code needed - root scaling handles everything!


ANIMATION TIMING
----------------
Animations are NOT scaled by FRAMERATE_SCALE. They advance at a fixed rate:
- Line 5553: frame = i_anm->getFrame() + 1.0f; (NOT scaled)
- Animations play at same speed, just rendered more smoothly at higher FPS
- This is correct because animation data is authored for 30fps playback


GRAVITY VALUE REFERENCE
------------------------
From daAlinkHIO_autoJump_c0 (d_a_alink_HIO_data.inc line 1061):
- mGravity = -3.4f (vanilla value at 30fps)
- At 60fps becomes: -3.4 * 0.5 = -1.7
- Negative value means downward acceleration


================================================================================
TESTING & VERIFICATION
================================================================================

Current Status:
- ✓ Deltatime system implemented and working at 60fps
- ✓ Link's movement speed matches vanilla at 60fps
- ✓ Jump heights and arcs correct at 60fps (all jump types)
- ✓ Sidestep distance, airtime, and arc correct at 60fps
- ✓ Roll speed and distance matches vanilla at 60fps
- ✓ No bonking issues in tested scenarios
- ✓ Root scaling approach confirmed working for all movement
- ⚠ Sword charge audio partially fixed (timer works, beam sound investigation ongoing)
- ⚠ Higher framerates (120fps, 144fps) not yet testable due to engine limitations
  (Game loop currently locked to 60fps maximum via JFWDisplay.cpp vsync bypass)

Known Limitations:
- OSReport() debug logging doesn't appear in Dolphin log window (version specific)
- Engine appears to be hard-locked at 60fps, cannot test 120fps+ without
  additional engine modifications
- Deltatime system is ready for higher framerates but untested
- Sword charge beam sound may not be playing correctly (needs investigation)

Test Scenarios Verified at 60fps:
1. Basic movement (walking, running) - Speed matches vanilla ✓
2. Forward jumps - Height and distance match vanilla ✓
3. Sidesteps (left/right/back) - Distance, airtime, arc all match vanilla ✓
4. Rolling - Speed and distance match vanilla ✓
5. Roll after backflip from Link's ladder - No bonking (vanilla behavior) ✓
6. Gravity and falling - Matches vanilla behavior ✓
7. Swimming and underwater movement - Correct physics ✓
8. Heavy state gravity (2.25× multiplier) - Working correctly ✓

Next Steps:
- Fix sword charge beam audio (investigate mSwordUpTimer usage)
- Identify and unlock engine framerate cap to test 120fps+
- Apply FRAMERATE_SCALE to other actors/systems as needed
- Test cutscenes and boss battles


================================================================================
FRAMERATES & DELTATIME VALUES
================================================================================

Target Framerate: 30fps (vanilla)
- deltaTime = 1.0
- Frame time: 33.33ms
- Link running: 23.0 units/frame = 690 units/sec
- Gravity: -3.4 units/frame²

Current Framerate: 60fps
- deltaTime = 0.5
- Frame time: 16.67ms
- Link running: 11.5 units/frame * 60 = 690 units/sec ✓
- Gravity: -1.7 units/frame² * 60 = -102 units/sec² ✓

Future Support: 120fps
- deltaTime = 0.25
- Frame time: 8.33ms
- Link running: 5.75 units/frame * 120 = 690 units/sec (theoretical)
- Gravity: -0.85 units/frame² * 120 = -102 units/sec² (theoretical)

Future Support: 144fps
- deltaTime = 0.208
- Frame time: 6.94ms
- Link running: 4.78 units/frame * 144 = 688 units/sec (theoretical)
- Gravity: -0.71 units/frame² * 144 = -102 units/sec² (theoretical)


================================================================================
FRAMERATE UNLOCK
================================================================================

JFWDisplay.cpp
------------------------------------------------------------------------
Line: 375

if (false) { // Boofener: Changed p1 != 0 to false (unlock fps)

This change bypasses the game's internal 30fps vsync lock, allowing the game
to run at 60fps. The original condition was (p1 != 0) which enforced vsync.

Effect:
- Game can now run at 60fps instead of being locked to 30fps
- Does NOT unlock framerates beyond 60fps (additional engine work needed)
- Works in conjunction with deltatime system for proper physics


d_map_path.cpp
------------------------------------------------------------------------
Line: 273

#define HYRULE_FIELD_SPEEDHACK

Enabled Hyrule Field rendering optimization for better emulator performance
in large open areas. This makes the minimap render at lower quality but
significantly improves framerate in Hyrule Field.

Not directly related to 60fps physics, but helps maintain stable 60fps
in demanding areas.


================================================================================
FILE MODIFICATION SUMMARY
================================================================================

Modified Files:
1. include/global.h - Deltatime system declarations and FRAMERATE_SCALE macro
2. src/m_Do/m_Do_main.cpp - Deltatime implementation and main loop integration
3. src/d/actor/d_a_alink.cpp - Link physics scaling (complete overhaul)
   - Line 2: Header comment
   - Line 12547: Gravity scaling at source (setSpecialGravity)
   - Line 12752: Horizontal movement scaling
   - Lines 12904-12906, 12911-12913: Vertical velocity scaling in posMove()
   - Line 15926-15932: Roll speed compensation
   - Lines 15977, 16006, 16015: Roll deceleration scaling
   - Lines 17067-17076: Small jump velocity handling
   - Lines 17606-17614: Sword charge timer fix (partial)
   - Multiple animation rate scalings throughout
4. src/JSystem/JFramework/JFWDisplay.cpp - Vsync unlock for 60fps
5. src/d/d_map_path.cpp - Hyrule Field speedhack enabled

New Files:
- Current 60fps Documentation.txt (this file)
- sidehop_current_implementation.txt (historical notes, mostly outdated)


================================================================================
CODE PATTERNS & BEST PRACTICES
================================================================================

When adding new movement types or physics, follow these patterns:

1. For horizontal movement:
   - Set mNormalSpeed in vanilla 30fps units
   - Let speedF calculation handle the scaling (line 12752)
   - Example: mNormalSpeed = 25.0f; (NOT 25.0f * FRAMERATE_SCALE)

2. For vertical movement:
   - Set speed.y in vanilla 30fps units
   - Scaling happens automatically in posMove()
   - Example: speed.y = 20.0f; (NOT 20.0f * FRAMERATE_SCALE)

3. For gravity:
   - Set gravity through setSpecialGravity() or initGravity()
   - Gravity gets scaled at source automatically
   - Apply with vanilla code: speed.y += gravity; (NOT += gravity * FRAMERATE_SCALE)

4. For deceleration/acceleration:
   - Scale the rate by FRAMERATE_SCALE
   - Example: cLib_chaseF(&mNormalSpeed, 0.0f, 2.5f * FRAMERATE_SCALE);

5. For timers:
   - Most timers should count in real frames (no scaling needed)
   - Special timers tied to audio/effects may need frame counting
   - See mSwordUpTimer for an example of frame-counted timer

6. For animations:
   - DO NOT scale animation frame advancement
   - Animations play at authored speed, rendered more smoothly at higher FPS
   - Only scale animation RATES when speeding up/slowing down animations


DEBUGGING TIPS
--------------
1. If movement is too fast: Check if you're scaling something twice
2. If movement is too slow: Check if you forgot to scale something
3. If distance is correct but feels wrong: Could be animation timing issue
4. If jump arc is wrong: Check gravity scaling in setSpecialGravity()
5. Use vanilla 30fps units in calculations, let the system handle scaling


================================================================================
END OF DOCUMENTATION
================================================================================
